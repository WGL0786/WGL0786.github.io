<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>
         WGL
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="第1章 Java基础 # 1.1 重写和重载的区别 # 重写（Override）：方法名与参数名都一样，返回类型也一样。 重载（Overload）：方法名相同参数不同，返回类型也可以修改。 ​	总的来说，重写和重载都是 Java 中常用的方法定义方式，它们的区别在于是否改变方法的行为以及如何进行方法调用。重写强调子类对父类的覆盖和多态性，重载强调相同方法名但不同参数列表的重载和方法重载的方便性。
1.2 String 和 StringBuffer、StringBuilder 的区别是什么，String 为什么是不可变的 # String 类是不可变的，即一旦创建就不能被修改。而 StringBuffer 和 StringBuilder 是可变的，可以进行修改操作。 String 类是线程安全的，可以在多线程环境下被共享。StringBuffer 也是线程安全的，支持多线程并发操作。而 StringBuilder 则是非线程安全的，适合单线程环境下的操作。 String 类的拼接操作（使用&#43;连接多个字符串）会创建新的String对象，导致内存消耗较大。而 StringBuffer 和 StringBuilder 的拼接操作则是直接在原有的对象上进行修改，不会创建新的对象，因此更加高效。 String 类的内部实现采用了字符数组的形式存储，而 StringBuffer 和 StringBuilder 的内部实现则采用了字符数组和可变容量缓冲区的形式存储，使得它们更加高效地支持字符串的修改操作。 ​	关于为什么 String 是不可变的，主要是为了保证字符串常量的安全性和不可更改性。如果 String 是可变的，那么任何一个持有该字符串引用的地方都可以修改它的值，这会导致安全问题和不可预期的行为。为了避免这种问题，Java 中将 String 设计成了不可变的类，保证了字符串常量的不可修改性，同时也提高了内存使用效率和程序的运行效率。
1.3 自动装箱与拆箱 # ​	自动装箱和拆箱是 Java 5 中引入的特性，用于简化基本数据类型和对应包装类型之间的转换操作。
​	自动装箱（Autoboxing）是指将基本数据类型转换为对应的包装类型的过程，例如将 int 类型的数据赋值给 Integer 类型的变量。自动装箱由编译器自动完成，避免了手动进行装箱操作的繁琐。
示例代码：
int num = 10; Integer numObj = num; // 自动装箱 ​	自动拆箱（Unboxing）是指将包装类型转换为对应的基本数据类型的过程，例如将 Integer 类型的数据赋值给 int 类型的变量。自动拆箱也由编译器自动完成，避免了手动进行拆箱操作的繁琐。"
/>
<meta
  name="keywords"
  content=""
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="http://WGL0786.github.io/post/myprofile/" />







<link rel="stylesheet" href="/css/style.css" />

<link rel="stylesheet" href="http://WGL0786.github.io/style.css" />


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://WGL0786.github.io/img/apple-touch-icon-144-precomposed.png" />
<link rel="shortcut icon" href="http://WGL0786.github.io/img/favicon.png" />


<link href="/fonts/Inter-Italic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/fonts/Inter-Regular.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/fonts/Inter-Medium.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/fonts/Inter-MediumItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/fonts/Inter-Bold.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="/fonts/Inter-BoldItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="第1章 Java基础 # 1.1 重写和重载的区别 # 重写（Override）：方法名与参数名都一样，返回类型也一样。 重载（Overload）：方法名相同参数不同，返回类型也可以修改。 ​	总的来说，重写和重载都是 Java 中常用的方法定义方式，它们的区别在于是否改变方法的行为以及如何进行方法调用。重写强调子类对父类的覆盖和多态性，重载强调相同方法名但不同参数列表的重载和方法重载的方便性。
1.2 String 和 StringBuffer、StringBuilder 的区别是什么，String 为什么是不可变的 # String 类是不可变的，即一旦创建就不能被修改。而 StringBuffer 和 StringBuilder 是可变的，可以进行修改操作。 String 类是线程安全的，可以在多线程环境下被共享。StringBuffer 也是线程安全的，支持多线程并发操作。而 StringBuilder 则是非线程安全的，适合单线程环境下的操作。 String 类的拼接操作（使用&#43;连接多个字符串）会创建新的String对象，导致内存消耗较大。而 StringBuffer 和 StringBuilder 的拼接操作则是直接在原有的对象上进行修改，不会创建新的对象，因此更加高效。 String 类的内部实现采用了字符数组的形式存储，而 StringBuffer 和 StringBuilder 的内部实现则采用了字符数组和可变容量缓冲区的形式存储，使得它们更加高效地支持字符串的修改操作。 ​	关于为什么 String 是不可变的，主要是为了保证字符串常量的安全性和不可更改性。如果 String 是可变的，那么任何一个持有该字符串引用的地方都可以修改它的值，这会导致安全问题和不可预期的行为。为了避免这种问题，Java 中将 String 设计成了不可变的类，保证了字符串常量的不可修改性，同时也提高了内存使用效率和程序的运行效率。
1.3 自动装箱与拆箱 # ​	自动装箱和拆箱是 Java 5 中引入的特性，用于简化基本数据类型和对应包装类型之间的转换操作。
​	自动装箱（Autoboxing）是指将基本数据类型转换为对应的包装类型的过程，例如将 int 类型的数据赋值给 Integer 类型的变量。自动装箱由编译器自动完成，避免了手动进行装箱操作的繁琐。
示例代码：
int num = 10; Integer numObj = num; // 自动装箱 ​	自动拆箱（Unboxing）是指将包装类型转换为对应的基本数据类型的过程，例如将 Integer 类型的数据赋值给 int 类型的变量。自动拆箱也由编译器自动完成，避免了手动进行拆箱操作的繁琐。"/>



<meta property="og:title" content="" />
<meta property="og:description" content="第1章 Java基础 # 1.1 重写和重载的区别 # 重写（Override）：方法名与参数名都一样，返回类型也一样。 重载（Overload）：方法名相同参数不同，返回类型也可以修改。 ​	总的来说，重写和重载都是 Java 中常用的方法定义方式，它们的区别在于是否改变方法的行为以及如何进行方法调用。重写强调子类对父类的覆盖和多态性，重载强调相同方法名但不同参数列表的重载和方法重载的方便性。
1.2 String 和 StringBuffer、StringBuilder 的区别是什么，String 为什么是不可变的 # String 类是不可变的，即一旦创建就不能被修改。而 StringBuffer 和 StringBuilder 是可变的，可以进行修改操作。 String 类是线程安全的，可以在多线程环境下被共享。StringBuffer 也是线程安全的，支持多线程并发操作。而 StringBuilder 则是非线程安全的，适合单线程环境下的操作。 String 类的拼接操作（使用&#43;连接多个字符串）会创建新的String对象，导致内存消耗较大。而 StringBuffer 和 StringBuilder 的拼接操作则是直接在原有的对象上进行修改，不会创建新的对象，因此更加高效。 String 类的内部实现采用了字符数组的形式存储，而 StringBuffer 和 StringBuilder 的内部实现则采用了字符数组和可变容量缓冲区的形式存储，使得它们更加高效地支持字符串的修改操作。 ​	关于为什么 String 是不可变的，主要是为了保证字符串常量的安全性和不可更改性。如果 String 是可变的，那么任何一个持有该字符串引用的地方都可以修改它的值，这会导致安全问题和不可预期的行为。为了避免这种问题，Java 中将 String 设计成了不可变的类，保证了字符串常量的不可修改性，同时也提高了内存使用效率和程序的运行效率。
1.3 自动装箱与拆箱 # ​	自动装箱和拆箱是 Java 5 中引入的特性，用于简化基本数据类型和对应包装类型之间的转换操作。
​	自动装箱（Autoboxing）是指将基本数据类型转换为对应的包装类型的过程，例如将 int 类型的数据赋值给 Integer 类型的变量。自动装箱由编译器自动完成，避免了手动进行装箱操作的繁琐。
示例代码：
int num = 10; Integer numObj = num; // 自动装箱 ​	自动拆箱（Unboxing）是指将包装类型转换为对应的基本数据类型的过程，例如将 Integer 类型的数据赋值给 int 类型的变量。自动拆箱也由编译器自动完成，避免了手动进行拆箱操作的繁琐。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://WGL0786.github.io/post/myprofile/" /><meta property="article:section" content="post" />








  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >hello friend</span
    >
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
        <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/showcase">Showcase</a></li>
        
      
      
      
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/showcase">Showcase</a></li>
      
    
  </ul>
</nav>

        <span class="menu-trigger">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M0 0h24v24H0z" fill="none" />
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z" />
          </svg>
        </span>
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <article class="post">
    <h1 class="post-title"></h1>
    <div class="post-meta">
      

      


      
    </div>

    

    

    <div class="post-content">
      
      <h1 id="第1章-java基础">
  第1章 Java基础
  <a href="#%e7%ac%ac1%e7%ab%a0-java%e5%9f%ba%e7%a1%80" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="11-重写和重载的区别">
  1.1 重写和重载的区别
  <a href="#11-%e9%87%8d%e5%86%99%e5%92%8c%e9%87%8d%e8%bd%bd%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<ul>
<li>重写（Override）：方法名与参数名都一样，返回类型也一样。</li>
<li>重载（Overload）：方法名相同参数不同，返回类型也可以修改。</li>
</ul>
<p>​		总的来说，重写和重载都是 Java 中常用的方法定义方式，它们的区别在于是否改变方法的行为以及如何进行方法调用。重写强调子类对父类的<strong>覆盖</strong>和多态性，重载强调相同方法名但不同参数列表的重载和方法重载的方便性。</p>
<h3 id="12-string-和-stringbufferstringbuilder-的区别是什么string-为什么是不可变的">
  1.2 String 和 StringBuffer、StringBuilder 的区别是什么，String 为什么是不可变的
  <a href="#12-string-%e5%92%8c-stringbufferstringbuilder-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88string-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%8d%e5%8f%af%e5%8f%98%e7%9a%84" class="h-anchor" aria-hidden="true">#</a>
</h3>
<ol>
<li>String 类是不可变的，即一旦创建就不能被修改。而 StringBuffer 和 StringBuilder 是可变的，可以进行修改操作。</li>
<li>String 类是线程安全的，可以在多线程环境下被共享。StringBuffer 也是线程安全的，支持多线程并发操作。而 StringBuilder 则是非线程安全的，适合单线程环境下的操作。</li>
<li>String 类的拼接操作（使用+连接多个字符串）会创建新的String对象，导致内存消耗较大。而 StringBuffer 和 StringBuilder 的拼接操作则是直接在原有的对象上进行修改，不会创建新的对象，因此更加高效。</li>
<li>String 类的内部实现采用了字符数组的形式存储，而 StringBuffer 和 StringBuilder 的内部实现则采用了字符数组和可变容量缓冲区的形式存储，使得它们更加高效地支持字符串的修改操作。</li>
</ol>
<p>​		关于为什么 String 是不可变的，主要是为了保证字符串常量的安全性和不可更改性。如果 String 是可变的，那么任何一个持有该字符串引用的地方都可以修改它的值，这会导致安全问题和不可预期的行为。为了避免这种问题，Java 中将 String 设计成了不可变的类，保证了字符串常量的不可修改性，同时也提高了内存使用效率和程序的运行效率。</p>
<h3 id="13-自动装箱与拆箱">
  1.3 自动装箱与拆箱
  <a href="#13-%e8%87%aa%e5%8a%a8%e8%a3%85%e7%ae%b1%e4%b8%8e%e6%8b%86%e7%ae%b1" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		自动装箱和拆箱是 Java 5 中引入的特性，用于简化基本数据类型和对应包装类型之间的转换操作。</p>
<p>​		自动装箱（Autoboxing）是指将基本数据类型转换为对应的包装类型的过程，例如将 int 类型的数据赋值给 Integer 类型的变量。自动装箱由编译器自动完成，避免了手动进行装箱操作的繁琐。</p>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>Integer numObj <span style="color:#f92672">=</span> num<span style="color:#f92672">;</span> <span style="color:#75715e">// 自动装箱
</span></span></span></code></pre></div><p>​		自动拆箱（Unboxing）是指将包装类型转换为对应的基本数据类型的过程，例如将 Integer 类型的数据赋值给 int 类型的变量。自动拆箱也由编译器自动完成，避免了手动进行拆箱操作的繁琐。</p>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span>Integer numObj <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> numObj<span style="color:#f92672">;</span> <span style="color:#75715e">// 自动拆箱
</span></span></span></code></pre></div><p>​		自动装箱和拆箱在一定程度上简化了代码编写和阅读，但也需要注意它们可能带来的性能问题。因为自动装箱和拆箱操作需要创建额外的对象和执行额外的方法调用，会带来一定的开销。在对性能要求较高的场景中，需要注意使用装箱和拆箱操作的次数和方式，避免对性能造成过大的影响。</p>
<h3 id="14--与-equals的区别">
  1.4 == 与 equals的区别
  <a href="#14--%e4%b8%8e-equals%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在  Java 中，== 和 equals 都是用于比较两个对象是否相等的操作，但它们的比较方式和作用略有不同。</p>
<ol>
<li>
<p>== 用于比较两个对象的<strong>引用地址</strong>是否相同。当比较基本数据类型时，比较的是它们的值。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String str1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>String str2 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>str1 <span style="color:#f92672">==</span> str2<span style="color:#f92672">);</span> <span style="color:#75715e">// true
</span></span></span></code></pre></div><p>上述代码中，str1 和 str2 的引用地址相同，因此 == 比较的结果为 true。</p>
</li>
<li>
<p>equals 用于比较两个对象的<strong>内容</strong>是否相同。equals 是 Object 类的方法，在 Java 中的所有类都继承了 Object 类，因此默认都具有 equals 方法。但是，如果没有对 equals 方法进行重写，equals 默认会和 == 一样比较引用地址。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String str1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>String str2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>str1<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>str2<span style="color:#f92672">));</span> <span style="color:#75715e">// true
</span></span></span></code></pre></div><p>上述代码中，虽然 str1 和 str2 的引用地址不同，但是它们的内容相同，因此 equals 比较的结果为 true。</p>
</li>
</ol>
<p>​		需要注意的是，如果自定义类想要使用 equals 比较对象的内容是否相同，需要对 equals 方法进行<strong>重写</strong>，并且根据实际情况来定义相等的条件。总之，<strong>== 是用于比较两个对象的引用地址是否相同</strong>，而 <strong>equals 是用于比较两个对象的内容是否相同</strong>。在使用时需要根据实际情况选择合适的比较方式。</p>
<h3 id="15-final-关键字">
  1.5 final 关键字
  <a href="#15-final-%e5%85%b3%e9%94%ae%e5%ad%97" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Java 中，final 是一个关键字，可以用于修饰类、方法和变量，其作用分别如下：</p>
<ol>
<li>
<p>final 修饰类：表示该类<strong>不能被继承</strong>。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 类的定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div></li>
<li>
<p>final 修饰方法：表示该方法<strong>不能被子类重写</strong>。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myMethod</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 方法的定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div></li>
<li>
<p>final 修饰变量：表示该变量只能被赋值一次，并且在赋值后不能被修改。final 变量可以是类变量、实例变量或者局部变量。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MAX_VALUE <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">MyClass</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">myMethod</span><span style="color:#f92672">(</span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> num<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> localVar <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 局部变量localVar被final修饰，不能被修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div></li>
</ol>
<p>​		使用 final 关键字可以使程序更加安全，因为 final 修饰的类、方法和变量在一定程度上可以避免被修改或者重写。此外，final 变量还可以提高程序的效率，因为 Java 编译器可以对 final 变量进行优化，减少内存的开销。</p>
<h3 id="16-object-类的常见方法">
  1.6 Object 类的常见方法
  <a href="#16-object-%e7%b1%bb%e7%9a%84%e5%b8%b8%e8%a7%81%e6%96%b9%e6%b3%95" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Object 类是 Java 中所有类的<strong>基类</strong>，其中定义了一些常用的方法，这些方法包括：</p>
<ol>
<li>equals (Object obj)：用于比较两个对象是否相等。默认情况下，该方法比较的是两个对象的引用地址是否相同，如果需要比较对象的内容是否相同，可以在自定义类中重写 equals 方法。</li>
<li>hashCode()：用于获取对象的哈希码。哈希码可以用于快速查找对象，因此在使用 Java 集合框架时，往往需要重写该方法。</li>
<li>toString()：用于将对象转换为字符串。默认情况下，该方法返回对象的类名和哈希码，如果需要返回对象的具体内容，可以在自定义类中重写该方法。</li>
<li>getClass()：用于获取对象的类类型。</li>
<li>wait()、notify()、notifyAll()：用于实现线程之间的协作。</li>
</ol>
<p>​		需要注意的是，Object 类中还定义了一些其他的方法，但是在使用时需要根据实际情况进行选择。此外，如果自定义类需要在集合框架中使用，通常需要重写 equals 和 hashCode 方法，以便于正确地比较对象和进行哈希查找。</p>
<h3 id="17-java-中的异常处理">
  1.7 Java 中的异常处理
  <a href="#17-java-%e4%b8%ad%e7%9a%84%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Java 中的异常处理机制可以帮助程序员更好地处理错误和异常情况，提高程序的可靠性和稳定性。Java 中的异常可以分为两类：</p>
<ol>
<li>可检查异常（checked exception）：这种异常必须在方法的 throws 声明中列出，或者必须使用 try-catch 块进行捕获和处理，否则编译时会产生错误。例如，IOException 和 SQLException 都是可检查异常。</li>
<li>不可检查异常（unchecked exception）：这种异常不需要在方法的 throws 声明中列出，也不需要使用 try-catch 块进行捕获和处理。通常，不可检查异常是由于程序员的错误导致的，例如，NullPointerException 和 ArrayIndexOutOfBoundsException 都是不可检查异常。</li>
</ol>
<p>Java 中的异常处理机制主要有以下几个关键字和语句：</p>
<ol>
<li>
<p>try-catch 语句：用于捕获并处理异常。try 块中包含可能会引发异常的代码，如果异常被捕获，则会执行 catch 块中的代码。catch 块中可以使用多个 catch 语句来处理不同类型的异常。</p>
</li>
<li>
<p>throw 语句：用于抛出异常。当程序出现异常情况时，可以使用 throw 语句将异常对象抛出。一般情况下，抛出的异常对象应该是 Java 中的 Throwable 类的子类。</p>
</li>
<li>
<p>throws 关键字：用于方法声明，用于声明该方法可能会抛出的异常类型。当方法可能会抛出异常时，需要在方法声明中使用 throws 关键字列出可能会抛出的异常类型。</p>
</li>
<li>
<p>finally 块：用于包含在 try-catch 语句中，无论 try 块中是否出现异常，finally 块中的代码都会被执行。通常，在 finally 块中可以进行资源的释放和清理操作。</p>
</li>
<li>
<p>下面是一个简单的示例代码，演示了 Java 中的异常处理机制：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ExceptionExample</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span><span style="color:#ae81ff">5</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>      arr<span style="color:#f92672">[</span><span style="color:#ae81ff">10</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span><span style="color:#f92672">;</span> <span style="color:#75715e">// 抛出ArrayIndexOutOfBoundsException异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>ArrayIndexOutOfBoundsException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;数组越界异常：&#34;</span> <span style="color:#f92672">+</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">getMessage</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;finally块中的代码被执行。&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div></li>
</ol>
<p>​		在上面的代码中，try 块中的代码会抛出一个 ArrayIndexOutOfBoundsException 异常，该异常被 catch 块捕获并处理，最后 finally 块中的代码也会被执行。</p>
<h3 id="18-接口和抽象类的区别是什么">
  1.8 接口和抽象类的区别是什么
  <a href="#18-%e6%8e%a5%e5%8f%a3%e5%92%8c%e6%8a%bd%e8%b1%a1%e7%b1%bb%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Java 中的接口（interface）和抽象类（abstract class）都是用于实现多态的关键元素，它们都可以被用作定义抽象类型的工具。</p>
<p>下面是接口和抽象类的主要区别：</p>
<ol>
<li>实现方式：抽象类是一个类，可以使用 extends 关键字来继承抽象类，子类必须实现抽象类中所有的抽象方法。而接口使用 implements 关键字来实现接口，实现类必须实现接口中所有的方法。</li>
<li>方法：抽象类可以包含具体方法的实现，也可以包含抽象方法的定义，子类必须实现抽象方法。而接口只能包含抽象方法的定义，实现类必须实现接口中所有的抽象方法。</li>
<li>可访问性：抽象类可以有 public、protected 和 default 等访问修饰符，可以在同一个包或子类中访问。而接口中的方法默认是 public 的，接口本身默认是 public 的，可以在任何地方访问。</li>
<li>可继承性：抽象类可以继承其他类和抽象类，也可以被其他类和抽象类继承。而接口只能继承其他接口，可以被其他类和接口实现。</li>
<li>实例化：抽象类不能被实例化，只能被用作其他类的父类，子类需要实现抽象方法。而接口也不能被实例化，但可以被实现，实现类必须实现接口中的所有抽象方法。</li>
</ol>
<p>​		综上所述，抽象类可以包含具体方法的实现，而接口只能包含抽象方法的定义，抽象类更适合用于定义一些相关类的公共行为和属性，而接口更适合用于定义某些行为的契约和协议。</p>
<h3 id="19-修饰符">
  1.9 修饰符
  <a href="#19-%e4%bf%ae%e9%a5%b0%e7%ac%a6" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Java 中的修饰符可以分为四类：</p>
<ol>
<li>访问修饰符（Access Modifiers）：用于控制程序中类、变量、方法的访问权限，包括 public、protected、private 和默认的访问修饰符。</li>
<li>非访问修饰符（Non-Access Modifiers）：用于控制程序的其他方面，包括 static、final、abstract、synchronized、transient、volatile 等。</li>
<li>注解修饰符（Annotation Modifiers）：用于注解（Annotation）的修饰符，包括 @Retention、@Target、@Inherited 等。</li>
<li>内部类修饰符（Inner Class Modifiers）：用于控制内部类的访问权限，包括 public、protected、private 和默认的访问修饰符。</li>
</ol>
<p>其中，访问修饰符和非访问修饰符是应用最为广泛的两类修饰符。</p>
<h3 id="110-string-stringbuffer-和-stringbuilder-的区别">
  1.10 String 、StringBuffer 和 StringBuilder 的区别
  <a href="#110-string-stringbuffer-%e5%92%8c-stringbuilder-%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>String、StringBuffer 和 StringBuilder 都是 Java 中处理字符串的类，它们的主要区别在于可变性、线程安全性和性能。</p>
<ol>
<li>String：String 是不可变的字符串类，一旦创建就无法被修改。每当对字符串进行修改时，都会创建一个新的 String 对象。因此，如果需要频繁进行字符串修改操作，String 会产生大量的无用对象，影响性能。</li>
<li>StringBuffer：StringBuffer 是可变的字符串类，可以通过 append()、insert() 等方法进行字符串的修改操作。它是线程安全的，多个线程可以同时访问同一个 StringBuffer 对象而不会产生线程安全问题。但是，由于线程安全的实现需要加锁，因此在性能上会受到一定的影响。</li>
<li>StringBuilder：StringBuilder 也是可变的字符串类，与 StringBuffer 类似，可以通过 append()、insert() 等方法进行字符串的修改操作。与 StringBuffer 不同的是，StringBuilder 是非线程安全的，因此在单线程场景下，StringBuilder 的性能优于 StringBuffer。</li>
</ol>
<p>​		因此，如果需要进行频繁的字符串修改操作，并且不需要考虑线程安全问题，建议使用 StringBuilder；如果需要进行频繁的字符串修改操作，并且需要考虑线程安全问题，建议使用 StringBuffer；如果字符串不需要进行修改操作，建议使用 String。</p>
<h3 id="111-io-流">
  1.11 IO 流
  <a href="#111-io-%e6%b5%81" class="h-anchor" aria-hidden="true">#</a>
</h3>
<!-- raw HTML omitted -->
<p>​		IO流（Input/Output Stream）是 Java 中用于处理输入输出的机制。在 Java 中，输入输出操作通过流来完成，这些流按照流向分为输入流和输出流。输入流用于读取数据，输出流用于写入数据。Java 的 IO 流体系是建立在 InputStream 和 OutputStream 基础之上的，包含了多种类，可分为字节流和字符流两大类。</p>
<p>​		字节流以字节为单位进行读写操作，是所有输入/输出操作的基本单元，用于处理二进制数据和文本数据；而字符流以字符为单位进行读写操作，是在字节流基础上对字符进行了封装，用于处理文本数据。Java 提供了四个基本的抽象类来实现字节流和字符流的操作：InputStream、OutputStream、Reader 和 Writer。</p>
<p>​		在 Java 中，常用的字节流有 FileInputStream、FileOutputStream、ByteArrayInputStream、ByteArrayOutputStream、DataInputStream、DataOutputStream 等；常用的字符流有 FileReader、FileWriter、BufferedReader、BufferedWriter、InputStreamReader、OutputStreamWriter 等。除此之外，还有一些高级流，如 PrintStream、PrintWriter、ObjectInputStream、ObjectOutputStream 等，它们可以将对象或其他格式的数据进行读写操作。</p>
<h3 id="112-字节流">
  1.12 字节流
  <a href="#112-%e5%ad%97%e8%8a%82%e6%b5%81" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Java 中，字节流是处理字节数据的输入和输出流。字节流以字节为单位读取和写入数据，适用于处理二进制数据和文本数据。字节流的输入流和输出流是 InputStream 和 OutputStream。</p>
<p>常见的字节流包括：</p>
<ol>
<li>FileInputStream 和 FileOutputStream：用于读写文件数据。</li>
<li>ByteArrayInputStream 和 ByteArrayOutputStream：用于读写字节数组数据。</li>
<li>PipedInputStream 和 PipedOutputStream：用于管道通信。</li>
<li>DataInputStream 和 DataOutputStream：用于读写基本数据类型和字符串。</li>
</ol>
<p>​		字节流的工作原理是从一个输入流中读取数据并将其存储到内存中或从内存中将数据写入一个输出流。可以使用不同的缓冲区大小和缓冲区类型来控制字节流的性能和效率。在使用字节流时，应注意正确关闭流以避免资源泄漏。</p>
<h3 id="113-字符流">
  1.13 字符流
  <a href="#113-%e5%ad%97%e7%ac%a6%e6%b5%81" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Java IO 中，字符流主要用于处理字符数据，以字符流的方式读写文本文件或网络数据。相比于字节流，字符流可以更好地处理 Unicode 编码的字符数据，同时也能够方便地进行编码转换。</p>
<p>​		Java 中的字符流主要有两种：Reader 和 Writer。Reader 用于从字符输入流中读取字符数据，Writer 则用于将字符数据写入到字符输出流中。常用的字符流实现类包括 FileReader、FileWriter、BufferedReader 和 BufferedWriter 等。</p>
<p>​		与字节流类似，字符流也存在缓冲区，通过将字符数据先缓存在内存中，再一次性写入到输出流中，可以有效地提高写入效率。因此，使用缓冲字符流（如 BufferedReader 和 BufferedWriter）一般比使用原始字符流效率更高。</p>
<h3 id="114-字节缓冲流">
  1.14 字节缓冲流
  <a href="#114-%e5%ad%97%e8%8a%82%e7%bc%93%e5%86%b2%e6%b5%81" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		字节缓冲流是一种高效的输入输出流，它是对字节流的一种包装，可以提高字节流的读写效率。常用的字节缓冲流有 BufferedInputStream 和 BufferedOutputStream。</p>
<p>​		BufferedInputStream 和 BufferedOutputStream 内部维护了一个缓冲区，每次读写数据时都是先将数据读取到缓冲区或从缓冲区写出数据，这样可以减少实际的物理读写次数，提高 IO 的效率。</p>
<p>BufferedInputStream 和 BufferedOutputStream 的构造方法都需要传入一个字节流对象，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>BufferedInputStream bis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedInputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;test.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>BufferedOutputStream bos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedOutputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;test.txt&#34;</span><span style="color:#f92672">));</span>
</span></span></code></pre></div><p>​		使用字节缓冲流读写数据时，一般需要先定义一个缓冲区数组，用于存储从流中读取的数据或要写入流的数据。在读取数据时，使用 read() 方法从缓冲区中读取数据，如果缓冲区中的数据已经读取完了，就会再次从输入流中读取一定量的数据到缓冲区中。在写入数据时，使用 write() 方法将数据写入缓冲区，如果缓冲区已满，就会将缓冲区中的数据写入输出流中，并清空缓冲区。</p>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>BufferedInputStream bis <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedInputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;test.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>BufferedOutputStream bos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedOutputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;output.txt&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span><span style="color:#ae81ff">1024</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> len<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>len <span style="color:#f92672">=</span> bis<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    bos<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">,</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> len<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>bis<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>bos<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>​		在上面的代码中，首先创建了一个 BufferedInputStream 对象和一个 BufferedOutputStream 对象，并定义了一个缓冲区数组 buffer，大小为 1024 字节。然后使用 read() 方法从 BufferedInputStream 对象中读取数据，使用 write() 方法将数据写入 BufferedOutputStream 对象中，读取和写入数据的过程都是通过缓冲区实现的。最后需要关闭输入输出流对象。</p>
<h3 id="115-字符缓冲流">
  1.15 字符缓冲流
  <a href="#115-%e5%ad%97%e7%ac%a6%e7%bc%93%e5%86%b2%e6%b5%81" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		字符缓冲流是 Java I/O 中的一种流，它是对字符流的一种封装，用于提高读写效率。和字节缓冲流类似，字符缓冲流也是通过缓冲区来减少读写次数，从而提高读写效率。在读取数据时，字符缓冲流会一次读取一定数量的字符，放入到内部缓冲区中，当缓冲区中的数据被读取完毕后，再从输入流中读取数据。在写入数据时，字符缓冲流也会将写入的数据先放入到缓冲区中，当缓冲区中的数据到达一定量之后再写入到输出流中。</p>
<p>​		与字符流相比，字符缓冲流的读写效率更高。由于字符流每次读写的是一个字符，因此需要频繁地进行 I/O 操作，而字符缓冲流可以一次性读写多个字符，减少了 I/O 操作的次数，提高了效率。另外，由于字符缓冲流有内部缓冲区，因此可以在缓冲区未满的情况下写入数据，这样可以减少阻塞等待的时间，提高了效率。</p>
<p>​		常见的字符缓冲流包括 BufferedReader 和 BufferedWriter，它们分别用于读取和写入字符数据。在使用字符缓冲流时，需要注意及时关闭流对象，以便释放资源和避免内存泄漏等问题。</p>
<h3 id="116-打印流">
  1.16 打印流
  <a href="#116-%e6%89%93%e5%8d%b0%e6%b5%81" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		打印流是 Java I/O 包提供的一种输出流，它可以方便地打印各种数据类型的值，并且可以输出到文件或者其他输出流中。</p>
<p>​		PrintStream 和 PrintWriter 是 Java 中的两个常用的打印流类。PrintStream 用于输出字节流，而 PrintWriter 用于输出字符流。两者的主要区别在于 PrintWriter 有更丰富的方法支持输出各种数据类型，并且它可以指定字符编码进行输出。</p>
<p>​		使用打印流，可以方便地将数据写入到文件或其他输出流中，而不用手动进行字符串拼接或格式化处理。同时，打印流还可以使用自动刷新功能，这样在输出的数据达到一定大小或者一定时间间隔之后，就会自动刷新缓冲区，将数据输出到目标流中，避免了手动调用 flush() 方法的繁琐操作。</p>
<h3 id="117-随机访问流">
  1.17 随机访问流
  <a href="#117-%e9%9a%8f%e6%9c%ba%e8%ae%bf%e9%97%ae%e6%b5%81" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		随机访问流（RandomAccessFile）是 Java 中用于读写文件的类之一，它既可以读取文件内容，也可以向文件写入数据，同时还支持随机访问文件内容的能力。</p>
<p>​		相较于其他的字节流和字符流，随机访问流具有随机读写的能力。即可以通过文件指针直接定位文件中的任意位置进行读写操作。</p>
<p>​		随机访问流支持两种模式的访问方式：只读（read-only）和读写（read-write）。在读写模式下，不仅可以读取文件中的数据，也可以向文件中写入数据，从而实现对文件的修改操作。同时，在读写模式下，也可以设置文件指针的位置，实现对文件中任意位置的读写操作。</p>
<p>​		需要注意的是，随机访问流是基于文件的，因此它只能用于操作文件，而不能用于操作其他类型的数据流。此外，它也不支持缓存，所以无法通过缓存来提高文件读写的效率。</p>
<h3 id="118-java-异常架构">
  1.18 Java 异常架构
  <a href="#118-java-%e5%bc%82%e5%b8%b8%e6%9e%b6%e6%9e%84" class="h-anchor" aria-hidden="true">#</a>
</h3>
<!-- raw HTML omitted -->
<p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。</p>
<!-- raw HTML omitted -->
<p>下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。</p>
<!-- raw HTML omitted -->
<p>下面的列表是 Throwable 类的主要方法:</p>
<!-- raw HTML omitted -->
<h3 id="119-error-和-exception-区别是什么">
  1.19 Error 和 Exception 区别是什么
  <a href="#119-error-%e5%92%8c-exception-%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Java 中，Error 和 Exception 都继承自 Throwable 类。它们之间的区别在于：</p>
<ol>
<li>Exception 表示可以被捕获并进行处理的异常，通常是由程序员编写的代码引起的，如数组越界、空指针引用等。</li>
<li>Error 表示不能被程序员处理的异常，通常是由系统或者硬件引起的，如虚拟机错误、内存溢出等。</li>
</ol>
<p>​		因此，程序通常只需要捕获并处理 Exception，而不需要处理 Error。如果程序中出现了 Error，通常表示程序已经无法继续执行下去了，需要进行紧急处理。</p>
<h3 id="120-运行时异常和一般异常受检异常区别是什么">
  1.20 运行时异常和一般异常(受检异常)区别是什么
  <a href="#120-%e8%bf%90%e8%a1%8c%e6%97%b6%e5%bc%82%e5%b8%b8%e5%92%8c%e4%b8%80%e8%88%ac%e5%bc%82%e5%b8%b8%e5%8f%97%e6%a3%80%e5%bc%82%e5%b8%b8%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Java 中的异常可以分为运行时异常和受检异常。</p>
<p>​		运行时异常是指在代码运行时才会出现的异常，通常是由程序员的错误引起的，如空指针异常（NullPointerException）、数组下标越界异常（ArrayIndexOutOfBoundsException）等。运行时异常不需要在方法声明中抛出，如果不处理它们，程序也不会编译错误。运行时异常都是 RuntimeException 的子类。</p>
<p>​		受检异常是指在编译时就需要捕获或声明抛出的异常，也就是需要在方法声明中使用 throws 抛出或使用 try-catch-finally 来捕获的异常，例如文件不存在异常（FileNotFoundException）、网络连接异常（IOException）等。受检异常是 Exception 类的子类，但不包括 RuntimeException 及其子类。</p>
<p>区别在于：</p>
<ol>
<li>运行时异常不需要显式地捕获或者声明抛出，而受检异常则需要显式地捕获或者声明抛出。</li>
<li>运行时异常通常由程序员的错误引起，而受检异常通常由外部环境因素（如用户输入、网络连接等）引起。</li>
<li>运行时异常在代码编写过程中通常不需要特别处理，而受检异常则需要进行处理。</li>
</ol>
<h3 id="121-jvm-是如何处理异常的">
  1.21 JVM 是如何处理异常的
  <a href="#121-jvm-%e6%98%af%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e5%bc%82%e5%b8%b8%e7%9a%84" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>JVM（Java 虚拟机）中处理异常的流程大致如下：</p>
<ol>
<li>当 Java 代码中抛出异常时，JVM 会创建一个异常对象。</li>
<li>JVM 查找当前方法的异常处理器（Exception Handler），如果该方法没有异常处理器，则向调用该方法的方法查找，依次往上，直到找到为止。</li>
<li>如果找到了匹配的异常处理器，则该处理器处理异常，否则将异常传递给调用该方法的方法，依次往上，直到找到匹配的异常处理器或抛出了未被处理的异常（Uncaught Exception）为止。</li>
<li>如果一直没有找到匹配的异常处理器，则 JVM 会将异常信息输出到控制台，并退出程序。</li>
</ol>
<p>​		处理异常的流程中，异常处理器分为两种：try-catch 块和异常处理器方法（Exception Handler Method）。在 try-catch 块中，我们可以捕获并处理指定类型的异常；在异常处理器方法中，我们可以处理未被捕获的异常。</p>
<p>​		需要注意的是，Java 中有一种特殊的异常类型，即运行时异常（RuntimeException），这种异常不需要在方法签名中声明，也不需要在方法中显式捕获或处理，因此如果运行时异常没有被捕获或处理，程序会直接退出并抛出异常信息。</p>
<h3 id="122-throw-和-throws-的区别是什么">
  1.22 throw 和 throws 的区别是什么
  <a href="#122-throw-%e5%92%8c-throws-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p><code>throw</code> 和 <code>throws</code> 是 Java 中用于处理异常的两个关键字，它们有以下区别：</p>
<ol>
<li><code>throw</code> 关键字用于在代码中抛出一个异常对象，可以在方法中使用，用于手动抛出异常。</li>
<li><code>throws</code> 关键字用于声明一个方法可能抛出的异常类型，可以在方法声明处使用，用于告诉调用该方法的代码可能会抛出哪些异常。使用 <code>throws</code> 声明异常类型，可以让代码更加清晰明了，让异常处理更加规范化。</li>
</ol>
<p>​		总的来说，<code>throw</code> 是用于抛出异常，<code>throws</code> 是用于声明异常类型。<code>throw</code> 用于方法体中，<code>throws</code> 用于方法声明中。</p>
<h3 id="123-finalfinallyfinalize-有什么区别">
  1.23 final、finally、finalize 有什么区别
  <a href="#123-finalfinallyfinalize-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p><code>final</code>、<code>finally</code>、<code>finalize</code> 是 Java 中的三个关键字，它们的作用完全不同：</p>
<ul>
<li><code>final</code>：用于修饰类、方法、变量，表示不可改变的含义，一旦被赋值便无法被改变；</li>
<li><code>finally</code>：与 try-catch 语句结合使用，表示无论是否抛出异常，都会执行 finally 块中的代码；</li>
<li><code>finalize</code>：是一个 Object 类中的方法，用于垃圾回收之前执行对象清理操作。</li>
</ul>
<p>具体来说：</p>
<ul>
<li><code>final</code>：用于修饰类，表示该类不可被继承；用于修饰方法，表示该方法不能被子类覆盖；用于修饰变量，表示该变量的值一旦被赋值便无法被改变，也可以被用于定义常量；</li>
<li><code>finally</code>：无论 try-catch 语句中是否抛出异常，finally 中的代码都会被执行。常用于执行一些必须要做的清理操作，例如关闭文件或数据库连接；</li>
<li><code>finalize</code>：是 Object 类中的一个方法，子类可以重写这个方法，在垃圾回收之前执行清理操作，例如释放对象占用的资源。</li>
</ul>
<p>​		需要注意的是，尽管 <code>finalize</code> 方法可以在垃圾回收之前执行清理操作，但它的使用已经不再被推荐，因为它具有不确定性，并且容易导致性能问题。</p>
<h3 id="124-noclassdeffounderror-和-classnotfoundexception-区别">
  1.24 NoClassDefFoundError 和 ClassNotFoundException 区别
  <a href="#124-noclassdeffounderror-%e5%92%8c-classnotfoundexception-%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		<code>NoClassDefFoundError</code> 和 <code>ClassNotFoundException</code> 都是与类的加载有关的异常，但是它们之间存在一些区别。</p>
<p>​		当 JVM 尝试在运行时动态加载类时，如果找不到相应的类，就会抛出 <code>ClassNotFoundException</code> 异常。通常发生在使用 <code>Class.forName()</code> 或者 <code>ClassLoader.loadClass()</code> 方法时，这些方法在找不到类时就会抛出 <code>ClassNotFoundException</code>。</p>
<p>​		而 <code>NoClassDefFoundError</code> 则是在类的加载过程中出现了问题，当 JVM 尝试加载某个类时，在类路径中找到了相应的 <code>.class</code> 文件，但是在加载过程中出现了错误，导致无法完成加载，从而抛出 <code>NoClassDefFoundError</code> 异常。</p>
<p>​		在实际开发中，<code>ClassNotFoundException</code> 更常见，通常是由于类路径设置不正确或者依赖库缺失导致的。而 <code>NoClassDefFoundError</code> 通常是由于类文件被破坏或者类文件之间的依赖关系出现了问题导致的。</p>
<h3 id="125-try-catch-finally-中哪个部分可以省略">
  1.25 try-catch-finally 中哪个部分可以省略
  <a href="#125-try-catch-finally-%e4%b8%ad%e5%93%aa%e4%b8%aa%e9%83%a8%e5%88%86%e5%8f%af%e4%bb%a5%e7%9c%81%e7%95%a5" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Java 中，try-catch-finally 语句用于捕获和处理异常。其中，try 是必需的，catch 和 finally 是可选的，但是不能同时省略，否则会出现编译错误。</p>
<p>​		如果只想捕获异常但不处理，可以省略 catch 块，只保留 try 和 finally。如果只是想执行一些必须要做的清理工作，可以省略 catch 块，只保留 try 和 finally。</p>
<p>​		需要注意的是，如果在 try 块中调用了 return 语句或者抛出了异常，那么 finally 块仍然会被执行。因此，finally 块通常用于释放资源，例如关闭数据库连接或者关闭文件等。</p>
<h3 id="126-try-catch-finally-中如果-catch-中-return-了finally-还会执行吗">
  1.26 try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗
  <a href="#126-try-catch-finally-%e4%b8%ad%e5%a6%82%e6%9e%9c-catch-%e4%b8%ad-return-%e4%ba%86finally-%e8%bf%98%e4%bc%9a%e6%89%a7%e8%a1%8c%e5%90%97" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		如果 catch 中 return 了，finally 块依然会执行。无论 try 或者 catch 中有没有 return 语句，finally 中的代码都会被执行。不过，finally 块中的 return 语句会覆盖 try 或者 catch 中的 return 语句，也就是说，如果 finally 块中有 return 语句，那么方法就会以 finally 块中的 return 语句为准，而不是以 try 或者 catch 中的 return 语句为准。</p>
<h3 id="127-java-常见异常有哪些">
  1.27 Java 常见异常有哪些
  <a href="#127-java-%e5%b8%b8%e8%a7%81%e5%bc%82%e5%b8%b8%e6%9c%89%e5%93%aa%e4%ba%9b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Java 常见异常可以分为两大类：受检异常（Checked Exception）和非受检异常（Unchecked Exception）。</p>
<p>受检异常：</p>
<ul>
<li>IOException：输入输出异常，如读写文件时出错。</li>
<li>SQLException：数据库访问异常。</li>
<li>ClassNotFoundException：找不到类异常。</li>
<li>InterruptedException：线程中断异常。</li>
<li>IllegalAccessException：非法访问异常。</li>
<li>NoSuchMethodException：找不到方法异常。</li>
<li>NoSuchFieldException：找不到属性异常。</li>
</ul>
<p>非受检异常：</p>
<ul>
<li>RuntimeException：运行时异常，不需要在代码中进行 try-catch 处理，也不需要 throws 声明抛出。</li>
<li>NullPointerException：空指针异常。</li>
<li>ClassCastException：类型转换异常。</li>
<li>IllegalArgumentException：非法参数异常。</li>
<li>IndexOutOfBoundsException：下标越界异常。</li>
<li>ArrayStoreException：数组存储异常。</li>
<li>ArithmeticException：算术异常。</li>
</ul>
<p>​		另外还有一个特殊的异常 Error，表示系统级别的错误，比如 OutOfMemoryError（内存溢出）等。通常情况下我们不会手动抛出 Error，而是让程序自动处理。</p>
<h3 id="128-什么是字节码采用字节码的好处是什么">
  1.28 什么是字节码，采用字节码的好处是什么
  <a href="#128-%e4%bb%80%e4%b9%88%e6%98%af%e5%ad%97%e8%8a%82%e7%a0%81%e9%87%87%e7%94%a8%e5%ad%97%e8%8a%82%e7%a0%81%e7%9a%84%e5%a5%bd%e5%a4%84%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		字节码是指一种中间代码，它是由 Java 编译器将源代码编译而成的，可以被 Java 虚拟机执行的二进制代码。采用字节码的好处主要有以下几点：</p>
<ol>
<li>跨平台性：由于字节码是一种中间代码，它可以被编译成不同平台的本地代码，从而实现跨平台运行的能力。</li>
<li>安全性：Java 虚拟机在加载字节码时会进行严格的校验，避免了一些潜在的安全漏洞，从而提高了程序的安全性。</li>
<li>高效性：由于字节码是一种高度优化过的代码，其执行效率比源代码要高，同时字节码也可以被多次重复使用，从而提高了程序的执行效率。</li>
<li>可移植性：字节码文件可以被打包成 JAR 包，在不同的项目之间进行共享和重用，从而提高了程序的可移植性。</li>
</ol>
<p>​		在 Java 虚拟机中，字节码是一种非常重要的概念，它可以被加载到虚拟机中并被执行，实现了 Java 语言的跨平台能力。</p>
<h3 id="129-介绍一下-java-的封装继承和多态">
  1.29 介绍一下 Java 的封装、继承和多态
  <a href="#129-%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-java-%e7%9a%84%e5%b0%81%e8%a3%85%e7%bb%a7%e6%89%bf%e5%92%8c%e5%a4%9a%e6%80%81" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		封装、继承和多态是面向对象编程的三个基本特性。</p>
<p>​		封装：将数据和行为封装成一个类，对外暴露一些接口，通过接口来访问数据和行为。封装可以有效保护数据，防止程序误操作，提高代码的安全性和可靠性。</p>
<p>​		继承：子类继承父类的属性和方法，可以减少重复代码，提高代码复用性。通过继承可以构建类的层次结构，实现多态性。</p>
<p>​		多态：同一个类型的对象在不同的情况下表现出不同的行为，即一个对象可以被看做是多种类型的实例。多态可以通过继承和接口实现。通过多态可以写出更加通用的代码，提高代码的灵活性和可维护性。</p>
<p>​		在 Java 中，封装可以通过访问修饰符（public、private、protected）来实现；继承可以通过 extends 关键字来实现；多态可以通过继承和重写、接口和实现来实现。</p>
<h3 id="130-java-的访问修饰符有哪些分别有哪些作用">
  1.30 Java 的访问修饰符有哪些，分别有哪些作用
  <a href="#130-java-%e7%9a%84%e8%ae%bf%e9%97%ae%e4%bf%ae%e9%a5%b0%e7%ac%a6%e6%9c%89%e5%93%aa%e4%ba%9b%e5%88%86%e5%88%ab%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bd%9c%e7%94%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Java 中的访问修饰符指的是用来控制类、接口、变量、方法等成员的访问权限的关键字。Java 中的访问修饰符有以下四个：</p>
<ol>
<li>public：公共访问修饰符，用来修饰类、接口、变量、方法等成员。被 public 修饰的成员可以被任何类或方法访问，没有访问限制。</li>
<li>protected：受保护的访问修饰符，用来修饰类的成员变量和成员方法。被 protected 修饰的成员可以被本类、子类和同一个包中的其他类访问，但不能被其他包中的类访问。</li>
<li>default：默认的访问修饰符，也称为包访问修饰符，没有关键字，只需要在声明时不加任何修饰符即可。被 default 修饰的成员可以被同一个包中的其他类访问，但不能被其他包中的类访问。</li>
<li>private：私有的访问修饰符，用来修饰类的成员变量和成员方法。被 private 修饰的成员只能被本类的其他成员访问，不能被其他类访问。</li>
</ol>
<p>​		访问修饰符的作用是控制类、接口、变量、方法等成员的访问权限，以实现信息的隐藏和保护。使用访问修饰符可以使程序更加健壮和安全，减少了程序出错的可能性。</p>
<h3 id="131-java-语言关键字有哪些">
  1.31 Java 语言关键字有哪些
  <a href="#131-java-%e8%af%ad%e8%a8%80%e5%85%b3%e9%94%ae%e5%ad%97%e6%9c%89%e5%93%aa%e4%ba%9b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<!-- raw HTML omitted -->
<p>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</p>
<p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p>
<ul>
<li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li>
<li>在类，方法和变量修饰符中，从 JDK 8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li>
<li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li>
</ul>
<p>注意 ：虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。</p>
<h3 id="132-continuebreak-和-return-的区别是什么">
  1.32 continue、break 和 return 的区别是什么
  <a href="#132-continuebreak-%e5%92%8c-return-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p><code>continue</code>、<code>break</code> 和 <code>return</code> 是三个控制语句，它们的作用如下：</p>
<ul>
<li><code>continue</code>：跳出本次循环的当前迭代，直接进入下一次循环的迭代。</li>
<li><code>break</code>：跳出循环或者 switch 语句，结束当前语句块的执行。</li>
<li><code>return</code>：返回调用者，并结束当前方法的执行。</li>
</ul>
<p>它们之间的主要区别如下：</p>
<ul>
<li><code>continue</code> 只是跳出本次循环的当前迭代，然后执行下一次循环；<code>break</code> 则是直接跳出循环或者 switch 语句，不再执行后续语句。</li>
<li><code>return</code> 会直接返回调用者，并结束当前方法的执行，不再执行后续语句。</li>
</ul>
<p>此外，它们还有以下特点：</p>
<ul>
<li><code>continue</code> 只能用于循环语句中，不能用于 switch 语句或者其他类型的语句中。</li>
<li><code>break</code> 可以用于循环语句、switch 语句或者其他类型的语句中。</li>
<li><code>return</code> 用于方法中，用于返回值给调用者，可以带有返回值，也可以没有返回值。</li>
</ul>
<h3 id="133-标识符和关键字的区别是什么">
  1.33 标识符和关键字的区别是什么
  <a href="#133-%e6%a0%87%e8%af%86%e7%ac%a6%e5%92%8c%e5%85%b3%e9%94%ae%e5%ad%97%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Java 编程语言中，标识符和关键字都是指特定类型的词。它们的区别在于其用途和含义。</p>
<ol>
<li>标识符：</li>
</ol>
<p>​		标识符是 Java 中用来标识各种实体的名称。标识符可以是变量名、方法名、类名、接口名等，以字母、下划线或美元符号开头，后面可以跟字母、数字、下划线或美元符号。标识符的命名要符合一定的规范和约定，如不能使用 Java 的关键字和保留字等。</p>
<ol start="2">
<li>关键字：</li>
</ol>
<p>​		关键字是 Java 编程语言中具有特殊含义的保留字。关键字在 Java 中有特定的语法和用途，不能用作标识符。例如，Java 中的“public”、“class”、“static”等都是关键字。</p>
<p>​		因此，标识符和关键字的区别在于<strong>标识符是程序员自定义的名称</strong>，用于标识各种实体；而<strong>关键字是具有特殊含义的保留字</strong>，用于实现Java 语言的语法规则。</p>
<h3 id="134-成员变量与局部变量的区别">
  1.34 成员变量与局部变量的区别
  <a href="#134-%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f%e4%b8%8e%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>成员变量和局部变量是 Java 中两种不同类型的变量，它们的区别如下：</p>
<ol>
<li>定义位置不同：成员变量定义在类中，方法外，而局部变量定义在方法中、代码块中或者方法的参数中。</li>
<li>生命周期不同：成员变量的生命周期和对象相同，当对象被销毁时，成员变量也被销毁。而局部变量的生命周期则和代码块、方法或者语句的执行情况相关，当执行到变量所在的语句块结束后，该变量就被销毁了。</li>
<li>访问权限不同：成员变量可以使用 public、protected、private 和默认访问权限进行修饰，而局部变量没有访问权限这个概念。</li>
<li>默认值不同：成员变量有默认值，例如 int 类型默认值为 0，boolean 类型默认值为 false。而局部变量在使用前必须被初始化，否则会报错。</li>
<li>作用域不同：成员变量可以被类中的所有方法和代码块访问，而局部变量只能在其所在的代码块中访问。</li>
</ol>
<p>​		总的来说，成员变量用于存储对象的状态，而局部变量则用于方法或语句块中的临时数据存储。</p>
<h3 id="135-静态变量有什么作用介绍下-static-关键字的作用">
  1.35 静态变量有什么作用，介绍下 static 关键字的作用
  <a href="#135-%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8%e4%bb%8b%e7%bb%8d%e4%b8%8b-static-%e5%85%b3%e9%94%ae%e5%ad%97%e7%9a%84%e4%bd%9c%e7%94%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		静态变量是指被声明为静态的变量，也称为类变量。与实例变量不同，静态变量属于类，而不是类的每个实例。因此，它们在内存中只存在一份拷贝，并且可以被类的所有实例共享。静态变量可以通过类名直接访问，也可以通过实例变量访问。在 Java 中，使用 <code>static</code> 关键字来定义静态变量。</p>
<p><code>static</code> 关键字还可以用于静态方法、静态代码块和内部类中，作用如下：</p>
<ul>
<li>静态方法：静态方法属于类而不是类的实例，可以直接通过类名调用，不需要创建类的实例。在静态方法中只能访问类的静态变量和静态方法，不能访问实例变量和实例方法。</li>
<li>静态代码块：静态代码块是在类加载时执行的，只会执行一次。一般用于初始化类的静态变量或执行一些静态操作。</li>
<li>静态内部类：静态内部类属于外部类而不是外部类的实例，可以直接通过外部类名访问，不需要创建外部类的实例。静态内部类只能访问外部类的静态变量和静态方法，不能访问外部类的实例变量和实例方法。</li>
</ul>
<p>​		总的来说，<code>static</code> 关键字的作用是将变量或方法与类绑定，而不是与类的实例绑定，从而实现全局访问或共享。</p>
<h3 id="136-说出-java-的数据类型并说明数据范围">
  1.36 说出 Java 的数据类型，并说明数据范围
  <a href="#136-%e8%af%b4%e5%87%ba-java-%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%b9%b6%e8%af%b4%e6%98%8e%e6%95%b0%e6%8d%ae%e8%8c%83%e5%9b%b4" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Java 的数据类型可以分为两大类：基本数据类型和引用数据类型。</p>
<ol>
<li>基本数据类型</li>
</ol>
<p>Java 的基本数据类型包括八种：boolean、byte、short、int、long、float、double 和 char。</p>
<ul>
<li>boolean：逻辑类型，只能取值 true 或 false。</li>
<li>byte：字节类型，8 位，有符号，范围为 -128 到 127。</li>
<li>short：短整型，16 位，有符号，范围为 -32768 到 32767。</li>
<li>int：整型，32 位，有符号，范围为 -2147483648 到 2147483647。</li>
<li>long：长整型，64 位，有符号，范围为 -9223372036854775808 到 9223372036854775807。</li>
<li>float：单精度浮点型，32 位，范围为 3.40282347E+38F 到 1.40239846E-45F。</li>
<li>double：双精度浮点型，64 位，范围为 1.79769313486231570E+308 到 4.94065645841246544E-324。</li>
<li>char：字符型，16 位，无符号，范围为 0 到 65535。</li>
</ul>
<ol start="2">
<li>引用数据类型</li>
</ol>
<p>引用数据类型包括类、接口、数组等。</p>
<ul>
<li>类：表示对象的类，类是一个模板，可以用来创建对象。Java 中的所有类都继承自 Object 类。</li>
<li>接口：一种特殊的类，只有方法定义，没有实现，接口可以被类实现。</li>
<li>数组：表示一组相同类型的数据的集合，可以使用数组来存储同类型的数据。数组的长度不可变。</li>
</ul>
<p>在 Java 中，不同的数据类型占用不同的字节数，数据类型的范围也不同，使用时需要注意数据类型的选择。</p>
<h3 id="137-静态方法为什么不能调用非静态成员">
  1.37 静态方法为什么不能调用非静态成员
  <a href="#137-%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e8%b0%83%e7%94%a8%e9%9d%9e%e9%9d%99%e6%80%81%e6%88%90%e5%91%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		静态方法不能调用非静态成员的原因是：静态方法不依赖于类的实例，而非静态成员必须依赖于类的实例才能被调用。</p>
<p>​		静态方法是属于类的，不依赖于类的实例，所以在静态方法中不能使用 this 关键字，也不能直接访问非静态的成员变量和非静态的成员方法，因为这些都需要先创建类的实例才能访问。而静态方法只能访问其他静态成员，因为静态成员也不依赖于类的实例，可以直接通过类名访问。</p>
<h3 id="138-基本类型和包装类型的区别">
  1.38 基本类型和包装类型的区别
  <a href="#138-%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%8c%85%e8%a3%85%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Java中的基本类型和包装类型的区别如下：</p>
<ol>
<li>基本类型存储的是实际的值，而包装类型存储的是对象的引用。</li>
<li>基本类型具有较高的执行效率，而包装类型则需要更多的内存和运行时间。</li>
<li>基本类型只有默认值（如 int 类型的默认值是 0），而包装类型则有一个默认值为 null。</li>
<li>基本类型可以直接参与算数运算，而包装类型需要通过方法调用才能参与运算。</li>
<li>基本类型不能被当做参数传递给泛型，而包装类型可以。</li>
</ol>
<p>Java的包装类型有以下几种：</p>
<ol>
<li>Boolean：布尔型。</li>
<li>Byte：字节型。</li>
<li>Short：短整型。</li>
<li>Integer：整型。</li>
<li>Long：长整型。</li>
<li>Float：单精度浮点型。</li>
<li>Double：双精度浮点型。</li>
<li>Character：字符型。</li>
</ol>
<p>包装类型可以通过构造函数或者静态方法来实例化，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 使用构造函数实例化包装类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Integer i1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span><span style="color:#ae81ff">10</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 使用静态方法实例化包装类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Integer i2 <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span><span style="color:#ae81ff">10</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><p>基本类型和包装类型之间可以进行自动装箱和拆箱，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 自动装箱
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Integer i <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 自动拆箱
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
</span></span></code></pre></div><h3 id="139-为什么浮点数运算的时候会有精度丢失的风险如何解决浮点数运算的精度丢失问题">
  1.39 为什么浮点数运算的时候会有精度丢失的风险，如何解决浮点数运算的精度丢失问题
  <a href="#139-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%b5%ae%e7%82%b9%e6%95%b0%e8%bf%90%e7%ae%97%e7%9a%84%e6%97%b6%e5%80%99%e4%bc%9a%e6%9c%89%e7%b2%be%e5%ba%a6%e4%b8%a2%e5%a4%b1%e7%9a%84%e9%a3%8e%e9%99%a9%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e6%b5%ae%e7%82%b9%e6%95%b0%e8%bf%90%e7%ae%97%e7%9a%84%e7%b2%be%e5%ba%a6%e4%b8%a2%e5%a4%b1%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		浮点数运算的精度丢失问题是由于计算机采用二进制来表示浮点数，而二进制无法精确表示某些十进制小数。因此，在进行浮点数运算时，可能会出现精度丢失的情况。例如，0.1 在二进制中是一个无限循环的小数，因此无法被精确表示。当进行一系列涉及 0.1 的浮点数运算时，就可能会出现精度丢失的情况。</p>
<p>要解决浮点数运算的精度丢失问题，可以采用以下两种方式：</p>
<ol>
<li>
<p>使用 BigDecimal 类：BigDecimal 类可以精确表示任意精度的十进制数，因此在进行需要高精度计算的场景中可以使用 BigDecimal 类。BigDecimal 类的运算比较复杂，需要使用相应的方法来进行加、减、乘、除等操作。</p>
</li>
<li>
<p>使用 IEEE 754 标准的舍入规则：IEEE 754 是一种标准，规定了浮点数的二进制表示、精度和舍入规则等方面的内容。在进行浮点数运算时，可以采用 IEEE 754 标准的舍入规则来减少精度丢失的风险。常用的舍入规则有四舍五入、向零取整和向最近的偶数取整等。需要注意的是，舍入规则并不能完全解决精度丢失的问题，只是能够减少出现精度丢失的概率。</p>
</li>
</ol>
<h3 id="140-面向对象和面向过程的区别">
  1.40 面向对象和面向过程的区别
  <a href="#140-%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e5%92%8c%e9%9d%a2%e5%90%91%e8%bf%87%e7%a8%8b%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		面向对象和面向过程都是软件开发中的两种不同的编程思想。</p>
<p>​		面向过程编程是指以过程为中心，以数据为辅助的编程方式，也被称为命令式编程。面向过程编程强调的是算法和操作，注重对数据的处理，以及对算法的效率和流程的控制。在面向过程编程中，数据和处理数据的方法是分离的，程序的执行过程是自顶向下的。</p>
<p>​		而面向对象编程则是以对象为中心的编程方式，也被称为概念式编程。面向对象编程强调的是对象的抽象、封装、继承和多态，注重的是对象之间的交互和协作。在面向对象编程中，数据和处理数据的方法是封装在一起的，程序的执行过程是由对象之间的消息传递和协作完成的。</p>
<p>具体来说，面向对象编程的优点包括：</p>
<ol>
<li>更容易理解和维护：面向对象编程使得程序的结构更加清晰，数据和处理数据的方法被封装在一起，更容易理解和维护。</li>
<li>更加灵活和可扩展：面向对象编程中，对象之间的关系可以通过继承、多态等方式进行组合，更加灵活和可扩展。</li>
<li>更加安全和可靠：面向对象编程中，数据和处理数据的方法被封装在一起，可以进行访问控制，避免数据被误用和损坏。</li>
</ol>
<p>而面向过程编程的优点包括：</p>
<ol>
<li>执行效率高：面向过程编程中，注重对算法和流程的控制，执行效率相对较高。</li>
<li>程序简单：面向过程编程中，程序的执行过程是自顶向下的，相对来说比较简单。</li>
<li>更容易理解和掌握：面向过程编程中，数据和处理数据的方法是分离的，更容易理解和掌握。</li>
</ol>
<p>​		综上所述，面向对象编程和面向过程编程都有其优缺点，选择何种编程思想应根据具体的业务场景和需求来确定。</p>
<h3 id="141-如果一个类没有声明构造方法该程序能正确执行吗">
  1.41 如果一个类没有声明构造方法，该程序能正确执行吗
  <a href="#141-%e5%a6%82%e6%9e%9c%e4%b8%80%e4%b8%aa%e7%b1%bb%e6%b2%a1%e6%9c%89%e5%a3%b0%e6%98%8e%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95%e8%af%a5%e7%a8%8b%e5%ba%8f%e8%83%bd%e6%ad%a3%e7%a1%ae%e6%89%a7%e8%a1%8c%e5%90%97" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		如果一个类没有声明构造方法，编译器会自动生成一个默认的无参构造方法。因此，该程序可以正确执行。如果该类的构造方法需要有参数，则必须显式地声明构造方法，否则编译器会报错。</p>
<h3 id="142-构造方法有哪些特点是否可被-override">
  1.42 构造方法有哪些特点，是否可被 override
  <a href="#142-%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b%e7%89%b9%e7%82%b9%e6%98%af%e5%90%a6%e5%8f%af%e8%a2%ab-override" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>构造方法是一种特殊的方法，用于创建对象并初始化其状态。它有以下特点：</p>
<ol>
<li>构造方法的名称必须与类名相同。</li>
<li>构造方法没有返回值类型，连 void 也不行。</li>
<li>构造方法可以重载，即一个类可以有多个不同参数列表的构造方法。</li>
<li>如果一个类没有定义构造方法，编译器会默认生成一个无参构造方法。</li>
<li>如果一个类定义了构造方法，但没有定义无参构造方法，那么在创建对象时如果没有指定参数，编译器会报错。</li>
</ol>
<p>构造方法可以被子类 override，但必须遵循以下规则：</p>
<ol>
<li>子类的构造方法必须调用父类的构造方法。</li>
<li>如果子类构造方法没有显式调用父类的构造方法，编译器会默认调用父类的无参构造方法。</li>
<li>如果父类没有无参构造方法，那么子类的构造方法必须显式调用父类的其他构造方法，并传入参数。</li>
</ol>
<h3 id="143-接口和抽象类有什么共同点和区别">
  1.43 接口和抽象类有什么共同点和区别
  <a href="#143-%e6%8e%a5%e5%8f%a3%e5%92%8c%e6%8a%bd%e8%b1%a1%e7%b1%bb%e6%9c%89%e4%bb%80%e4%b9%88%e5%85%b1%e5%90%8c%e7%82%b9%e5%92%8c%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>接口和抽象类都是为了实现面向对象编程中的抽象和封装。</p>
<p>共同点：</p>
<ol>
<li>都不能被实例化，需要子类来实现。</li>
<li>都可以包含抽象方法，子类需要实现这些方法。</li>
<li>都可以被用来实现多态，子类可以覆盖父类的方法。</li>
</ol>
<p>区别：</p>
<ol>
<li>抽象类可以包含普通方法和属性，而接口只能包含抽象方法和常量。</li>
<li>一个类只能继承一个抽象类，但可以实现多个接口。</li>
<li>抽象类的子类可以不实现抽象方法，而是继续被声明为抽象类，但接口的实现类必须实现接口中的所有抽象方法。</li>
<li>抽象类的构造方法可以被子类调用，而接口没有构造方法。</li>
<li>抽象类是对类的抽象，接口是对行为的抽象。</li>
</ol>
<p>​		因为抽象类可以包含普通方法和属性，所以可以用于一些有公共实现的类的抽象，而接口则更适用于定义规范和行为的约束。在设计时，需要根据具体的场景和需求来选择使用抽象类还是接口。</p>
<h3 id="144-什么是泛型有什么作用泛型的使用方式有哪几种">
  1.44 什么是泛型，有什么作用，泛型的使用方式有哪几种
  <a href="#144-%e4%bb%80%e4%b9%88%e6%98%af%e6%b3%9b%e5%9e%8b%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8%e6%b3%9b%e5%9e%8b%e7%9a%84%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		泛型是 Java 中的一种类型参数化机制，它提供了类型安全的编程方式，可以让程序员编写出更加通用、更加可读、更加稳定的代码。使用泛型可以让我们编写一份代码，让它能够适用于不同类型的数据，从而避免了因类型转换错误而引发的问题。</p>
<p>泛型的作用主要有以下几点：</p>
<ol>
<li>提供了类型安全的编程方式，避免了类型转换错误。</li>
<li>增强了代码的重用性和可读性，让程序员可以编写出更加通用的代码。</li>
<li>让程序员可以在编译期间就能够发现类型不匹配的错误。</li>
</ol>
<p>泛型的使用方式主要有以下几种：</p>
<ol>
<li>类型通配符：使用 ? 表示任意类型。例如 List<!-- raw HTML omitted --> 表示一个元素类型不确定的 List。</li>
<li>泛型方法：将泛型定义在方法上，例如：public <!-- raw HTML omitted --> void method(T t)。</li>
<li>泛型类：将泛型定义在类上，例如：public class GenericClass<!-- raw HTML omitted -->。</li>
<li>泛型接口：将泛型定义在接口上，例如：public interface GenericInterface<!-- raw HTML omitted -->。</li>
</ol>
<p>​		总之，泛型是 Java 语言中的一项重要特性，它可以让我们写出更加灵活、安全和通用的代码。在日常编码中，建议多使用泛型，以提高程序的可读性和稳定性。</p>
<h3 id="145-何为反射反射的优缺点有哪些说说反射的应用场景">
  1.45 何为反射，反射的优缺点有哪些，说说反射的应用场景
  <a href="#145-%e4%bd%95%e4%b8%ba%e5%8f%8d%e5%b0%84%e5%8f%8d%e5%b0%84%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9%e6%9c%89%e5%93%aa%e4%ba%9b%e8%af%b4%e8%af%b4%e5%8f%8d%e5%b0%84%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		反射（Reflection）是 Java 中的一种高级特性，它允许程序在运行时动态地获取类的信息、访问或修改对象的属性和方法，以及创建新的对象。反射机制使得 Java 程序可以检查和调用任意一个类的方法、属性、构造方法等，无需事先知道这个类的名称，只需要获得这个类的 Class 对象即可。</p>
<p>反射的优点：</p>
<ol>
<li>可以在程序运行时动态地获取类的信息，提高程序的灵活性和可扩展性。</li>
<li>可以对任意一个类进行操作，包括调用方法、获取属性等，使得程序更加灵活。</li>
</ol>
<p>反射的缺点：</p>
<ol>
<li>反射操作相对于直接调用类的方法和属性来说，会增加一定的开销，影响程序的运行效率。</li>
<li>反射使得代码难以理解和维护，降低了程序的可读性和可维护性。</li>
</ol>
<p>反射的应用场景：</p>
<ol>
<li>编写通用代码，例如数据库操作、ORM 框架等，需要动态地加载类、创建对象、调用方法等。</li>
<li>框架开发，例如 Spring、Hibernate 等，需要通过反射机制来加载配置文件中的类、调用其中的方法、注入依赖等。</li>
<li>动态代理，例如 AOP 框架等，需要在程序运行时动态地生成代理类，以实现横切逻辑。</li>
<li>单元测试，例如 JUnit 等，需要通过反射机制来调用被测试类中的私有方法和属性。</li>
</ol>
<h3 id="146-何为注解注解的解析方法有哪几种">
  1.46 何为注解，注解的解析方法有哪几种
  <a href="#146-%e4%bd%95%e4%b8%ba%e6%b3%a8%e8%a7%a3%e6%b3%a8%e8%a7%a3%e7%9a%84%e8%a7%a3%e6%9e%90%e6%96%b9%e6%b3%95%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		注解是一种元数据，可以用来给程序中的代码增加一些特定的信息或标记，以便于在运行时通过反射等机制对代码进行处理或者生成相应的文档。注解在 Java 语言中的特殊语法是在注解名称前面加上“@”符号。</p>
<p>Java 中的注解解析方式主要有以下几种：</p>
<ol>
<li>编译时注解处理器：这种方式是通过 Java 编译器来解析注解，在编译过程中生成相应的代码或配置文件。这种方式可以在编译时检查代码的正确性，并且可以在编译过程中生成一些额外的代码或文件。</li>
<li>运行时注解解析：这种方式是通过 Java 反射机制来解析注解，可以在程序运行时动态地读取和解析注解。这种方式通常用于框架开发中，可以通过注解来控制框架的行为。</li>
<li>字节码注解解析：这种方式是通过 Java 字节码来解析注解，可以在程序执行过程中对字节码进行修改。这种方式通常用于 AOP（面向切面编程）等技术中。</li>
</ol>
<p>注解的优点包括：</p>
<ol>
<li>可以提高程序的可读性和可维护性，使代码更加清晰明了。</li>
<li>可以减少编码量，提高开发效率。</li>
<li>可以为程序提供更多的元数据，使程序在运行时拥有更多的信息。</li>
</ol>
<p>注解的缺点包括：</p>
<ol>
<li>过度使用注解会使代码变得复杂难懂。</li>
<li>注解机制的使用需要谨慎，因为注解在编译和运行时都会产生一定的性能开销。</li>
</ol>
<p>注解的应用场景包括：</p>
<ol>
<li>用于框架开发中，可以通过注解来控制框架的行为。</li>
<li>用于测试框架中，可以通过注解来标记测试用例和测试方法。</li>
<li>用于持久化框架中，可以通过注解来映射 Java 对象和数据库表。</li>
<li>用于 Web 开发中，可以通过注解来处理 HTTP 请求和响应。</li>
</ol>
<h3 id="147-什么是序列化什么是反序列化">
  1.47 什么是序列化，什么是反序列化
  <a href="#147-%e4%bb%80%e4%b9%88%e6%98%af%e5%ba%8f%e5%88%97%e5%8c%96%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		序列化是将对象转换为字节序列的过程，方便在网络上传输或者保存到本地。反序列化是将字节序列还原为对象的过程。</p>
<p>​		在 Java 中，可以通过实现 Serializable 接口来使一个类可序列化，这个接口没有方法，仅仅是一个标记接口，表示该类支持序列化。在序列化和反序列化过程中，Java 对象的状态信息被转化为字节序列和反序列化后的 Java 对象的状态信息可以完全还原。</p>
<p>​		Java 中提供了两种序列化方式，一种是默认的序列化方式，另一种是自定义的序列化方式。默认的序列化方式可以通过实现 Serializable 接口来实现，自定义的序列化方式可以通过实现 Externalizable 接口来实现，它需要手动实现 readExternal 和 writeExternal 方法。</p>
<p>​		序列化可以实现跨平台的对象传输，而反序列化则可以将传输过来的对象还原为原来的对象。在分布式系统中，序列化和反序列化是非常重要的技术手段，例如在 RPC 调用中，客户端需要将参数序列化之后发送给服务器端，服务器端再将返回结果序列化之后发送给客户端。此外，在缓存中保存 Java 对象时，也需要将 Java 对象序列化成字节序列，以便在需要时可以快速地反序列化得到 Java 对象。</p>
<h3 id="148-java-io-流了解吗io-流为什么要分为字节流和字符流呢">
  1.48 Java IO 流了解吗，I/O 流为什么要分为字节流和字符流呢
  <a href="#148-java-io-%e6%b5%81%e4%ba%86%e8%a7%a3%e5%90%97io-%e6%b5%81%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%88%86%e4%b8%ba%e5%ad%97%e8%8a%82%e6%b5%81%e5%92%8c%e5%ad%97%e7%ac%a6%e6%b5%81%e5%91%a2" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Java IO 流提供了一种标准的输入/输出机制，用于与各种设备进行通信，如文件、网络连接、控制台等。</p>
<p>​		Java I/O 流根据处理数据的单位不同分为字节流和字符流。</p>
<ol>
<li>字节流：</li>
</ol>
<ul>
<li>字节流以字节为单位进行读写，适用于所有类型的数据，包括二进制数据和文本数据。</li>
<li>InputStream 和 OutputStream 是字节流的抽象类。</li>
</ul>
<ol start="2">
<li>字符流：</li>
</ol>
<ul>
<li>字符流以字符为单位进行读写，适用于文本数据。</li>
<li>Reader 和 Writer 是字符流的抽象类。</li>
</ul>
<p>​		主要原因是不同的数据类型需要使用不同的编码方式进行输入/输出，字符流使用的是 Unicode 编码，而字节流则没有固定的编码方式，通常使用 ASCII 码或其他编码方式进行输入/输出。字符流可以直接操作字符数据，不需要像字节流那样先进行转换。因此，当需要读写文本文件时，使用字符流更为方便，而读写二进制文件则需要使用字节流。</p>
<h3 id="149-bionio-和-aio-的区别">
  1.49 BIO、NIO 和 AIO 的区别
  <a href="#149-bionio-%e5%92%8c-aio-%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		BIO、NIO 和 AIO 都是 Java 中用于网络编程的 API（application programming interface，应用程序接口），它们之间的主要区别在于它们的工作方式和适用场景。</p>
<ol>
<li>BIO（Blocking I/O）：同步阻塞模式，传统的 Java I/O 模型。在这种模型下，每个连接都会占用一个线程，因此无法同时处理大量连接，容易导致服务器性能瓶颈。BIO 适用于连接数比较少且连接比较长的情况。</li>
<li>NIO（Non-blocking I/O）：同步非阻塞模式，引入了 Channel、Buffer 和 Selector 等新的概念，可以实现一个线程处理多个请求，但是需要对请求进行轮询才能找出可以处理的请求，因此编程复杂度较高。NIO 适用于连接数多且连接比较短的情况。</li>
<li>AIO（Asynchronous I/O）：异步非阻塞模式，引入了 CompletionHandler 回调函数，可以在数据准备好之后再通知线程进行读写操作，因此不需要轮询，编程复杂度相对较低。AIO 适用于连接数多且连接比较短的情况，适合实现高并发的网络应用。</li>
</ol>
<p>​		综上所述，BIO 适用于连接数比较少且连接比较长的情况，NIO 适用于连接数多且连接比较短的情况，AIO 适用于实现高并发的网络应用。</p>
<h3 id="150-详细介绍下-cookie-和-session">
  1.50 详细介绍下 Cookie 和 Session
  <a href="#150-%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d%e4%b8%8b-cookie-%e5%92%8c-session" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Cookie 和 Session 都是 Web 应用程序中常用的会话管理技术，它们用于在客户端和服务器端之间维护用户状态信息。</p>
<p>​		Cookie 是服务器发送到客户端的小型文本文件，保存在客户端的浏览器中。它包含了一些用户相关的信息，如用户名、购物车信息等。当客户端向服务器发出请求时，会自动将相应的 Cookie 信息发送到服务器端。服务器可以利用 Cookie 来识别客户端，从而实现状态管理的功能。Cookie 主要有以下特点：</p>
<ul>
<li>Cookie 存在于客户端，可以被客户端修改或删除。</li>
<li>Cookie 可以设置过期时间，过期后会被自动删除。</li>
<li>Cookie 的大小受到浏览器和服务器的限制，一般不能超过 4KB。</li>
</ul>
<p>​		Session 是服务器端保存用户状态的一种机制。当客户端向服务器发出请求时，服务器会为每个会话创建一个唯一的 Session ID，然后将这个 Session ID 发送给客户端。客户端在之后的请求中会自动携带这个 Session ID，服务器就可以根据 Session ID 来识别客户端，从而实现状态管理的功能。Session 主要有以下特点：</p>
<ul>
<li>Session 存在于服务器端，客户端无法修改或删除。</li>
<li>Session 可以存储任意类型的数据，比 Cookie 更加灵活。</li>
<li>Session 的大小受到服务器的限制，一般没有特别严格的大小限制。</li>
</ul>
<p>​		需要注意的是，Session 依赖于 Cookie。在默认情况下，服务器会将 Session ID 保存在 Cookie 中发送给客户端。如果客户端禁用了 Cookie，那么 Session 将无法正常工作。为了解决这个问题，可以采用 URL 重写或者使用 HTML5 提供的 Web 存储技术。</p>
<h1 id="第2章-集合框架">
  第2章 集合框架
  <a href="#%e7%ac%ac2%e7%ab%a0-%e9%9b%86%e5%90%88%e6%a1%86%e6%9e%b6" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="21-listsetmap-三者的区别">
  2.1 List，Set，Map 三者的区别
  <a href="#21-listsetmap-%e4%b8%89%e8%80%85%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有 Set、List、Queue 三种子接口。我们比较常用的是 Set、List， Map 接口不是 Collection 的子接口。</p>
</li>
<li>
<p>Collection 集合主要有 List 和 Set 两大接口：</p>
</li>
</ul>
<ul>
<li>
<ul>
<li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个 null 元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>
</ul>
</li>
</ul>
<ul>
<li>
<ul>
<li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个 null 元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li>
</ul>
</li>
<li>
<p>Map 是一个键值对集合，存储键、值和之间的映射。 Key 无序，唯一；value 不要求有序，允许重复。Map 没有继承于 Collection 接口，从 Map 集合中检索元素时，只要给出键对象，就会返回对应的值对象。</p>
</li>
<li>
<p>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p>
</li>
</ul>
<h3 id="22-array-和-arraylist-有何区别">
  2.2 Array 和 ArrayList 有何区别
  <a href="#22-array-%e5%92%8c-arraylist-%e6%9c%89%e4%bd%95%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Array 和 ArrayList 都是用来存储一组数据的 Java 集合类型，但是有以下几点不同：</p>
<ol>
<li>Array 是 Java 中的数组，是一种固定大小的数据结构，一旦创建后大小就无法改变。ArrayList 是 Java 中的动态数组，大小可以根据需要自动增长或缩小。</li>
<li>Array 可以存储基本类型和对象类型，而 ArrayList 只能存储对象类型。</li>
<li>Array 可以直接通过下标访问元素，而 ArrayList 需要通过 get() 方法来访问元素。</li>
<li>Array 在初始化时需要指定数组长度，而 ArrayList 可以直接创建空列表，后续再添加元素。</li>
<li>Array 的元素可以是任何数据类型，包括基本类型和对象类型，而 ArrayList 只能存储对象类型。</li>
<li>Array 存储的是实际的元素，而 ArrayList 存储的是对象的引用。</li>
<li>Array 可以直接通过数组拷贝方法对数组进行复制和排序，而 ArrayList 需要通过 Collections 工具类来实现复制和排序等操作。</li>
</ol>
<p>​		综上所述，Array 适用于存储大小固定且类型确定的数据集合，而 ArrayList 适用于存储大小不确定且类型不固定的数据集合。</p>
<h3 id="23-如何实现-array-和-list-之间的转换">
  2.3 如何实现 Array 和 List 之间的转换
  <a href="#23-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0-array-%e5%92%8c-list-%e4%b9%8b%e9%97%b4%e7%9a%84%e8%bd%ac%e6%8d%a2" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Java 中，可以使用 <code>Arrays.asList()</code> 方法将一个数组转换为 List。示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String<span style="color:#f92672">[]</span> array <span style="color:#f92672">=</span> <span style="color:#f92672">{</span> <span style="color:#e6db74">&#34;foo&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;bar&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;baz&#34;</span> <span style="color:#f92672">};</span>
</span></span><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>array<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>​		需要注意的是，<code>Arrays.asList()</code> 返回的是一个固定大小的 List，该 List 不支持 add、remove 等修改操作。如果需要对转换后的 List 进行修改，需要使用另外一种方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String<span style="color:#f92672">[]</span> array <span style="color:#f92672">=</span> <span style="color:#f92672">{</span> <span style="color:#e6db74">&#34;foo&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;bar&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;baz&#34;</span> <span style="color:#f92672">};</span>
</span></span><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>array<span style="color:#f92672">));</span>
</span></span></code></pre></div><p>​		上述代码将转换后的 List 作为构造函数参数传递给了一个 ArrayList，这样就可以对 List 进行任意修改操作了。反过来，可以使用 <code>List.toArray()</code> 方法将一个 List 转换为数组：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
</span></span><span style="display:flex;"><span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;foo&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;bar&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;baz&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>String<span style="color:#f92672">[]</span> array <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">]);</span>
</span></span></code></pre></div><p>​		上述代码将 List 转换为了一个 String 类型的数组。需要注意的是，在 <code>toArray()</code> 方法中需要传递一个数组类型的参数，用于指定返回的数组类型，同时也可以通过传递一个空数组来自动推断返回的数组类型。</p>
<h3 id="24-arraylist-与-linkedlist-区别">
  2.4 Arraylist 与 LinkedList 区别
  <a href="#24-arraylist-%e4%b8%8e-linkedlist-%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>ArrayList 和 LinkedList 都是 Java 中常用的 List 集合实现类，它们的实现方式有所不同，因此在使用时需要考虑它们的特点和适用场景。</p>
<ol>
<li>实现方式的不同：</li>
</ol>
<p>​		ArrayList 是通过数组实现的，每个元素在内存中是连续的。当需要插入或删除元素时，需要将后续元素进行移动，因此插入和删除元素的效率较低。但是，由于每个元素在内存中是连续的，因此在读取元素时，具有较好的缓存命中率，因此读取元素的效率较高。</p>
<p>​		LinkedList 是通过双向链表实现的，每个元素在内存中是不连续的。当需要插入或删除元素时，只需要修改前后元素的指针，因此插入和删除元素的效率较高。但是，在读取元素时，由于元素在内存中是不连续的，因此缓存命中率较低，读取元素的效率较低。</p>
<ol start="2">
<li>内存占用的不同：</li>
</ol>
<p>​		ArrayList 是通过数组实现的，每个元素占用固定的内存空间，因此当数组大小不足时，需要扩容，会占用更多的内存空间。当数组大小超过实际元素个数时，会浪费一定的内存空间。</p>
<p>​		LinkedList 是通过链表实现的，每个元素占用不固定的内存空间，除了元素本身的内存空间外，还需要额外存储前后元素的指针，因此占用的内存空间较大。</p>
<ol start="3">
<li>随机访问的效率：</li>
</ol>
<p>​		由于 ArrayList 的每个元素在内存中是连续的，因此可以通过索引随机访问元素，具有较好的随机访问效率。</p>
<p>​		而 LinkedList 中的元素在内存中是不连续的，因此需要遍历链表才能访问指定索引的元素，具有较差的随机访问效率。根据上述特点，一般建议在以下情况下使用：</p>
<ul>
<li>当需要大量随机访问元素时，建议使用 ArrayList。</li>
<li>当需要大量插入和删除元素时，建议使用 LinkedList。</li>
<li>当只需要在末尾添加元素，并且需要快速访问时，也可以考虑使用 ArrayList。</li>
</ul>
<h3 id="25-arraylist-与-vector-区别">
  2.5 ArrayList 与 Vector 区别
  <a href="#25-arraylist-%e4%b8%8e-vector-%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>ArrayList 和 Vector 都是 Java 中常用的 List 集合实现类，它们有很多相似之处，但也有一些区别，主要包括以下几点：</p>
<ol>
<li>线程安全性：</li>
</ol>
<p>​		ArrayList 是非线程安全的，多个线程同时操作同一个 ArrayList 实例可能会导致数据不一致的问题。</p>
<p>​		Vector 是线程安全的，它的每个方法都被 synchronized 修饰，因此在多线程环境中使用 Vector 可以保证线程安全性。</p>
<ol start="2">
<li>扩容方式：</li>
</ol>
<p>​		ArrayList 和 Vector 在内部实现上都是通过数组实现的，当数组大小不足时，需要进行扩容。ArrayList 在扩容时，会将容量增加50%，而 Vector 会将容量增加一倍。</p>
<ol start="3">
<li>性能：</li>
</ol>
<p>​		由于 Vector 需要在每个方法上加锁，因此在单线程环境下性能较差。而 ArrayList 在单线程环境下性能较好，但在多线程环境下需要考虑同步问题。</p>
<ol start="4">
<li>集合实现版本：</li>
</ol>
<p>​		ArrayList 从 JDK 1.2 开始引入，而 Vector 则是从 JDK 1.0 就已经存在了，因此 Vector 比 ArrayList 更加兼容旧版本的 Java。</p>
<p>​		总的来说，如果在单线程环境下，建议使用 ArrayList；如果在多线程环境下，建议使用 Vector。但是，随着 Java 集合框架的发展，现在更加推荐使用线程安全的集合类，如 CopyOnWriteArrayList、ConcurrentLinkedDeque 等，它们可以在保证线程安全的同时，不影响性能。</p>
<h3 id="26-集合框架底层数据结构">
  2.6 集合框架底层数据结构
  <a href="#26-%e9%9b%86%e5%90%88%e6%a1%86%e6%9e%b6%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Java 集合框架中常用的数据结构包括数组、链表、哈希表、树等。</p>
<p>下面是集合框架中常用的数据结构和对应的接口：</p>
<ul>
<li>数组：使用数组实现的集合有 ArrayList 和数组。ArrayList 是基于动态数组实现的，而数组是静态的，一旦创建就无法更改大小。</li>
<li>链表：使用链表实现的集合有 LinkedList。LinkedList 是双向链表，每个节点都包含了前后指针。</li>
<li>哈希表：使用哈希表实现的集合有 HashMap、HashSet、LinkedHashMap、LinkedHashSet。哈希表使用了散列表来存储键值对，可以快速地查找和插入元素。</li>
<li>树：使用树实现的集合有 TreeMap、TreeSet。TreeMap 是基于红黑树实现的，TreeSet 是基于 TreeMap 实现的。</li>
</ul>
<p>​		除了上述常用的数据结构外，Java 集合框架还包括一些其他的数据结构，比如栈、队列、优先队列等，它们的实现方式也各不相同。</p>
<h3 id="27-哪些集合类是线程安全的">
  2.7 哪些集合类是线程安全的
  <a href="#27-%e5%93%aa%e4%ba%9b%e9%9b%86%e5%90%88%e7%b1%bb%e6%98%af%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Java 中的集合类分为线程安全和非线程安全两类。线程安全的集合类是多线程环境下可以安全地被多个线程并发访问而不会出现线程安全问题的集合类。</p>
<p>Java 中的线程安全的集合类主要有以下几个：</p>
<ol>
<li>ConcurrentHashMap：基于哈希表的线程安全 Map 实现，支持高并发、高吞吐量的操作，读操作不需要加锁，写操作只锁住部分数据，效率很高。</li>
<li>CopyOnWriteArrayList：基于数组实现的线程安全 List，每次对集合的修改都会将原有集合进行一次复制，并在新集合上进行修改操作，修改完成后再将新集合赋值回原有引用。这样做可以保证并发修改时不会出现异常，但会引起一定的内存消耗和性能损失，适合读多写少的场景。</li>
<li>CopyOnWriteArraySet：基于 CopyOnWriteArrayList 实现的线程安全 Set，本质上就是一个线程安全的 HashSet。</li>
<li>ConcurrentLinkedQueue：基于链表实现的线程安全队列，支持高并发、高吞吐量的操作。</li>
<li>ConcurrentLinkedDeque：基于双向链表实现的线程安全双端队列，也支持高并发、高吞吐量的操作。</li>
<li>BlockingQueue：一个支持阻塞的队列接口，常用实现类有 ArrayBlockingQueue、LinkedBlockingQueue 等，可以用于实现生产者-消费者模型。</li>
</ol>
<p>​		除了以上线程安全的集合类之外，还可以通过使用 Collections 工具类提供的 synchronizedXXX() 方法将普通的集合类转换为线程安全的集合类。但需要注意的是，这种方式只能保证单个操作的原子性，无法保证连续多个操作的原子性，所以并不适合高并发场景。</p>
<h3 id="28-java-集合的快速失败机制-fail-fast">
  2.8 Java 集合的快速失败机制 “fail-fast“
  <a href="#28-java-%e9%9b%86%e5%90%88%e7%9a%84%e5%bf%ab%e9%80%9f%e5%a4%b1%e8%b4%a5%e6%9c%ba%e5%88%b6-fail-fast" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Java 集合的快速失败机制，也称为“fail-fast”，是指在多线程环境下，如果一个线程对集合进行了结构上的修改，那么其他线程在对该集合进行迭代或者操作时，就会抛出 ConcurrentModificationException 异常，从而提醒用户集合已经被修改，不要进行操作。</p>
<p>​		快速失败机制的目的是为了保证在多线程环境下集合的一致性和稳定性。如果没有快速失败机制，那么其他线程在进行操作时，就有可能会使用到被修改过的数据，从而导致数据不一致性和不可预期的结果。</p>
<p>​		需要注意的是，快速失败机制只是一种检测机制，并不能保证线程安全。在多线程环境下，如果需要保证集合的线程安全性，可以使用线程安全的集合，或者使用同步措施进行保护。</p>
<h3 id="29-怎么确保一个集合不能被修改">
  2.9 怎么确保一个集合不能被修改
  <a href="#29-%e6%80%8e%e4%b9%88%e7%a1%ae%e4%bf%9d%e4%b8%80%e4%b8%aa%e9%9b%86%e5%90%88%e4%b8%8d%e8%83%bd%e8%a2%ab%e4%bf%ae%e6%94%b9" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		要确保一个集合不能被修改，可以使用 Java 集合框架中的<code>Collections</code>类的<code>unmodifiableXXX()</code>方法，例如<code>unmodifiableList()</code>、<code>unmodifiableSet()</code>等方法来创建一个不可修改的集合对象。</p>
<p>​		这些方法返回的集合对象是一个只读的包装器，对其进行任何修改操作都将抛出<code>UnsupportedOperationException</code>异常。这种方法是一种轻量级的实现方式，可以用来保护不想被修改的集合对象，而不用自己手动实现一种只读集合。</p>
<h3 id="210-迭代器-iterator-是什么怎么使用有什么特点">
  2.10 迭代器 Iterator 是什么，怎么使用，有什么特点
  <a href="#210-%e8%bf%ad%e4%bb%a3%e5%99%a8-iterator-%e6%98%af%e4%bb%80%e4%b9%88%e6%80%8e%e4%b9%88%e4%bd%bf%e7%94%a8%e6%9c%89%e4%bb%80%e4%b9%88%e7%89%b9%e7%82%b9" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Java 中，迭代器（Iterator）是一种设计模式，用于遍历集合（Collection）中的元素而<strong>无需暴露其底层实现</strong>。使用迭代器，可以在不知道集合底层结构的情况下，遍历集合中的元素。Java 中的所有集合框架都提供了迭代器。</p>
<p>​		迭代器可以通过调用 <code>iterator()</code> 方法获得。该方法返回一个迭代器对象，其实现基于集合的类型和底层数据结构。</p>
<p>使用迭代器，可以通过以下方法遍历集合：</p>
<ul>
<li><code>hasNext()</code>：检查是否还有元素可以遍历；</li>
<li><code>next()</code>：返回当前指向的元素，并将指针向后移动一个位置；</li>
<li><code>remove()</code>：从底层集合中删除迭代器返回的最后一个元素（可选操作）。</li>
</ul>
<p>迭代器有以下特点：</p>
<ul>
<li>迭代器是一次性的，遍历过程中只能往后遍历，不能往前遍历或者重置迭代器。</li>
<li>迭代器只能在迭代的同时删除元素，如果在遍历时对集合进行修改（添加或删除元素），可能会导致迭代器失效或抛出异常。</li>
<li>迭代器不支持多线程，如果需要在多线程中使用迭代器，需要进行手动同步或使用线程安全的集合类。</li>
<li>在集合中遍历时，如果使用迭代器的 <code>remove()</code> 方法删除元素，不会抛出 <code>ConcurrentModificationException</code> 异常，而是直接从集合中删除元素。</li>
</ul>
<p>​		总之，迭代器提供了一种安全和方便的方式来遍历集合中的元素，同时也需要注意它的使用限制和特点。</p>
<h3 id="211-如何边遍历边移除-collection-中的元素">
  2.11 如何边遍历边移除 Collection 中的元素
  <a href="#211-%e5%a6%82%e4%bd%95%e8%be%b9%e9%81%8d%e5%8e%86%e8%be%b9%e7%a7%bb%e9%99%a4-collection-%e4%b8%ad%e7%9a%84%e5%85%83%e7%b4%a0" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在遍历 Collection 时，如果需要边遍历边删除元素，可以使用迭代器 Iterator 的 remove() 方法。该方法可以从集合中删除上一次 next() 方法返回的元素。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;c&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;d&#34;</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>Iterator<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    String element <span style="color:#f92672">=</span> iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>element<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>​		这段代码遍历了一个包含 &ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;c&rdquo;, &ldquo;d&rdquo; 四个元素的 List，并在遍历时删除了值为 &ldquo;b&rdquo; 的元素。需要注意的是，在使用迭代器的 remove() 方法时，必须先调用 next() 方法获得要删除的元素，否则会抛出 IllegalStateException 异常。另外，如果在遍历时直接使用集合的 remove() 方法，也会导致 ConcurrentModificationException 异常。</p>
<h3 id="212-iterator-和-listiterator-有什么区别">
  2.12 Iterator 和 ListIterator 有什么区别
  <a href="#212-iterator-%e5%92%8c-listiterator-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Iterator 和 ListIterator 都是 Java 集合框架中用于遍历集合元素的接口，但是有以下区别：</p>
<ol>
<li>功能不同：Iterator 只能单向遍历集合元素，而 ListIterator 可以双向遍历，还可以添加、修改、删除集合中的元素。</li>
<li>使用范围不同：Iterator 可以遍历 List、Set 和 Map 中的元素，而 ListIterator 只能遍历 List 中的元素。</li>
<li>方法不同：ListIterator 在 Iterator 的基础上增加了以下方法：previous()、hasPrevious()、nextIndex()、previousIndex()、add()、set() 和 remove()。</li>
</ol>
<p>​		总之，如果需要在遍历 List 的过程中进行添加、修改或删除元素的操作，应该使用 ListIterator。而如果只是需要单向遍历 List，或者遍历 Set 或 Map，可以使用 Iterator。</p>
<h3 id="213-遍历一个-list-有哪些不同的方式每种方法的实现原理是什么java-中-list-遍历的最佳实践是什么">
  2.13 遍历一个 List 有哪些不同的方式，每种方法的实现原理是什么，Java 中 List 遍历的最佳实践是什么
  <a href="#213-%e9%81%8d%e5%8e%86%e4%b8%80%e4%b8%aa-list-%e6%9c%89%e5%93%aa%e4%ba%9b%e4%b8%8d%e5%90%8c%e7%9a%84%e6%96%b9%e5%bc%8f%e6%af%8f%e7%a7%8d%e6%96%b9%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88java-%e4%b8%ad-list-%e9%81%8d%e5%8e%86%e7%9a%84%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>遍历一个 List 可以使用以下不同的方式：</p>
<ol>
<li>for 循环：使用普通的 for 循环可以遍历 List 中的元素。可以使用 List 的 <code>size()</code> 方法获取 List 的大小，并使用索引遍历每个元素。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;apple&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;banana&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;orange&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="2">
<li>增强型 for 循环：Java 5 引入了增强型 for 循环，可以更方便地遍历 List 中的元素。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;apple&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;banana&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;orange&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String fruit <span style="color:#f92672">:</span> list<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>fruit<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="3">
<li>迭代器：使用 List 的迭代器可以遍历 List 中的元素。可以使用 <code>hasNext()</code> 方法检查是否有下一个元素，并使用 <code>next()</code> 方法获取下一个元素。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;apple&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;banana&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;orange&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>Iterator<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> iterator <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>iterator<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>​		最佳实践是使用增强型 for 循环遍历 List。相比普通的 for 循环和迭代器，增强型 for 循环更简洁、更易读，而且避免了下标越界和忘记调用 <code>next()</code> 的问题。但如果需要同时遍历和修改 List，或者需要在遍历时使用索引，那么普通的 for 循环可能更合适。</p>
<h3 id="214-说一下-arraylist-的优缺点">
  2.14 说一下 ArrayList 的优缺点
  <a href="#214-%e8%af%b4%e4%b8%80%e4%b8%8b-arraylist-%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>ArrayList 是 Java 集合框架中常用的动态数组实现类，具有以下优缺点：</p>
<p>优点：</p>
<ol>
<li>随机访问元素快：可以通过索引快速访问数组中的元素，时间复杂度为 O(1)；</li>
<li>方便插入删除：插入和删除元素时，只需要移动数组中的元素即可，时间复杂度为 O(n)，但是在末尾插入和删除元素的时间复杂度为 O(1)；</li>
<li>实现了可变长度数组：与传统数组相比，ArrayList 可以根据需要动态增长数组的大小，而不需要手动创建一个新数组并复制元素，因此更加方便。</li>
</ol>
<p>缺点：</p>
<ol>
<li>插入删除操作效率低：插入和删除元素时，需要移动数组中的元素，时间复杂度为 O(n)；</li>
<li>需要连续的内存空间：在创建 ArrayList 时需要分配一段连续的内存空间，如果连续内存空间不足，则需要进行扩容操作，此时需要重新分配内存空间，并将原数组中的元素复制到新的数组中，如果数组长度比较大，则扩容操作会比较耗时；</li>
<li>线程不安全：ArrayList 不是线程安全的，在并发环境下需要进行额外的同步操作，否则可能出现数据不一致的情况。</li>
</ol>
<p>最佳实践：</p>
<ol>
<li>尽量指定 ArrayList 的初始容量，以减少扩容操作的次数，提高性能；</li>
<li>在插入和删除元素时，如果没有特殊的需求，尽量从 List 的末尾进行操作，以避免数组的移动操作，提高效率；</li>
<li>在多线程环境下，尽量使用线程安全的集合类或者手动进行同步操作。</li>
</ol>
<h3 id="215-插入数据时arraylistlinkedlistvector-谁速度较快阐述-arraylistvectorlinkedlist-的存储性能和特性">
  2.15 插入数据时，ArrayList、LinkedList、Vector 谁速度较快，阐述 ArrayList、Vector、LinkedList 的存储性能和特性
  <a href="#215-%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae%e6%97%b6arraylistlinkedlistvector-%e8%b0%81%e9%80%9f%e5%ba%a6%e8%be%83%e5%bf%ab%e9%98%90%e8%bf%b0-arraylistvectorlinkedlist-%e7%9a%84%e5%ad%98%e5%82%a8%e6%80%a7%e8%83%bd%e5%92%8c%e7%89%b9%e6%80%a7" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在插入数据时，LinkedList 比 ArrayList 和 Vector 更快，因为 LinkedList 的插入操作只需要修改链表的指针，而 ArrayList 和 Vector 需要移动数组中的元素。ArrayList 和 Vector 内部都是通过数组实现的，它们在随机访问元素时速度非常快，但在插入或删除元素时需要移动元素，速度比 LinkedList 慢。</p>
<p>​		ArrayList 和 Vector 的区别在于线程安全和增长因子。Vector 是线程安全的，而 ArrayList 不是。Vector 的增长因子是原来数组长度的 2 倍，而 ArrayList 的增长因子是原来数组长度的一半。由于数组实现的局限性，Vector 和 ArrayList 的存储性能随着元素数量的增加而降低，因为它们需要重新分配更大的内存块并将所有元素复制到新块中。LinkedList 使用链表存储元素，它的存储性能比 ArrayList 和 Vector 更好，但在随机访问元素时速度较慢。</p>
<h3 id="216-多线程场景下如何使用-arraylist">
  2.16 多线程场景下如何使用 ArrayList
  <a href="#216-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%9c%ba%e6%99%af%e4%b8%8b%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-arraylist" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在多线程场景下，如果需要使用 ArrayList，需要注意以下几点：</p>
<ol>
<li>线程安全问题：ArrayList 是非线程安全的，如果多个线程同时对 ArrayList 进行修改操作，可能会导致数据异常或者抛出 ConcurrentModificationException 异常。因此，在多线程场景下，可以考虑使用线程安全的 Vector 或者通过 Collections 工具类提供的 synchronizedList 方法将 ArrayList 转化为线程安全的集合。</li>
<li>性能问题：ArrayList 是基于数组实现的，如果频繁进行插入和删除操作，可能会导致数组的扩容和数据的复制，影响性能。因此，在多线程场景下，如果需要频繁进行插入和删除操作，可以考虑使用基于链表实现的 LinkedList，或者使用 CopyOnWriteArrayList。</li>
<li>内存可见性问题：由于 ArrayList 是非线程安全的，因此在多线程场景下，如果一个线程对 ArrayList 进行了修改操作，可能会导致其他线程看到的是修改前的数据，即存在内存可见性问题。为了解决这个问题，可以使用 volatile 关键字或者 synchronized 关键字来保证数据的可见性。</li>
</ol>
<p>​		综上所述，在多线程场景下，如果需要使用 ArrayList，需要注意线程安全问题、性能问题和内存可见性问题，并根据实际情况选择合适的解决方案。</p>
<h3 id="217-说一下-hashset-的实现原理">
  2.17 说一下 HashSet 的实现原理
  <a href="#217-%e8%af%b4%e4%b8%80%e4%b8%8b-hashset-%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		HashSet 是基于哈希表实现的无序集合，它继承自 AbstractSet，实现了 Set 接口。</p>
<p>​		在 HashSet 内部，元素是通过哈希表来存储的，具体的实现是一个 HashMap 实例，其中每个元素作为键存储在 HashMap 中，而值则是一个常量对象。HashSet 中的所有元素都必须实现 hashCode 方法和 equals 方法。当我们把元素添加到 HashSet 中时，HashSet 会调用元素的 hashCode 方法来得到该元素的哈希码，然后根据哈希码找到元素在哈希表中对应的位置，如果该位置上已经有元素了，就调用元素的 equals 方法与新元素比较，如果相等就不添加到集合中，如果不相等则添加到集合中。</p>
<p>HashSet 具有以下特点：</p>
<ol>
<li>无序性：HashSet 中的元素是无序的，元素的存储顺序并不是添加顺序。</li>
<li>唯一性：HashSet 中的元素是唯一的，不允许重复。</li>
<li>线程不安全：HashSet 不是线程安全的集合，如果多个线程同时修改 HashSet，可能会导致不可预期的结果。</li>
<li>初始容量和负载因子：在创建 HashSet 实例时，可以指定初始容量和负载因子。初始容量指的是 HashSet 的初始大小，负载因子指的是 HashSet 在达到多少容量时会自动扩容。默认情况下，初始容量为 16，负载因子为 0.75。</li>
</ol>
<p>​		由于 HashSet 内部使用哈希表存储元素，因此它的查询速度非常快，但是添加和删除操作比较耗时。如果在多线程场景下使用 HashSet，需要使用 Collections.synchronizedSet 方法或者使用 ConcurrentHashMap 实现线程安全的集合。</p>
<h3 id="218-hashset-如何检查重复hashset-是如何保证数据不可重复的">
  2.18 HashSet 如何检查重复，HashSet 是如何保证数据不可重复的
  <a href="#218-hashset-%e5%a6%82%e4%bd%95%e6%a3%80%e6%9f%a5%e9%87%8d%e5%a4%8dhashset-%e6%98%af%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e6%95%b0%e6%8d%ae%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e7%9a%84" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		HashSet 通过哈希表来实现，哈希表的底层是一个数组，数组中的每个元素都是一个单向链表。当元素被添加到 HashSet 中时，HashSet 会先根据元素的哈希码（通过对象的 <code>hashCode()</code> 方法获取）计算出该元素在数组中的位置，然后将元素插入到对应位置的链表中。</p>
<p>​		当向 HashSet 中插入一个元素时，HashSet 会先通过 <code>hashCode()</code> 方法计算元素的哈希码，然后根据哈希码计算出元素在数组中的位置。如果该位置上已经存在元素，则会遍历对应位置上的链表，检查链表中是否已经存在该元素，如果已经存在则不会将该元素插入到集合中，否则将该元素插入到链表的头部。</p>
<p>​		HashSet 通过哈希表实现，不仅能够高效地判断元素是否存在集合中，而且插入、删除操作的效率也非常高，时间复杂度为 O(1)。但是 HashSet 的实现依赖于对象的 <code>hashCode()</code> 方法，如果对象的 <code>hashCode()</code> 方法实现不好，可能会导致哈希表中元素的分布不均匀，进而影响到 HashSet 的性能。</p>
<h3 id="219-hashset-与-hashmap-的区别">
  2.19 HashSet 与 HashMap 的区别
  <a href="#219-hashset-%e4%b8%8e-hashmap-%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		HashSet 和 HashMap 的底层都是使用哈希表实现的，但是它们的用途和实现方式有所不同。</p>
<p>​		HashSet 是一个无序的、不可重复的集合。它通过将元素作为 HashMap 的 key 存储来实现的，而 value 则被设为一个虚拟的 Object 对象。</p>
<p>​		HashMap 是一个映射表，它通过将 key-value 对存储在哈希表中来实现的。HashMap 允许 key 和 value 都为 null，但是只允许一个 null 的 key。</p>
<p>HashSet 和 HashMap 的区别主要在于：</p>
<ol>
<li>HashSet 只存储一个对象，而 HashMap 存储键值对。</li>
<li>HashSet 使用元素作为 HashMap 的 key，而 value 则被设为一个虚拟的 Object 对象。</li>
<li>HashSet 对于重复元素的处理是直接判断元素的 hashCode 和 equals 方法，而 HashMap 则需要同时判断 key 的 hashCode 和equals 方法。</li>
</ol>
<p>​		因此，HashSet 和 HashMap 的使用场景也不同。HashSet 通常用于需要快速判断元素是否存在的场景，而 HashMap 通常用于需要键值对映射的场景。</p>
<h3 id="220-什么是-hash-算法">
  2.20 什么是 Hash 算法
  <a href="#220-%e4%bb%80%e4%b9%88%e6%98%af-hash-%e7%ae%97%e6%b3%95" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		哈希算法（Hash Algorithm）是一种从任何一种数据中创建小的数字“指纹”的方法，其目的是为了让数据的检索更快速。哈希算法把任意长度的输入（又叫做预映射， pre-image），压缩到某一个固定长度的输出，也就是哈希值（又叫做散列值， digest）。哈希值通常是一个 32 位或者 64 位的二进制数，用于确保数据的完整性和一致性。</p>
<h3 id="221-hashmap-的底层实现">
  2.21 HashMap 的底层实现
  <a href="#221-hashmap-%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		HashMap 是 Java 中非常常用的一种数据结构，它是基于<strong>哈希表</strong>实现的。在 HashMap 中，每个元素包含一个<strong>键</strong>对象和一个<strong>值</strong>对象，它们都可以为 null。HashMap 的底层数据结构是一个<strong>数组</strong>，每个元素是一个链表，链表中存放的是哈希值相同的键值对。</p>
<p>​		当向 HashMap 中插入元素时，首先根据键对象的 hashCode 方法计算出哈希值，然后通过哈希值得到数组中的索引位置。如果该位置上没有元素，则直接将键值对插入该位置；如果该位置上已经有元素了，则需要遍历链表，判断键对象是否相等，如果相等则覆盖值对象，否则将键值对插入链表的末尾。</p>
<p>​		在使用 HashMap 时，需要注意以下几点：</p>
<ol>
<li>HashMap 的初始容量和负载因子</li>
</ol>
<p>​		HashMap 的初始容量指的是在创建 HashMap 时，数组的初始大小。负载因子是 HashMap 在自动扩容时，数组大小与元素个数的比值。当元素个数超过容量与负载因子的乘积时，HashMap 会自动扩容。</p>
<ol start="2">
<li>哈希冲突</li>
</ol>
<p>​		由于哈希表的大小是有限的，所以当不同的键对象具有相同的哈希值时，就会发生哈希冲突。为了解决哈希冲突，HashMap 使用了链表的方式存储相同哈希值的键值对。</p>
<ol start="3">
<li>线程安全性</li>
</ol>
<p>​		HashMap 是非线程安全的，如果多个线程同时对 HashMap 进行修改，则可能会发生数据不一致的情况。可以考虑使用ConcurrentHashMap 等线程安全的 HashMap 替代。</p>
<ol start="4">
<li>迭代顺序</li>
</ol>
<p>​		HashMap 中元素的迭代顺序是不确定的，可能会受到哈希冲突、扩容等因素的影响。如果需要按照特定顺序迭代 HashMap 中的元素，可以考虑使用 LinkedHashMap。</p>
<h3 id="222-hashmap-和-hashtable-的区别">
  2.22 HashMap 和 Hashtable 的区别
  <a href="#222-hashmap-%e5%92%8c-hashtable-%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>HashMap 和 Hashtable 是 Java 中常用的两个哈希表实现，它们在实现上有以下几个区别：</p>
<ol>
<li>线程安全性</li>
</ol>
<p>​		Hashtable 是线程安全的，即多个线程可以同时访问 Hashtable 对象而不会发生数据不一致的情况。它的线程安全是通过在每个方法上加上 synchronized 关键字实现的。而 HashMap 是非线程安全的，如果多个线程同时对 HashMap 进行修改，则可能会发生数据不一致的情况。</p>
<ol start="2">
<li>null 值</li>
</ol>
<p>​		Hashtable 不允许键或值为 null，否则会抛出 NullPointerException 异常。而 HashMap 允许键或值为 null，因为它们都有专门的处理机制。</p>
<ol start="3">
<li>初始容量和自动扩容</li>
</ol>
<p>​		Hashtable 的初始容量为11，负载因子为0.75，当元素个数超过容量与负载因子的乘积时，Hashtable 会自动扩容。而 HashMap 的初始容量为16，负载因子为0.75，当元素个数超过容量与负载因子的乘积时，HashMap 会自动扩容。</p>
<ol start="4">
<li>迭代顺序</li>
</ol>
<p>​		Hashtable 中元素的迭代顺序是不确定的，可能会受到哈希冲突、扩容等因素的影响。而 HashMap 中元素的迭代顺序也是不确定的，但是它提供了一种可以控制元素迭代顺序的方式，即 LinkedHashMap。</p>
<p>​		总的来说，HashMap 比 Hashtable 更常用，因为 HashMap 不仅性能更高，而且允许键和值为 null，而且不需要额外的同步开销。但是如果需要保证线程安全，可以考虑使用 ConcurrentHashMap 等线程安全的 HashMap 替代。</p>
<h3 id="223-hashmap-的长度为什么是-2-的幂次方">
  2.23 HashMap 的长度为什么是 2 的幂次方
  <a href="#223-hashmap-%e7%9a%84%e9%95%bf%e5%ba%a6%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af-2-%e7%9a%84%e5%b9%82%e6%ac%a1%e6%96%b9" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		HashMap 的长度为什么是 2 的幂次方，主要是因为在 HashMap 的内部实现中，需要使用到取模运算（%）来计算元素在哈希表中的位置，而计算模运算的操作成本较高。而如果哈希表的长度是 2 的幂次方，则可以用位运算（&amp;）与来代替取模运算，进一步提高计算效率。</p>
<p>​		具体来说，HashMap 中将一个键值对映射到哈希表中的位置，是通过先将键的 hashCode() 方法计算得到哈希码，然后再对哈希码进行某些操作，最终得到键值对在哈希表中的位置。如果哈希表的长度是 2 的幂次方，那么对哈希码取模运算的结果就等于对哈希表的长度 -1 进行位运算（&amp;）与的结果，即 hash &amp;  (length-1)。这样可以避免使用取模运算，提高了计算效率。</p>
<p>​		因此，为了提高 HashMap 的性能，其长度应该尽量选取 2 的幂次方。例如，如果哈希表的长度为 16，那么 length-1 的二进制表示为1111，也就是低 4 位都是 1，这时候使用 hash &amp; 15，就等价于对哈希码取模 16 的操作，但是位运算的速度要比取模运算快得多。</p>
<h3 id="224-hashmap-多线程操作导致死循环问题">
  2.24 HashMap 多线程操作导致死循环问题
  <a href="#224-hashmap-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%93%8d%e4%bd%9c%e5%af%bc%e8%87%b4%e6%ad%bb%e5%be%aa%e7%8e%af%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		HashMap 是非线程安全的数据结构，如果在多线程环境下对 HashMap 进行修改操作，可能会导致数据结构的破坏，甚至进入死循环。</p>
<p>​		这个问题主要是由于在多线程环境下，当多个线程同时访问 HashMap 时，如果一个线程在进行修改操作时改变了 HashMap 的结构，而另一个线程正在遍历 HashMap，这时候就有可能导致遍历线程进入死循环，因为它期望下一个节点的位置已经确定，但是实际上已经被修改了。</p>
<p>​		例如，假设线程 A 正在遍历 HashMap，它已经访问到节点 A，而此时线程 B 在修改 HashMap，将节点 B 插入到节点 A 之前，这时候线程 A 的下一个节点应该是节点 B，但是由于 HashMap 的结构已经发生了变化，节点 A 的 next 指针可能已经被修改，线程 A 就会陷入死循环。</p>
<p>为了避免这个问题，可以采用以下两种方法：</p>
<ol>
<li>
<p>使用线程安全的 Map，例如 ConcurrentHashMap。</p>
</li>
<li>
<p>在多线程环境下使用 HashMap 时，需要使用<strong>同步机制</strong>来确保线程安全。可以使用 synchronized 关键字或者 ConcurrentHashMap 等线程安全的 Map 来解决这个问题。</p>
</li>
</ol>
<h3 id="225-concurrenthashmap-和-hashtable-的区别">
  2.25 ConcurrentHashMap 和 Hashtable 的区别
  <a href="#225-concurrenthashmap-%e5%92%8c-hashtable-%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>ConcurrentHashMap 和 Hashtable 都是线程安全的 Map，它们之间的区别如下：</p>
<ol>
<li>同步策略不同：ConcurrentHashMap 使用了<strong>锁分段</strong>技术来提高并发访问性能，即将整个 Map 分为多个 Segment，每个 Segment 维护着一个 Hash 表，多个线程可以同时访问不同 Segment 的数据，从而提高并发访问性能；而 Hashtable 则使用了 Synchronized关键字对整个 Map 进行同步。</li>
<li>迭代器不同：ConcurrentHashMap 的迭代器是<strong>弱一致性</strong>的，即在迭代过程中，如果其他线程修改了 Map 中的内容，不一定会立即反映在迭代器的遍历结果中；而 Hashtable 的迭代器是<strong>强一致性</strong>的，即在迭代过程中，如果其他线程修改了 Map 中的内容，迭代器会立即抛出 ConcurrentModificationException 异常。</li>
<li>null 值处理不同：ConcurrentHashMap 允许 key 和 value 都为 null，而 Hashtable 不允许 key 和 value 为 null。</li>
<li>性能不同：ConcurrentHashMap 的并发性能比 Hashtable 要好，因为它使用了锁分段技术，可以同时支持多个线程的并发操作，而Hashtable 在并发访问时需要通过 Synchronized 关键字对整个 Map 进行同步，因此并发性能较差。</li>
</ol>
<p>​		因此，在多线程环境下，如果需要高效地进行并发访问，建议使用 ConcurrentHashMap，如果是单线程环境或者需要强一致性的迭代器，则可以使用 Hashtable。</p>
<h3 id="226-hashmap-和-concurrenthashmap-的区别">
  2.26 HashMap 和 ConcurrentHashMap 的区别
  <a href="#226-hashmap-%e5%92%8c-concurrenthashmap-%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		HashMap 和 ConcurrentHashMap 都是 Java 中的哈希表实现，都可以用于存储键值对。它们之间的主要区别在于线程安全性和并发性能。</p>
<p>​		HashMap 是<strong>非线程安全</strong>的，如果多个线程同时进行写操作可能会出现数据不一致的情况。HashMap 的底层数据结构是数组和链表，它使用哈希算法来将键映射到数组索引上，然后将值存储在链表中。当发生哈希冲突时，即多个键被映射到同一个索引上时，HashMap 会在链表的头部插入新的键值对，形成一个链表。</p>
<p>​		ConcurrentHashMap 是<strong>线程安全</strong>的哈希表实现，它通过分段锁（Segment）的方式实现了更好的并发性能。它将整个哈希表分成了多个段（Segment），每个段维护了一个独立的哈希表。每个段可以被不同的线程访问，从而实现了更高的并发性能。当一个线程访问一个段时，只有这个段被锁定，其他段不受影响。这样，在并发访问时，只需要锁定访问的那个段，其他段仍然可以被其他线程访问，大大提高了并发性能。</p>
<p>​		在使用 HashMap 时，需要注意线程安全性问题，可以通过使用 Collections.synchronizedMap() 方法将 HashMap 转换为线程安全的。而 ConcurrentHashMap 在并发访问时可以获得更好的性能表现，因此是并发场景下的首选。</p>
<h3 id="227-concurrenthashmap-线程安全的具体实现方式底层具体实现">
  2.27 ConcurrentHashMap 线程安全的具体实现方式/底层具体实现
  <a href="#227-concurrenthashmap-%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f%e5%ba%95%e5%b1%82%e5%85%b7%e4%bd%93%e5%ae%9e%e7%8e%b0" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		ConcurrentHashMap 是通过将整个 Map 分为多个 Segment 来实现线程安全的。每个 Segment 维护着一个 Hash 表，多个线程可以同时访问不同 Segment 的数据，从而提高并发访问性能。</p>
<p>​		在 Java 7 及之前的版本中，ConcurrentHashMap 中的 Segment 是通过 ReentrantLock 实现的，即每个 Segment 维护着一个独立的ReentrantLock 对象。在 Java 8 及之后的版本中，ConcurrentHashMap 改为了使用 synchronized 关键字来实现 Segment 的同步，即每个 Segment 使用 synchronized 关键字来保证线程安全。</p>
<p>​		在 ConcurrentHashMap 中，put、get 等操作都是先定位到对应的 Segment，然后再在该 Segment 中进行操作。因此，ConcurrentHashMap 的并发性能取决于 Segment 的数量，通常情况下，Segment 的数量与处理器核心数相等时，可以取得最佳性能。</p>
<p>​		ConcurrentHashMap 在 Java 中是一个非常常用的线程安全的 Map 实现，它具有较好的并发性能和扩展性。</p>
<h3 id="228-hashmap-的-put-方法的具体流程">
  2.28 HashMap 的 put 方法的具体流程
  <a href="#228-hashmap-%e7%9a%84-put-%e6%96%b9%e6%b3%95%e7%9a%84%e5%85%b7%e4%bd%93%e6%b5%81%e7%a8%8b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>HashMap 的 put 方法是向 HashMap 中添加元素的方法，其大致流程如下：</p>
<ol>
<li>判断 HashMap 是否已经初始化，如果没有则进行初始化操作；</li>
<li>计算插入元素的哈希值，根据哈希值定位元素应该存放的桶；</li>
<li>如果桶中没有元素，则直接插入元素并返回 null；</li>
<li>如果桶中已经有元素，则遍历链表（或红黑树）找到相同 key 的元素，如果找到则替换 value 并返回旧 value，如果没找到则在链表（或红黑树）的尾部添加新的节点，并判断链表（或红黑树）的长度是否达到阈值，如果达到则将链表（或红黑树）转换为红黑树；</li>
<li>插入元素后判断是否需要扩容，如果需要则进行扩容操作。</li>
</ol>
<p>​		在多线程环境下，当多个线程同时向 HashMap 中添加元素时，可能会发生链表成环、数据覆盖等问题，因此需要对 HashMap 进行加锁或使用线程安全的 ConcurrentHashMap。</p>
<h3 id="229-hashmap-的扩容操作是怎么实现的">
  2.29 HashMap 的扩容操作是怎么实现的
  <a href="#229-hashmap-%e7%9a%84%e6%89%a9%e5%ae%b9%e6%93%8d%e4%bd%9c%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		HashMap 在添加元素时，会检查当前容量是否足够，如果不足则需要进行扩容操作，即将容量翻倍。</p>
<p>扩容过程主要包括以下几个步骤：</p>
<ol>
<li>创建一个新的 Entry 数组，长度是原数组的两倍；</li>
<li>将原数组中的元素重新计算 hash 后插入到新数组中；</li>
<li>如果新数组中的某个位置已经有元素了，则将该元素放到链表的末尾；</li>
<li>将新数组的引用赋值给原数组。</li>
</ol>
<p>​		在上述过程中，需要重新计算 hash 值，这是因为扩容后，数组的长度发生了变化，元素的 hash 值也会随之发生变化。</p>
<p>​		需要注意的是，当数组中的元素比较多时，扩容操作会比较耗时，因此在使用 HashMap 时，最好预估需要存储的元素数量，初始化时就将容量设置得足够大，避免扩容的发生。同时，如果需要使用 HashMap 的并发版本，可以考虑使用 ConcurrentHashMap，它可以在多线程环境下高效地进行并发操作，而且不需要进行全局的锁定。</p>
<h3 id="230-什么是哈希什么是哈希冲突hashmap-是怎么解决哈希冲突的">
  2.30 什么是哈希，什么是哈希冲突，HashMap 是怎么解决哈希冲突的
  <a href="#230-%e4%bb%80%e4%b9%88%e6%98%af%e5%93%88%e5%b8%8c%e4%bb%80%e4%b9%88%e6%98%af%e5%93%88%e5%b8%8c%e5%86%b2%e7%aa%81hashmap-%e6%98%af%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3%e5%93%88%e5%b8%8c%e5%86%b2%e7%aa%81%e7%9a%84" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		哈希（Hash）是将任意长度的输入通过哈希算法，变换成固定长度的输出，通常是一个固定长度的字符串。哈希冲突指不同的输入值，通过哈希算法得到相同的输出值。哈希冲突是哈希算法的一个普遍问题。</p>
<p>​		HashMap 采用的是拉链法（Chaining）解决哈希冲突。在拉链法中，每个桶（bucket）都对应一个链表（LinkedList），所有哈希值相同的元素都放到对应链表中。当新元素添加进来时，会计算出它的哈希值并定位到相应的桶，然后将新元素插入到链表的头部。</p>
<p>​		如果不同的键值对的哈希值相同，就会插入到同一个桶的链表中。为了提高查找效率，链表的长度过长时，就需要将链表转换为红黑树。这样可以避免链表查找的效率过低的问题。当红黑树节点数太少时，会将红黑树重新转换为链表。</p>
<p>​		在添加元素时，如果元素数量大于容量（threshold），就需要对 HashMap 进行扩容操作，重新分配更大的空间。具体实现时，HashMap 会将容量扩大为原来的两倍，并将所有元素重新分配到新的桶中。由于重新分配桶的过程需要重新计算所有元素的哈希值，所以扩容操作比较耗费时间，因此需要尽量避免发生扩容操作。</p>
<h3 id="231-hashmap-的数据结构">
  2.31 HashMap 的数据结构
  <a href="#231-hashmap-%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		HashMap 是一种散列表实现的 Map，它基于哈希表（Hash Table）实现，其中键（Key）和值（Value）都可以为null。它通过计算每个元素的键的哈希码（hash code），并将这些键值对存储在一个数组中。哈希码将作为数组索引，通过哈希函数（hash function）将哈希码映射到数组的索引位置，该位置称为哈希表槽（bucket）。</p>
<p>​		HashMap 中每个节点（Node）包含键、值、哈希码和指向下一个节点的指针。如果两个或多个键的哈希码相同，那么它们会被分配到同一个槽位，这种情况被称为哈希冲突（hash collision）。当发生哈希冲突时，HashMap 使用链表（linked list）来存储具有相同哈希码的元素，新元素将被插入链表的头部。</p>
<p>​		在 JDK 1.8 之前，当链表的长度达到一个阈值（默认为8），链表将被转换为红黑树。当节点数量减少到一个较小的阈值时（默认为6），树将被转换回链表。这个过程被称为树化（treeify）和反树化（untreeify）。这种优化使得在具有大量哈希冲突的情况下，HashMap 的性能更加稳定。在 JDK 1.8 之后，当链表长度超过一定阈值（默认为8），链表和树化结构将同时存在。这个阈值可以通过修改 loadFactor 参数进行调整。</p>
<h3 id="232-什么是-treemap如何决定使用-hashmap-还是-treemap">
  2.32 什么是 TreeMap，如何决定使用 HashMap 还是 TreeMap
  <a href="#232-%e4%bb%80%e4%b9%88%e6%98%af-treemap%e5%a6%82%e4%bd%95%e5%86%b3%e5%ae%9a%e4%bd%bf%e7%94%a8-hashmap-%e8%bf%98%e6%98%af-treemap" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		TreeMap 是基于红黑树实现的一种有序的 Map 接口的实现类。TreeMap 内部使用红黑树来维护元素的顺序，可以保证 key 的有序性，因此 TreeMap 适合于需要对元素按照 key 进行排序的场景。</p>
<p>​		相对地，HashMap 是一种散列表的实现，无法保证元素的顺序，但是插入和查询的时间复杂度是常数级别的，因此 HashMap 适合于插入和查询操作比较频繁，对元素的顺序不敏感的场景。</p>
<p>​		因此，在选择使用 HashMap 还是 TreeMap 时，需要考虑到具体的业务场景，如果需要对元素进行排序，则可以选择 TreeMap，如果不需要排序，则可以选择 HashMap。</p>
<h3 id="233-comparable-和-comparator-的区别">
  2.33 Comparable 和 Comparator 的区别
  <a href="#233-comparable-%e5%92%8c-comparator-%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Java 中，<code>Comparable</code> 和 <code>Comparator</code> 都是用于对象比较排序的接口。它们的区别如下：</p>
<ol>
<li><code>Comparable</code> 是内部比较器，是在类内部实现，要求被比较的类实现 <code>Comparable</code> 接口并重写 <code>compareTo()</code> 方法。通过实现 <code>compareTo()</code> 方法来指定对象之间的比较方式。这种方式的排序只能有一种。</li>
<li><code>Comparator</code> 是外部比较器，是在类外部实现，需要定义一个独立的比较器类，通过实现 <code>Comparator</code> 接口并重写 <code>compare()</code> 方法来指定对象之间的比较方式。这种方式的排序可以有多种。</li>
</ol>
<p>​		一般来说，如果一个类已经实现了 <code>Comparable</code> 接口，并且这个比较方式适用于大多数情况下的排序，那么应该使用 <code>Comparable</code> 接口进行排序。如果需要在不同的情况下采用不同的排序方式，或者需要为已经存在的类增加新的排序方式，就应该使用 <code>Comparator</code> 接口。</p>
<h3 id="234--collection-和-collections-有什么区别">
  2.34  Collection 和 Collections 有什么区别
  <a href="#234--collection-%e5%92%8c-collections-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Collection 和 Collections 是 Java 集合框架中的两个不同概念。</p>
<p>​		Collection 是一个接口，表示一组对象，这些对象被称为元素。Collection 接口提供了一组操作元素的方法，包括添加、删除、遍历等。</p>
<p>​		Collections 是一个工具类，提供了一组静态方法，用于操作集合类。例如，Collections.sort() 方法用于对 List 集合进行排序，Collections.binarySearch() 方法用于在 List 集合中进行二分查找。</p>
<p>​		总体来说，Collection 是一个接口，定义了一组操作集合元素的方法，而 Collections 是一个工具类，提供了一组静态方法，用于操作集合类。</p>
<h3 id="235-treemap-和-treeset-在排序时如何比较元素collections-工具类中的-sort-方法如何比较元素">
  2.35 TreeMap 和 TreeSet 在排序时如何比较元素，Collections 工具类中的 sort() 方法如何比较元素
  <a href="#235-treemap-%e5%92%8c-treeset-%e5%9c%a8%e6%8e%92%e5%ba%8f%e6%97%b6%e5%a6%82%e4%bd%95%e6%af%94%e8%be%83%e5%85%83%e7%b4%a0collections-%e5%b7%a5%e5%85%b7%e7%b1%bb%e4%b8%ad%e7%9a%84-sort-%e6%96%b9%e6%b3%95%e5%a6%82%e4%bd%95%e6%af%94%e8%be%83%e5%85%83%e7%b4%a0" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		TreeMap 和 TreeSet 通过比较元素的大小来进行排序。在创建 TreeMap 和 TreeSet 对象时，可以传入一个实现了 Comparable 接口的类对象或一个实现了 Comparator 接口的类对象，这个对象的比较方法将被用于元素之间的比较和排序。</p>
<p>​		Collections 工具类中的 sort() 方法也是通过比较元素的大小来进行排序。sort() 方法有两种重载形式，一种是不传入比较器对象，此时被排序的元素必须实现 Comparable 接口；另一种是传入一个比较器对象，此时将使用该比较器对象的比较方法来进行排序。在比较元素大小时，sort() 方法将使用被排序元素的 compareTo() 方法或者比较器对象的 compare() 方法。</p>
<h3 id="236-什么是红黑树">
  2.36 什么是红黑树
  <a href="#236-%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%a2%e9%bb%91%e6%a0%91" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		红黑树（Red-Black Tree）是一种自平衡二叉查找树，每个节点上都有一个额外的存储位记录该节点的颜色，可以是红色或黑色。通过对任何一条从根到叶子节点的简单路径上各个节点的颜色进行约束，红黑树保证了没有一条路径会比其他路径长出俩倍，因而是近似于平衡的。</p>
<p>具体来说，红黑树需要满足以下五个性质：</p>
<ol>
<li>每个节点要么是红色，要么是黑色；</li>
<li>根节点必须是黑色；</li>
<li>每个叶子节点（NIL节点，空节点）是黑色的；</li>
<li>如果一个节点是红色的，则它的两个子节点必须都是黑色的；</li>
<li>对于任意一个节点而言，其左右子树必须保持黑色节点的平衡，即黑色节点的数量相等。</li>
</ol>
<p>​		红黑树可以实现高效的查找、插入、删除等操作，并且具有比平衡二叉树更加简单的实现。在 Java 中，HashMap 的实现就是基于红黑树和链表两种数据结构的组合实现。</p>
<h1 id="第3章-多线程与并发">
  第3章 多线程与并发
  <a href="#%e7%ac%ac3%e7%ab%a0-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e4%b8%8e%e5%b9%b6%e5%8f%91" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="31-线程和进程的区别是什么">
  3.1 线程和进程的区别是什么
  <a href="#31-%e7%ba%bf%e7%a8%8b%e5%92%8c%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>线程和进程是操作系统中的两个基本概念，它们之间的区别如下：</p>
<ol>
<li>资源分配：进程是资源分配的最小单位，线程是CPU调度的最小单位。进程包含代码、数据和堆栈等资源，而线程则共享进程的资源。一个进程内可以包含多个线程。</li>
<li>并发性：进程之间是相互独立的，而线程之间是相互依存的。在一个进程内部，多个线程可以并发执行，共享同一进程的地址空间和其他资源。</li>
<li>调度：进程之间是互相独立的，由操作系统负责进程的调度，而线程之间是相互依存的，由进程内的线程调度器负责调度。</li>
<li>开销：进程的创建和销毁需要操作系统进行一系列的操作，而线程的创建和销毁则相对较快，因为它们共享进程的资源。</li>
<li>通信：不同的进程之间通信需要通过进程间通信的方式，如管道、共享内存、消息队列等，而同一进程内的线程之间可以直接共享数据。</li>
<li>安全性：线程之间共享数据，需要进行同步和互斥，而进程之间是相互独立的，不会相互干扰，因此线程的安全性相对较低。</li>
</ol>
<p>​		总之，进程和线程都是计算机系统中的基本概念，各有其特点和用途。在编程中，需要根据实际需求选择适当的方式进行处理。</p>
<h3 id="32-java-实现线程有哪几种方式">
  3.2 Java 实现线程有哪几种方式
  <a href="#32-java-%e5%ae%9e%e7%8e%b0%e7%ba%bf%e7%a8%8b%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e6%96%b9%e5%bc%8f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Java 实现线程的方式有以下几种：</p>
<ol>
<li>继承 Thread 类：通过继承 Thread 类并重写 run() 方法实现多线程。</li>
<li>实现 Runnable 接口：通过实现 Runnable 接口并重写 run() 方法实现多线程，无返回值，不能抛出异常。</li>
<li>实现 Callable 接口：Callable 接口的 call() 方法可以返回结果，可以抛出异常，需要 FutureTask 类或线程池的支持。</li>
<li>使用线程池：线程池是一个线程队列，可以复用已经创建的线程，减少线程的创建和销毁带来的开销。</li>
<li>使用 Executor 框架：Executor 框架是一个强大的框架，可以灵活地管理线程，同时提供了多种线程池的实现。</li>
<li>使用 Java 8 中的 Lambda 表达式：Lambda 表达式可以简化线程的创建，可以避免使用匿名内部类。</li>
</ol>
<p>​		以上方式都可以实现多线程，但在不同的场景下，选择不同的方式可以更好地满足需求。</p>
<h3 id="33-启动线程方法-start-和-run-有什么区别">
  3.3 启动线程方法 start() 和 run() 有什么区别
  <a href="#33-%e5%90%af%e5%8a%a8%e7%ba%bf%e7%a8%8b%e6%96%b9%e6%b3%95-start-%e5%92%8c-run-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Java 中，有两种方式来启动一个线程：一种是继承 <code>Thread</code> 类并重写 <code>run()</code> 方法，另一种是实现 <code>Runnable</code> 接口并重写 <code>run()</code> 方法。无论哪种方式，都需要在某个地方调用 <code>start()</code> 方法来启动线程。</p>
<p>​		<code>start()</code> 方法会启动一个新的线程，并在新线程中执行 <code>run()</code> 方法。而直接调用 <code>run()</code> 方法不会创建一个新线程，而只是在当前线程中调用 <code>run()</code> 方法。</p>
<p>例如，使用 <code>Thread</code> 类的方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Thread thread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 线程运行的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">};</span>
</span></span><span style="display:flex;"><span>thread<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span> <span style="color:#75715e">// 启动新线程
</span></span></span></code></pre></div><p>使用 <code>Runnable</code> 接口的方式：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Runnable runnable <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 线程运行的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">};</span>
</span></span><span style="display:flex;"><span>Thread thread <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(</span>runnable<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>thread<span style="color:#f92672">.</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span> <span style="color:#75715e">// 启动新线程
</span></span></span></code></pre></div><p>​		从上面的例子可以看出，无论是哪种方式，都需要在某个地方调用 <code>start()</code> 方法来启动线程。而直接调用 <code>run()</code> 方法只是普通的方法调用，不会启动新的线程。</p>
<h3 id="34-怎么终止一个线程">
  3.4 怎么终止一个线程
  <a href="#34-%e6%80%8e%e4%b9%88%e7%bb%88%e6%ad%a2%e4%b8%80%e4%b8%aa%e7%ba%bf%e7%a8%8b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Java 中，可以使用以下方法终止一个线程：</p>
<ol>
<li>使用标志变量控制线程执行。在线程执行的过程中，检查某个标志变量的值是否为终止线程的指令，如果是，则退出线程的执行。这种方法需要在线程执行的过程中周期性地检查标志变量的值，可以使用 <code>volatile</code> 关键字确保多线程之间的可见性。</li>
<li>使用 <code>Thread.stop()</code> 方法强制终止线程。然而，这种方法已经被废弃，因为它可能导致线程没有来得及执行清理操作就被终止，引发一些不可预知的问题。</li>
<li>使用 <code>Thread.interrupt()</code> 方法中断线程。这种方法不会立即终止线程，而是给线程发送中断信号，如果线程在等待 I/O、sleep() 或 join() 等操作时被中断，会抛出一个 <code>InterruptedException</code> 异常，从而中断线程执行。在线程中需要使用 <code>Thread.currentThread().isInterrupted()</code> 方法来检查中断标志位，并根据标志位的值决定是否终止线程。</li>
</ol>
<p>​		总之，线程的终止应该是一种协作式的操作，线程应该在执行过程中检查中断标志位并做出响应，而不是通过强制终止的方式结束线程的执行。</p>
<h3 id="35-一个线程的生命周期有哪几种状态它们之间如何流转的">
  3.5 一个线程的生命周期有哪几种状态，它们之间如何流转的
  <a href="#35-%e4%b8%80%e4%b8%aa%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e7%8a%b6%e6%80%81%e5%ae%83%e4%bb%ac%e4%b9%8b%e9%97%b4%e5%a6%82%e4%bd%95%e6%b5%81%e8%bd%ac%e7%9a%84" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>一个线程的生命周期通常有以下几种状态：</p>
<ol>
<li>新建状态（New）：当线程对象被创建时，它处于新建状态，此时它只是一个空壳，没有被系统分配到任何资源。</li>
<li>就绪状态（Runnable）：当线程调用了 <code>start()</code> 方法之后，进入就绪状态，等待系统为其分配资源（CPU 时间片）。</li>
<li>运行状态（Running）：当系统分配到时间片后，线程进入运行状态，开始执行 <code>run()</code> 方法中的任务。</li>
<li>阻塞状态（Blocked）：线程执行时可能会发生阻塞，比如等待 IO 完成、等待其他线程完成等。在这种情况下，线程会进入阻塞状态，等待某个条件满足。</li>
<li>等待状态（Waiting）：线程在调用 <code>wait()</code>、<code>join()</code> 等方法时，会进入等待状态，等待其他线程发出通知，以便恢复到就绪状态。</li>
<li>计时等待状态（Timed Waiting）：线程在调用 <code>sleep()</code>、<code>wait(long)</code> 等方法时，会进入计时等待状态，即等待一定时间后自动恢复到就绪状态。</li>
<li>终止状态（Terminated）：线程执行完任务或者出现异常时，会进入终止状态，此时线程被销毁，释放所有资源。</li>
</ol>
<p>线程状态之间的转换如下：</p>
<ol>
<li>新建状态（New） -&gt; 就绪状态（Runnable）</li>
<li>就绪状态（Runnable） -&gt; 运行状态（Running）</li>
<li>运行状态（Running） -&gt; 就绪状态（Runnable）</li>
<li>运行状态（Running） -&gt; 阻塞状态（Blocked）</li>
<li>阻塞状态（Blocked） -&gt; 就绪状态（Runnable）</li>
<li>运行状态（Running） -&gt; 等待状态（Waiting）</li>
<li>等待状态（Waiting） -&gt; 就绪状态（Runnable）</li>
<li>运行状态（Running） -&gt; 计时等待状态（Timed Waiting）</li>
<li>计时等待状态（Timed Waiting） -&gt; 就绪状态（Runnable）</li>
<li>运行状态（Running） -&gt; 终止状态（Terminated）</li>
</ol>
<h3 id="36-线程中的-wait-和-sleep-方法有什么区别notify-和-notifyall-方法的区别">
  3.6 线程中的 wait() 和 sleep() 方法有什么区别，notify() 和 notifyAll() 方法的区别
  <a href="#36-%e7%ba%bf%e7%a8%8b%e4%b8%ad%e7%9a%84-wait-%e5%92%8c-sleep-%e6%96%b9%e6%b3%95%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%abnotify-%e5%92%8c-notifyall-%e6%96%b9%e6%b3%95%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		wait() 和 sleep() 方法都可以让线程等待一段时间，但是它们的作用不同。</p>
<p>​		wait() 方法属于 Object 类，需要在 synchronized 块或方法中调用。当线程执行 wait() 方法时，它会释放锁并进入等待状态，等待其他线程调用 notify() 或 notifyAll() 方法唤醒。wait() 方法还可以带一个参数，表示等待的最长时间，在这个时间内如果没有其他线程调用 notify() 或 notifyAll() 方法，线程也会被唤醒。</p>
<p>​		sleep() 方法属于 Thread 类，可以在任何地方调用。当线程执行 sleep() 方法时，它会休眠指定时间，并不会释放锁，也不会被其他线程唤醒。sleep() 方法也可以带一个参数，表示休眠的时间。</p>
<p>​		因此，wait() 方法是在同步块中让线程等待并释放锁，sleep() 方法是在任何地方让线程休眠并不释放锁。另外，wait() 方法需要其他线程唤醒，而 sleep() 方法不需要。</p>
<p>​		<code>notify()</code> 和 <code>notifyAll()</code> 都是 <code>Object</code> 类中定义的方法，用于唤醒正在等待该对象锁的线程，使其从等待队列进入可运行状态。两者的区别在于：</p>
<ol>
<li><code>notify()</code> 方法只会随机唤醒等待队列中的一个线程，而 <code>notifyAll()</code> 方法会唤醒等待队列中的所有线程。</li>
<li><code>notify()</code> 方法只有一个线程能够获取锁并继续执行，而其他等待线程仍然需要等待，而 <code>notifyAll()</code> 方法则可以唤醒所有等待线程，让它们去竞争锁。</li>
</ol>
<p>​		通常情况下，如果多个线程需要等待同一个条件，并且在条件满足时需要同时执行，可以使用 <code>notifyAll()</code> 方法。如果只有一个线程需要等待条件并且其他线程不需要知道条件是否已经满足，则可以使用 <code>notify()</code> 方法。</p>
<h3 id="37-多线程同步有哪几种方法">
  3.7 多线程同步有哪几种方法
  <a href="#37-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e6%96%b9%e6%b3%95" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Java 中，有以下几种方式可以实现多线程同步：</p>
<ol>
<li>synchronized：使用 synchronized 关键字可以让代码块或方法变为同步代码块或同步方法，从而实现线程同步。synchronized 可以保证线程安全，但是由于锁的粒度较大，可能会导致性能问题。</li>
<li>Lock：Java 提供了 Lock 接口和 ReentrantLock 类，可以使用 lock() 方法和 unlock() 方法来实现线程同步。相较于 synchronized，Lock 提供了更细粒度的锁控制，但是使用 Lock 时需要手动管理锁的获取和释放，需要更多的代码量。</li>
<li>volatile：使用 volatile 关键字可以保证共享变量在多个线程之间的可见性，从而实现线程同步。volatile 可以用来修饰共享变量，但是不能保证原子性。</li>
<li>Atomic：Java 中提供了一些原子类，如 AtomicInteger、AtomicLong、AtomicBoolean 等，这些类可以实现原子操作，从而实现线程同步。</li>
<li>CountDownLatch：Java 提供了 CountDownLatch 类，可以使用它来实现线程同步，例如等待多个线程都执行完毕后再执行某个操作。</li>
<li>CyclicBarrier：Java 提供了 CyclicBarrier 类，可以使用它来实现线程同步，例如等待多个线程都执行完毕后再一起执行某个操作。</li>
<li>Semaphore：Java 提供了 Semaphore 类，可以使用它来实现线程同步，例如限制线程的数量。</li>
</ol>
<p>​		这些方法各有优缺点，具体使用时需要根据具体情况进行选择。</p>
<h3 id="38-多线程之间如何进行通信线程怎样拿到返回结果">
  3.8 多线程之间如何进行通信，线程怎样拿到返回结果
  <a href="#38-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e4%b9%8b%e9%97%b4%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e9%80%9a%e4%bf%a1%e7%ba%bf%e7%a8%8b%e6%80%8e%e6%a0%b7%e6%8b%bf%e5%88%b0%e8%bf%94%e5%9b%9e%e7%bb%93%e6%9e%9c" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		多线程之间可以通过共享变量进行通信，例如使用 synchronized 关键字保证多个线程访问共享变量的互斥性，或者使用 Lock、Semaphore、CountDownLatch 等工具类进行同步控制。</p>
<p>​		如果需要拿到线程的返回结果，可以使用 Callable 接口定义任务并返回执行结果，然后通过 FutureTask 包装 Callable 对象，再将 FutureTask 对象传入线程的构造方法中，最后使用 FutureTask 的 get() 方法获取执行结果。或者可以使用 CountDownLatch 等同步工具类进行线程的同步等待和结果获取。</p>
<h3 id="39-volatile-关键字的作用">
  3.9 volatile 关键字的作用
  <a href="#39-volatile-%e5%85%b3%e9%94%ae%e5%ad%97%e7%9a%84%e4%bd%9c%e7%94%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Java 中，volatile 关键字可以用于修饰变量。它的作用是使得被修饰的变量在多线程环境中的读取和修改操作具有可见性，并且禁止了指令重排序优化。</p>
<p>​		具体来说，当一个线程修改了被 volatile 关键字修饰的变量时，这个变量的修改将立即被刷入主存，而不是仅仅是线程内部的工作内存，这样其他线程就可以立即看到该变量的修改。同时，volatile 也可以防止 JVM 对代码的重排序优化，保证指令执行的顺序不会被改变，从而保证多线程的正确性。</p>
<p>​		需要注意的是，虽然 volatile 可以保证可见性和顺序性，但是它并不能保证原子性。在多线程并发修改同一个变量时，如果要保证原子性，需要使用其他的同步手段，比如 synchronized 或者 Lock。</p>
<h3 id="310-什么是活锁饥饿无锁死锁如何避免死锁">
  3.10 什么是活锁、饥饿、无锁、死锁，如何避免死锁
  <a href="#310-%e4%bb%80%e4%b9%88%e6%98%af%e6%b4%bb%e9%94%81%e9%a5%a5%e9%a5%bf%e6%97%a0%e9%94%81%e6%ad%bb%e9%94%81%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d%e6%ad%bb%e9%94%81" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		活锁（livelock）：是指线程虽然没有被阻塞，但是它们都在忙于响应对方的动作，却没有任何一个线程能够进展。它们不断重复相同的操作，但是却一直无法推进。</p>
<p>​		饥饿（starvation）：是指某些线程由于始终得不到所需要的资源而无法执行。例如，如果一个线程在运行时需要访问一个共享资源，但是其他线程占用了该资源并且一直不释放，那么该线程将一直被阻塞，无法执行。</p>
<p>​		无锁（lock-free）：是指线程在访问共享资源时不会被阻塞。在多线程并发访问时，无锁的算法通常会使用 CAS（Compare And Swap）等机制来保证原子性和一致性，从而避免了死锁和饥饿的问题。</p>
<p>​		死锁（deadlock）：是指两个或多个线程互相持有对方所需的资源，导致它们都无法继续执行。如果不解决死锁，那么这些线程将一直阻塞，导致程序无法继续运行。</p>
<p>为了避免死锁，可以采用以下方法：</p>
<ol>
<li>避免一个线程同时获取多个锁。</li>
<li>避免一个线程在锁内部占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用 lock.tryLock(timeout) 来替代使用内部锁机制。</li>
<li>对于数据库锁等资源，尽量使用带超时参数的方法。</li>
<li>对于一些可以通过资源剥离来避免死锁的情况，可以考虑使用资源剥离。</li>
</ol>
<h3 id="311-什么是乐观锁和悲观锁">
  3.11 什么是乐观锁和悲观锁
  <a href="#311-%e4%bb%80%e4%b9%88%e6%98%af%e4%b9%90%e8%a7%82%e9%94%81%e5%92%8c%e6%82%b2%e8%a7%82%e9%94%81" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		乐观锁和悲观锁是两种不同的并发控制策略。</p>
<p>​		悲观锁是一种悲观的、保守的并发控制策略，认为在并发情况下，总是会有冲突发生，因此在进行任何操作前，都会先将资源锁定，以防止其他线程对资源的操作。常见的悲观锁有 synchronized 和 ReentrantLock。</p>
<p>​		乐观锁是一种乐观的并发控制策略，认为并发冲突的概率很小，因此不需要锁定资源，而是在更新时判断数据是否被其他线程修改。如果没有被修改，则直接更新；否则，进行重试或回滚操作。常见的乐观锁有 CAS（Compare And Swap）和版本号控制等。</p>
<p>​		在实际应用中，悲观锁适用于对数据更新操作较多的场景，如数据的增删改操作；而乐观锁适用于数据读取操作较多的场景，如数据的查询操作。同时，悲观锁需要频繁地进行锁定和释放，可能会导致性能下降和死锁等问题，因此需要谨慎使用。</p>
<h3 id="312-什么是原子性可见性有序性">
  3.12 什么是原子性、可见性、有序性
  <a href="#312-%e4%bb%80%e4%b9%88%e6%98%af%e5%8e%9f%e5%ad%90%e6%80%a7%e5%8f%af%e8%a7%81%e6%80%a7%e6%9c%89%e5%ba%8f%e6%80%a7" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		原子性、可见性和有序性是 Java 内存模型中的三个概念。</p>
<ol>
<li>原子性</li>
</ol>
<p>​		原子性是指一个操作是不可中断的，要么全部执行成功，要么全部执行失败回滚，不会出现执行一半的情况。在 Java 中，基本数据类型的赋值和返回引用操作是具有原子性的，而像 long 和 double 等数据类型的赋值则不具有原子性。</p>
<p>​		为了保证复合操作的原子性，Java 提供了一些原子性的操作类，比如 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code> 等。这些类提供了一些原子性的方法，比如 <code>getAndIncrement()</code>、<code>getAndSet()</code> 等。</p>
<ol start="2">
<li>可见性</li>
</ol>
<p>​		可见性是指一个线程对共享变量的修改对其他线程是可见的。在 Java 中，共享变量存储在主内存中，每个线程都有自己的工作内存，线程在使用共享变量时，会将主内存中的值复制一份到自己的工作内存中，然后对这个副本进行操作。当一个线程修改了共享变量的值后，如果不满足某些条件，其他线程是无法看到这个修改的。这就是可见性问题。</p>
<p>​		为了解决可见性问题，Java 提供了 <code>volatile</code> 关键字。使用 <code>volatile</code> 修饰共享变量时，每次访问这个变量时，都会从主内存中读取最新的值，对这个变量的修改也会立即写回到主内存中。这样可以保证共享变量对其他线程的可见性。</p>
<ol start="3">
<li>有序性</li>
</ol>
<p>​		有序性是指程序执行的顺序按照代码的先后顺序执行。在 Java 中，编译器、处理器和运行时都会对指令进行重排序，可以提高程序的执行效率。但是，有些操作需要按照代码的先后顺序执行，否则会产生一些问题，这就需要保证有序性。</p>
<p>​		为了解决有序性问题，Java 提供了 <code>volatile</code> 和 <code>synchronized</code> 关键字。使用 <code>volatile</code> 修饰的变量和使用 <code>synchronized</code> 修饰的代码块，都可以保证程序的有序性。</p>
<h3 id="313-什么是守护线程有什么用">
  3.13 什么是守护线程，有什么用
  <a href="#313-%e4%bb%80%e4%b9%88%e6%98%af%e5%ae%88%e6%8a%a4%e7%ba%bf%e7%a8%8b%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		守护线程（Daemon Thread）是一种在后台运行的线程，它的生命周期与应用程序或其他线程不同。当所有非守护线程结束时，守护线程自动结束。通常，守护线程用于执行某些任务，比如垃圾回收（GC）等。</p>
<p>​		Java 虚拟机会自动结束所有的守护线程，因此，应用程序中的守护线程不能持有任何应用程序资源，如文件或数据库连接等，否则这些资源将无法正常关闭。守护线程通常用于在后台执行一些任务，并且这些任务对应用程序的运行不是必须的，比如监控线程、定时任务等。</p>
<h3 id="314-一个线程运行时发生异常会怎样">
  3.14 一个线程运行时发生异常会怎样
  <a href="#314-%e4%b8%80%e4%b8%aa%e7%ba%bf%e7%a8%8b%e8%bf%90%e8%a1%8c%e6%97%b6%e5%8f%91%e7%94%9f%e5%bc%82%e5%b8%b8%e4%bc%9a%e6%80%8e%e6%a0%b7" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		当一个线程运行时发生异常，如果异常没有被捕获处理，线程将会中止运行，同时 JVM 会输出异常堆栈信息。如果该线程是守护线程，则该线程中止运行，JVM 也会停止运行，因为此时只剩下守护线程在运行。如果该线程不是守护线程，则该线程会中止运行，但是其他非守护线程不会受到影响，仍然继续运行。</p>
<h3 id="315-线程-yield-方法有什么用">
  3.15 线程 yield() 方法有什么用
  <a href="#315-%e7%ba%bf%e7%a8%8b-yield-%e6%96%b9%e6%b3%95%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		线程的 <code>yield()</code> 方法可以让当前线程让出 CPU 执行权，让 CPU 调度器重新调度一次，但是 <code>yield()</code> 方法并不能保证让其他线程一定能得到执行机会，也有可能当前线程还是会继续执行。<code>yield()</code> 方法通常用于某个线程需要让出 CPU 执行权给其他优先级更高的线程，以提高程序的效率。使用 <code>yield()</code> 方法需要注意，过度的调用会导致 CPU 调度器的过度切换，影响程序的效率。</p>
<h3 id="316-什么是重入锁">
  3.16 什么是重入锁
  <a href="#316-%e4%bb%80%e4%b9%88%e6%98%af%e9%87%8d%e5%85%a5%e9%94%81" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		重入锁是一种可重入的互斥锁，它允许同一个线程多次获得同一把锁，而不会因为自己已经持有该锁而被阻塞。重入锁通常是基于Java 语言内置的 synchronized 关键字实现的，但与 synchronized 相比，重入锁提供了更多的灵活性和可扩展性，可以通过更加细粒度的控制来提高并发性能。</p>
<p>​		在使用重入锁时，需要注意一些概念和方法，比如公平锁和非公平锁、可重入性、重入次数、锁的状态等。同时，还需要注意锁的粒度问题，过大的锁粒度会影响并发性能，过小的锁粒度则可能导致锁竞争和线程上下文切换开销过大等问题。因此，在使用重入锁时需要根据具体情况进行锁的设计和粒度控制。</p>
<h3 id="317-线程同步需要注意什么">
  3.17 线程同步需要注意什么
  <a href="#317-%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在线程同步时，需要注意以下几点：</p>
<ol>
<li>避免死锁：死锁是指两个或多个线程互相持有对方所需要的锁，导致它们都无法继续执行的情况。为了避免死锁，需要在设计程序时，尽量避免一个线程同时持有多个锁。</li>
<li>避免饥饿：饥饿是指一个或多个线程因始终无法获取所需的锁，而无法执行的情况。为了避免饥饿，需要使用公平锁来保证每个线程都能公平地获取锁。</li>
<li>避免竞态条件：竞态条件是指多个线程访问共享资源时，由于执行顺序不确定而导致程序出现错误的情况。为了避免竞态条件，需要使用同步机制来保证共享资源的原子性操作。</li>
<li>尽量避免使用 synchronized：synchronized 的效率不高，而且容易造成死锁等问题。可以考虑使用 Lock 和 Condition 等更高级的同步机制来代替 synchronized。</li>
<li>尽量避免使用 Thread.stop()：Thread.stop() 方法会强制停止线程，容易导致线程运行的状态不一致。可以使用其他方式来停止线程，例如设置标志位来控制线程的执行状态。</li>
<li>尽量避免使用 Thread.suspend() 和 Thread.resume()：Thread.suspend() 方法会挂起线程，Thread.resume() 方法会恢复线程的执行。这两个方法容易导致死锁等问题，因此不建议使用。可以考虑使用 LockSupport.park() 和 LockSupport.unpark() 来代替。</li>
</ol>
<h3 id="318-怎么唤醒一个阻塞的线程">
  3.18 怎么唤醒一个阻塞的线程
  <a href="#318-%e6%80%8e%e4%b9%88%e5%94%a4%e9%86%92%e4%b8%80%e4%b8%aa%e9%98%bb%e5%a1%9e%e7%9a%84%e7%ba%bf%e7%a8%8b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>要唤醒一个阻塞的线程，可以使用以下方法：</p>
<ol>
<li>使用 <code>notify()</code> 方法唤醒单个线程：调用被锁定对象的 <code>notify()</code> 方法，唤醒一个等待在该对象上的线程。</li>
<li>使用 <code>notifyAll()</code> 方法唤醒所有阻塞线程：调用被锁定对象的 <code>notifyAll()</code> 方法，唤醒所有等待在该对象上的线程。</li>
<li>使用 <code>wait()</code> 方法释放锁并等待：在 synchronized 代码块中调用对象的 <code>wait()</code> 方法，线程将释放对象的锁并进入等待状态，直到被唤醒。</li>
</ol>
<p>​		需要注意的是，在使用 wait() 和 notify() 方法时，必须先获得对象的锁。如果线程没有获得对象的锁，会抛出 IllegalMonitorStateException 异常。此外，由于线程唤醒是随机的，因此不能依赖于线程唤醒的顺序。</p>
<h3 id="319-aqs-原理">
  3.19 AQS 原理
  <a href="#319-aqs-%e5%8e%9f%e7%90%86" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		AQS（AbstractQueuedSynchronizer）是 Java 并发包中非常重要的一个类，它是实现锁和其他同步器的基础。AQS 的核心思想是将锁的获取和释放操作分离成两个独立的步骤，从而可以实现更加灵活的锁定机制。AQS 实现了一个 FIFO 的队列，用于存储被阻塞的线程，实现了对线程的排队、阻塞和唤醒等操作。</p>
<p>​		AQS 主要有两种同步方式：<strong>独占锁</strong>和<strong>共享锁</strong>。独占锁是指同一时刻只有一个线程可以获得锁，其他线程需要等待；共享锁是指同一时刻可以有多个线程获得锁。</p>
<p>​		AQS 的底层数据结构是一个<strong>双向链表</strong>，每个链表节点都表示一个等待获取锁的线程。AQS 通过 CAS 操作（Compare and Swap）实现了对链表节点的加锁和解锁操作，保证了并发安全。</p>
<p>​		AQS 的实现是通过内置的同步器来实现的。在自定义锁或者同步器时，只需要继承 AQS 并实现相关方法即可。AQS 提供了一些模板方法，如 tryAcquire、tryRelease 等，方便开发者实现自己的同步器。</p>
<p>​		总的来说，AQS 的核心思想是将锁的控制逻辑抽象出来，并提供了一个底层的队列管理机制，使得Java并发包中的锁和同步器可以实现更加灵活的锁定机制。</p>
<h3 id="320-aqs-对资源的共享方式">
  3.20 AQS 对资源的共享方式
  <a href="#320-aqs-%e5%af%b9%e8%b5%84%e6%ba%90%e7%9a%84%e5%85%b1%e4%ba%ab%e6%96%b9%e5%bc%8f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		AQS（AbstractQueuedSynchronizer）提供了两种同步方式：独占锁和共享锁。</p>
<p>​		独占锁是指同一时刻只有一个线程可以获得锁，其他线程需要等待。这种锁的典型应用场景是对于一些需要<strong>互斥</strong>访问的共享资源，例如读写锁、可重入锁等。</p>
<p>​		共享锁是指同一时刻可以有多个线程获得锁，允许多个线程同时访问共享资源。这种锁的典型应用场景是对于一些只需要<strong>共享</strong>访问的资源，例如 Semaphore（信号量）。</p>
<p>​		在 AQS 中，独占锁和共享锁的实现都是通过维护<strong>同步队列</strong>来实现的。当一个线程请求获取锁时，AQS 会将其加入同步队列的尾部，同时在队列中记录该线程的状态，例如独占锁会记录当前锁是否被占用，共享锁会记录当前已经获得锁的线程数量。</p>
<p>​		当锁释放时，AQS 会从队列头部开始，唤醒等待线程并尝试让其获取锁，如果获取成功则将该线程从队列中移除；如果获取失败则继续唤醒下一个线程，直到队列为空或者所有等待线程都获得了锁。在这个过程中，AQS 会使用 CAS（Compare and Swap）操作来保证并发安全。</p>
<h3 id="321-aqs-底层使用了模板方法模式">
  3.21 AQS 底层使用了模板方法模式
  <a href="#321-aqs-%e5%ba%95%e5%b1%82%e4%bd%bf%e7%94%a8%e4%ba%86%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95%e6%a8%a1%e5%bc%8f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		AQS 底层使用了模板方法模式，通过定义算法骨架和钩子函数，让子类实现具体的业务逻辑，以达到代码复用和解耦的目的。</p>
<p>​		在 AQS 中，定义了两个基本的同步操作方法：acquire 和 release，以及两个不同类型的同步方法 tryAcquire 和 tryRelease。其中，acquire 和 release 是独占锁和共享锁的核心操作，是具体的同步算法骨架；tryAcquire 和 tryRelease 则是具体同步操作的具体实现，由子类实现。</p>
<p>​		AQS 中还定义了许多钩子函数，例如 shouldParkAfterFailedAcquire、parkAndCheckInterrupt 等，子类可以根据具体需求来实现这些钩子函数，以完成特定的同步操作。</p>
<p>​		使用模板方法模式的好处在于，将同步算法骨架与具体的同步操作分离，可以灵活地扩展和定制同步操作，同时也方便代码复用和维护。</p>
<h3 id="322-说一说自己对于-synchronized-关键字的了解">
  3.22 说一说自己对于 synchronized 关键字的了解
  <a href="#322-%e8%af%b4%e4%b8%80%e8%af%b4%e8%87%aa%e5%b7%b1%e5%af%b9%e4%ba%8e-synchronized-%e5%85%b3%e9%94%ae%e5%ad%97%e7%9a%84%e4%ba%86%e8%a7%a3" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		synchronized 是 Java 中的关键字，用于实现线程的同步。具体来说，synchronized 可以用来修饰方法和代码块，以实现对类、对象或代码块的加锁操作。</p>
<p>​		当一个线程试图访问一个被 synchronized 关键字修饰的方法或代码块时，它会尝试获取锁，如果锁没有被其他线程占用，则该线程可以执行操作；否则，该线程会进入阻塞状态，直到获取到锁为止。</p>
<p>​		synchronized 的主要作用是<strong>确保线程安全</strong>，即在多线程环境下，保证对共享资源的访问是有序、同步和互斥的。通过 synchronized 关键字，可以避免多个线程同时访问共享资源而导致的数据竞争和冲突问题。</p>
<p>​		需要注意的是，synchronized 虽然可以实现线程同步，但是过多的同步操作会带来性能上的负担，因此在实际开发中，应该根据具体的业务场景和性能需求，合理地使用 synchronized 关键字。此外，Java 中还提供了其他更高级别的并发工具，如 Lock、Semaphore、CountDownLatch 等，也可以用来实现线程同步和控制。</p>
<h3 id="323-说说自己是怎么使用-synchronized-关键字在项目中用到了吗">
  3.23 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗
  <a href="#323-%e8%af%b4%e8%af%b4%e8%87%aa%e5%b7%b1%e6%98%af%e6%80%8e%e4%b9%88%e4%bd%bf%e7%94%a8-synchronized-%e5%85%b3%e9%94%ae%e5%ad%97%e5%9c%a8%e9%a1%b9%e7%9b%ae%e4%b8%ad%e7%94%a8%e5%88%b0%e4%ba%86%e5%90%97" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		项目中使用 synchronized 关键字的场景主要是针对共享资源的并发访问进行同步控制。比如，在一个多线程环境下，如果多个线程需要对一个共享资源进行读写操作，那么就需要使用 synchronized 关键字进行同步处理，以确保每个线程在访问共享资源时都是有序、同步和互斥的。</p>
<p>​		具体来说，我在项目中使用 synchronized 关键字的方式有两种：</p>
<ol>
<li>对象锁：使用 synchronized 修饰一个非静态方法或代码块时，锁的对象是当前对象实例。这种方式主要用于对实例方法的同步控制。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Java" data-lang="Java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 对共享资源进行写操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="2">
<li>类锁：使用 synchronized 修饰一个静态方法或代码块时，锁的对象是当前类的 Class 对象。这种方式主要用于对静态方法或类变量的同步控制。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 对共享资源进行写操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>​		需要注意的是，synchronized 关键字虽然可以实现线程同步，但是如果使用不当，可能会带来性能上的损失。在实际开发中，应该根据具体的业务场景和性能需求，合理地使用 synchronized 关键字，并且结合其他更高级别的并发工具，如 Lock、Semaphore、CountDownLatch等，来实现更灵活、高效的线程同步和控制。</p>
<h3 id="324-讲一下-synchronized-关键字的底层原理">
  3.24 讲一下 synchronized 关键字的底层原理
  <a href="#324-%e8%ae%b2%e4%b8%80%e4%b8%8b-synchronized-%e5%85%b3%e9%94%ae%e5%ad%97%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		<code>synchronized</code> 是 Java 中用于实现线程同步的关键字。它可以修饰方法和代码块，在使用时需要指定同步锁对象。当多个线程试图同时访问同步代码块时，只有一个线程能够获得同步锁，其他线程则进入等待状态，直到获得锁的线程释放同步锁。</p>
<p>​		<code>	synchronized</code> 关键字的底层实现主要是通过 Java 中的 <code>Monitor</code> 对象来实现的。每个 Java 对象都有一个关联的 <code>Monitor</code> 对象，它用于实现对象级别的锁。在每个对象的头部，有一个记录锁状态的标志位，用于表示对象当前是否被锁定。</p>
<p>​		当线程进入同步代码块时，它首先会尝试获取锁。如果锁处于可用状态，那么线程会将锁标志位设置为锁定状态，然后进入同步代码块。如果锁已经被其他线程持有，则当前线程会进入等待状态，直到锁被释放为止。</p>
<p>​		在底层实现上，<code>synchronized</code> 代码块会被编译成 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，它们分别用于获取和释放锁。在执行 <code>monitorenter</code> 指令时，会尝试获取对象的 <code>Monitor</code>，如果获取成功，那么就说明该对象的锁处于可用状态；如果获取失败，则说明该对象的锁已经被其他线程持有，当前线程会进入等待状态。在执行 <code>monitorexit</code> 指令时，会释放对象的 <code>Monitor</code>，并将锁标志位设置为可用状态，以便其他线程可以获取锁。</p>
<p>​		需要注意的是，<code>synchronized</code> 关键字还有一种锁定方式是修饰方法，这种方式的锁是对象级别的锁，它锁定的是整个对象，而不是对象的某个属性或方法。对于静态方法而言，锁定的是类级别的锁，它可以锁定整个类。这种方式相对于代码块来说更为简洁，但是锁的粒度比较大，可能会影响程序的并发性能。</p>
<h3 id="325-说说-jdk16-之后的-synchronized-关键字底层做了哪些优化可以详细介绍一下这些优化吗">
  3.25 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗
  <a href="#325-%e8%af%b4%e8%af%b4-jdk16-%e4%b9%8b%e5%90%8e%e7%9a%84-synchronized-%e5%85%b3%e9%94%ae%e5%ad%97%e5%ba%95%e5%b1%82%e5%81%9a%e4%ba%86%e5%93%aa%e4%ba%9b%e4%bc%98%e5%8c%96%e5%8f%af%e4%bb%a5%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b%e8%bf%99%e4%ba%9b%e4%bc%98%e5%8c%96%e5%90%97" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 JDK 1.6 之前，synchronized 的实现是基于重量级锁（也叫做对象监视器 monitor）的，每次在进入和退出同步块（即进入和退出临界区）时都会进行线程的阻塞和唤醒，这样会导致在并发情况下性能低下。因此，JDK 1.6 对 synchronized 进行了优化，改进了锁的实现方式，主要体现在以下两个方面：</p>
<ol>
<li>从重量级锁到轻量级锁</li>
</ol>
<p>​		在 JDK 1.6 中，synchronized 引入了轻量级锁和偏向锁的概念，当没有竞争时，使用轻量级锁代替重量级锁，可以避免线程的阻塞和唤醒。只有在出现竞争时才会使用重量级锁。轻量级锁的实现使用了 CAS（比较并交换）操作来实现，这样可以避免多线程竞争的开销。</p>
<ol start="2">
<li>从可重入锁到偏向锁</li>
</ol>
<p>​		可重入锁是指在同一线程外层函数获取锁的时候，在进入内层函数会自动获取锁，而不会发生死锁的情况。在 JDK 1.6 中，对 synchronized 进行了另外一项优化，引入了偏向锁的概念，当只有一个线程访问同步块时，该线程会自动获取偏向锁，并记录下来，当线程再次访问该同步块时，无需再次获取锁，而是直接进入临界区，这样可以避免多次加锁和解锁带来的性能开销。</p>
<p>​		需要注意的是，在竞争激烈的情况下，偏向锁的效果并不好，此时会退化为轻量级锁或者重量级锁，因此在使用 synchronized 的时候需要根据实际情况进行选择。</p>
<p>​		综上所述，JDK 1.6 对 synchronized 进行了重大的性能优化，通过引入轻量级锁和偏向锁的概念，避免了线程阻塞和唤醒所带来的性能开销，同时也提高了并发效率。</p>
<h3 id="326-synchronized-和-reentrantlock-的区别">
  3.26 synchronized 和 ReenTrantLock 的区别
  <a href="#326-synchronized-%e5%92%8c-reentrantlock-%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>synchronized 和 ReentrantLock 都是 Java 中用于实现线程同步的机制，但它们之间存在以下区别：</p>
<ol>
<li>锁的获取方式：synchronized 是<strong>隐式</strong>获取锁，当线程进入 synchronized 保护的代码块时，会自动获取锁；ReentrantLock 则是通过代码<strong>显式</strong>获取锁和释放锁，需要手动调用 lock() 和 unlock() 方法。</li>
<li>可中断性：在获取锁时，ReentrantLock 支持中断等待锁的线程，而 synchronized 不支持，如果一个线程进入了 synchronized 保护的代码块，只能等待锁的释放。</li>
<li>公平性：ReentrantLock 支持公平锁和非公平锁，而 synchronized 只能是非公平锁。公平锁表示等待时间最长的线程将获得锁，非公平锁则是先尝试获取锁的线程获得锁。</li>
<li>等待通知机制：synchronized 内置了等待通知机制（wait/notify/notifyAll），而 ReentrantLock 则需要借助 Condition 来实现。</li>
<li>性能：JDK 1.6 之后，synchronized 的性能得到了大幅优化，比较低级的竞争激烈时使用 ReentrantLock 性能较好，而 synchronized 在竞争不激烈时性能优于 ReentrantLock。</li>
</ol>
<p>​		综上所述，synchronized 和 ReentrantLock 都是线程同步机制，但它们的使用方式和功能上存在一些差别，具体选择哪个取决于实际需求。在 JDK 1.6 之后，synchronized 的性能也得到了大幅优化，因此在竞争不激烈时，建议使用 synchronized。</p>
<h3 id="327-synchronized-关键字和-volatile-关键字的区别">
  3.27 synchronized 关键字和 volatile 关键字的区别
  <a href="#327-synchronized-%e5%85%b3%e9%94%ae%e5%ad%97%e5%92%8c-volatile-%e5%85%b3%e9%94%ae%e5%ad%97%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字都是 Java 中用于保证多线程程序正确性的关键字，但是它们之间有以下区别：</p>
<ol>
<li>作用范围不同：<code>synchronized</code> 关键字可以用来修饰方法、代码块或者类，而 <code>volatile</code> 关键字只能修饰变量。</li>
<li>实现原理不同：<code>synchronized</code> 关键字是通过独占锁实现的，即一个线程获取了锁，其他线程就不能同时获取该锁，只能等待该线程释放锁；而 <code>volatile</code> 关键字是通过修改内存可见性实现的，即一个线程对 <code>volatile</code> 变量的修改会立即被其他线程看到。</li>
<li>保证的内容不同：<code>synchronized</code> 关键字保证了线程的互斥访问，即同一时刻只有一个线程可以执行同步代码块中的代码；而 <code>volatile</code> 关键字保证了线程之间对变量的可见性，即一个线程修改了 <code>volatile</code> 变量的值，其他线程会立即看到这个值的变化。</li>
</ol>
<p>​		因此，当需要保证线程安全时，应该优先考虑使用 <code>synchronized</code> 关键字，因为它能够保证线程的互斥访问和数据的一致性；而当需要保证变量的可见性时，应该考虑使用 <code>volatile</code> 关键字。同时，在一些需要进行复杂的线程协作和控制的场景下，<code>ReentrantLock</code> 可以作为 <code>synchronized</code> 关键字的一种替代方案。</p>
<h3 id="328-为什么要用线程池">
  3.28 为什么要用线程池
  <a href="#328-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在多线程编程中，创建线程是一项消耗资源的操作，线程的创建和销毁会消耗较多的CPU时间和内存资源。如果我们需要频繁地创建和销毁线程，会导致系统的性能急剧下降。此外，线程池还可以方便地管理线程数量，防止线程数量过多导致系统崩溃。</p>
<p>使用线程池的好处有：</p>
<ol>
<li>节省资源：线程池在程序启动时便创建好了一定数量的线程，线程可以重复利用，避免了频繁创建和销毁线程所带来的性能开销。</li>
<li>提高响应速度：线程池中的线程可以异步执行任务，提高了任务的响应速度。</li>
<li>提高线程的可管理性：通过线程池，我们可以更好地管理和监控线程的状态和执行情况，可以方便地调整线程池的大小、添加新的任务等。</li>
<li>提高系统的稳定性：线程池可以控制线程的数量，避免了线程数量过多导致系统资源耗尽或系统崩溃的情况。</li>
</ol>
<p>​		总的来说，使用线程池可以提高程序的性能和可维护性，是多线程编程中的一种重要的优化手段。</p>
<h3 id="329-如何创建线程池">
  3.29 如何创建线程池
  <a href="#329-%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba%e7%ba%bf%e7%a8%8b%e6%b1%a0" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Java 中，可以通过<code>java.util.concurrent</code>包中的<code>Executor</code>框架来创建线程池。其中，<code>ExecutorService</code>是一个线程池的具体实现。</p>
<p>下面是创建线程池的示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个固定大小的线程池，其中线程数量为5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ExecutorService executor <span style="color:#f92672">=</span> Executors<span style="color:#f92672">.</span><span style="color:#a6e22e">newFixedThreadPool</span><span style="color:#f92672">(</span><span style="color:#ae81ff">5</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 提交任务到线程池
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>executor<span style="color:#f92672">.</span><span style="color:#a6e22e">execute</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Runnable<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 任务具体执行的代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">});</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 关闭线程池
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>executor<span style="color:#f92672">.</span><span style="color:#a6e22e">shutdown</span><span style="color:#f92672">();</span>
</span></span></code></pre></div><p>​		上面的代码中，使用了<code>Executors.newFixedThreadPool(5)</code>来创建一个固定大小的线程池，其中线程数量为5。然后，通过<code>executor.execute()</code>方法将需要执行的任务提交到线程池中。</p>
<p>​		在任务执行完毕后，需要调用<code>executor.shutdown()</code>方法关闭线程池，释放资源。</p>
<p>​		除了<code>newFixedThreadPool()</code>方法，还有其他方法可以创建不同类型的线程池，例如<code>newCachedThreadPool()</code>可以创建一个根据需要动态调整线程数量的线程池，<code>newSingleThreadExecutor()</code>可以创建一个只包含一个线程的线程池等等。</p>
<h3 id="330-实现-runnable-接口和-callable-接口的区别">
  3.30 实现 Runnable 接口和 Callable 接口的区别
  <a href="#330-%e5%ae%9e%e7%8e%b0-runnable-%e6%8e%a5%e5%8f%a3%e5%92%8c-callable-%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Java 中的线程可以通过两种方式来创建，分别是实现 Runnable 接口和实现 Callable 接口。它们之间的主要区别如下：</p>
<ol>
<li>返回值不同：</li>
</ol>
<p>​		Runnable 接口的 run() 方法不返回任何值，而 Callable 接口的 call() 方法可以返回执行结果，可以通过 Future 对象来获取结果。</p>
<ol start="2">
<li>抛出异常不同：</li>
</ol>
<p>​		Runnable 接口的 run() 方法不能抛出异常，而 Callable 接口的 call() 方法可以抛出异常。</p>
<ol start="3">
<li>调用方式不同：</li>
</ol>
<p>​		使用 Runnable 接口创建线程时，需要将其作为参数传递给 Thread 类的构造函数中；而使用 Callable 接口创建线程时，则需要使用FutureTask 类来包装 Callable 对象，再将其作为参数传递给 Thread 类的构造函数中。</p>
<ol start="4">
<li>对线程池的支持不同：</li>
</ol>
<p>​		Callable 接口支持线程池，可以提交给 ExecutorService 进行执行，而 Runnable 接口不支持线程池。</p>
<ol start="5">
<li>泛型不同：</li>
</ol>
<p>​	Callable 接口需要指定返回值类型，而 Runnable 接口没有泛型。</p>
<h3 id="331-执行-execute-方法和-submit-方法的区别是什么">
  3.31 执行 execute() 方法和 submit() 方法的区别是什么
  <a href="#331-%e6%89%a7%e8%a1%8c-execute-%e6%96%b9%e6%b3%95%e5%92%8c-submit-%e6%96%b9%e6%b3%95%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Java 线程池中，执行 <code>execute()</code> 方法和 <code>submit()</code> 方法都可以提交任务到线程池中执行，它们的主要区别在于返回值、异常处理和任务类型。</p>
<ol>
<li>返回值</li>
</ol>
<p>​		<code>execute()</code> 方法没有返回值，无法知道任务是否执行成功。而 <code>submit()</code> 方法返回一个 <code>Future</code> 对象，可以通过 <code>Future</code> 对象来判断任务是否执行成功，还可以获取任务执行的结果。</p>
<ol start="2">
<li>异常处理</li>
</ol>
<p>​		<code>execute()</code> 方法执行任务时，如果任务抛出了未捕获的异常，则会使得整个线程终止。而 <code>submit()</code> 方法执行任务时，如果任务抛出了未捕获的异常，则该异常会被包装在一个 <code>ExecutionException</code> 中，不会影响线程池中其他任务的执行。</p>
<ol start="3">
<li>任务类型</li>
</ol>
<p>​		<code>execute()</code> 方法只能提交实现了 <code>Runnable</code> 接口的任务，而 <code>submit()</code> 方法可以提交实现了 <code>Runnable</code> 接口和 <code>Callable</code> 接口的任务。<code>Runnable</code> 接口的任务只能执行一些操作，而 <code>Callable</code> 接口的任务可以返回一个结果并抛出异常。</p>
<p>​		综上所述，使用 <code>submit()</code> 方法比 <code>execute()</code> 方法更加灵活和方便，可以获取任务执行结果和进行异常处理。但是如果只需要提交 <code>Runnable</code> 任务并且不需要知道任务执行结果或进行异常处理，那么使用 <code>execute()</code> 方法也是可以的。</p>
<h3 id="332-介绍一下-atomic-原子类">
  3.32 介绍一下 Atomic 原子类
  <a href="#332-%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-atomic-%e5%8e%9f%e5%ad%90%e7%b1%bb" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在多线程编程中，一个操作（比如自增）通常包含了多个指令，而在多线程环境下执行这些指令时可能出现竞争条件（race condition），从而导致数据不一致的问题。Atomic 原子类是 Java 提供的一种线程安全的变量类型，能够保证单个变量的原子性操作（例如加减操作），避免了竞争条件，从而保证了多线程环境下的数据一致性。</p>
<p>​		Java 提供了多种 Atomic 原子类，例如 AtomicInteger、AtomicLong、AtomicBoolean 等，它们分别对应了整型、长整型、布尔型等基本数据类型。这些类提供了诸如 get、set、incrementAndGet、compareAndSet 等方法，能够支持原子性的读写和操作，从而避免了线程竞争导致的数据不一致问题。</p>
<p>​		使用 Atomic 原子类通常比使用 synchronized 关键字更加高效，因为 Atomic 原子类底层是基于 CPU 指令实现的，而 synchronized 关键字是基于对象锁的实现。当然，Atomic 原子类的使用范围更加有限，它只能用于<strong>单个变量</strong>的原子操作，不能代替 synchronized 实现更复杂的同步逻辑。</p>
<h3 id="333-juc-包中的原子类是哪-4-类">
  3.33 JUC 包中的原子类是哪 4 类
  <a href="#333-juc-%e5%8c%85%e4%b8%ad%e7%9a%84%e5%8e%9f%e5%ad%90%e7%b1%bb%e6%98%af%e5%93%aa-4-%e7%b1%bb" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>JUC 包中的原子类大致可以分为以下四类：</p>
<ol>
<li>原子更新<strong>基本类型类</strong>（如：AtomicInteger、AtomicLong、AtomicBoolean）：这些类提供了对基本数据类型的原子性更新操作，包括 getAndAdd、getAndIncrement、getAndSet 等方法。</li>
<li>原子更新<strong>数组类</strong>（如：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray）：这些类提供了对数组中元素的原子性更新操作，包括 getAndAdd、getAndIncrement、getAndSet 等方法。</li>
<li>原子更新<strong>引用类型类</strong>（如：AtomicReference、AtomicStampedReference、AtomicMarkableReference）：这些类提供了对引用类型对象的原子性更新操作，包括 getAndSet、compareAndSet 等方法。</li>
<li>原子更新<strong>字段类</strong>（如：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater）：这些类提供了对普通对象的原子性更新操作，可以用来更新某个类的实例对象中的某个字段，包括 compareAndSet、getAndAdd、getAndSet 等方法。</li>
</ol>
<p>​		这些原子类的底层都使用了类似 CAS（Compare And Swap） 的无锁算法来实现线程安全，相较于传统的使用锁的方式，这些类可以提供更高效的并发性能。</p>
<h3 id="334-介绍一下cas">
  3.34 介绍一下CAS
  <a href="#334-%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8bcas" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		CAS，全称为 Compare And Swap，是一种<strong>乐观锁</strong>技术。它的原理是利用 CPU 的原子指令，先比较目标内存的值是否与指定值相等，若相等，则将目标内存的值更新为新值；否则不做任何操作。CAS 操作是一个<strong>原子操作</strong>，不会被其他线程干扰。</p>
<p>​		在 Java 中，使用 CAS 技术的类主要有 AtomicInteger、AtomicLong、AtomicBoolean 等。</p>
<p>CAS 操作相比于传统的加锁操作，在并发量较高时，具有更高的性能。但是，它也有一些限制：</p>
<ol>
<li>ABA 问题：当一个值由 A 变成了 B，又变成了 A，此时 CAS 是无法检测到这种变化的，可能会引起业务逻辑上的问题。</li>
<li>循环时间长开销大：在 CAS 操作失败的情况下，会一直循环尝试，如果长时间无法成功，会造成 CPU 资源的浪费。</li>
<li>只能保证一个变量的原子操作：对于多个变量的操作，需要加锁来保证原子性。</li>
</ol>
<p>​	总的来说，CAS 是一种非常重要的并发技术，可以有效提高程序的性能和可伸缩性。但在使用时需要注意其局限性和适用场景。</p>
<h3 id="335-讲讲-atomicinteger-的使用">
  3.35 讲讲 AtomicInteger 的使用
  <a href="#335-%e8%ae%b2%e8%ae%b2-atomicinteger-%e7%9a%84%e4%bd%bf%e7%94%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		AtomicInteger 是 Java 并发包中的一个原子类，用于实现整数的原子操作，它可以保证多个线程同时对一个 AtomicInteger 进行操作时，不会出现线程安全问题。</p>
<p>AtomicInteger 类提供了多个方法，其中比较常用的有：</p>
<ul>
<li>incrementAndGet()：以原子方式将当前值加 1，返回更新后的值。</li>
<li>getAndIncrement()：以原子方式将当前值加 1，返回更新前的值。</li>
<li>decrementAndGet()：以原子方式将当前值减 1，返回更新后的值。</li>
<li>getAndDecrement()：以原子方式将当前值减 1，返回更新前的值。</li>
<li>addAndGet(int delta)：以原子方式将指定值与当前值相加，返回更新后的值。</li>
<li>getAndAdd(int delta)：以原子方式将指定值与当前值相加，返回更新前的值。</li>
<li>compareAndSet(int expect, int update)：如果当前值等于 expect，则以原子方式将该值设置为 update，返回 true；否则返回 false。</li>
</ul>
<p>​		其中 compareAndSet() 方法是实现 CAS 的核心方法，它会比较当前值是否等于期望值 expect，如果相等则将值更新为新值 update，否则不做任何操作。该方法的执行是原子性的，因此可以保证多个线程同时对一个 AtomicInteger 进行操作时，不会出现线程安全问题。</p>
<p>下面是一个简单的 AtomicInteger 使用示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.concurrent.atomic.AtomicInteger<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AtomicIntegerDemo</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> AtomicInteger count <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AtomicInteger<span style="color:#f92672">(</span><span style="color:#ae81ff">0</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">100</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Thread<span style="color:#f92672">(()</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                count<span style="color:#f92672">.</span><span style="color:#a6e22e">incrementAndGet</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}).</span><span style="color:#a6e22e">start</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        Thread<span style="color:#f92672">.</span><span style="color:#a6e22e">sleep</span><span style="color:#f92672">(</span><span style="color:#ae81ff">1000</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>count<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>​		在该示例中，我们创建了一个初始值为 0 的 AtomicInteger 对象，然后启动了 100 个线程，每个线程执行一次 incrementAndGet() 方法，将 AtomicInteger 的值加 1。最终我们输出 AtomicInteger 的值，得到的结果应该是 100。由于 AtomicInteger 的操作是原子的，因此这个程序可以正确地计算 AtomicInteger 的值，不会出现线程安全问题。</p>
<h3 id="336-简单介绍一下-atomicinteger-类的原理">
  3.36 简单介绍一下 AtomicInteger 类的原理
  <a href="#336-%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-atomicinteger-%e7%b1%bb%e7%9a%84%e5%8e%9f%e7%90%86" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		AtomicInteger 类是 Java 并发包（java.util.concurrent）中提供的一种线程安全的、原子性的整数操作类，它通过一种无锁的方式，使用 CAS（Compare and Swap）实现原子性的操作。</p>
<p>​		在 AtomicInteger 类内部，使用了一个名为 value 的 volatile 变量来存储整数值，该变量被标记为 volatile，保证了在多线程的情况下，每个线程都能获得该变量的最新值。</p>
<p>​		在对 value 变量进行修改的操作（如 addAndGet() 方法）时，AtomicInteger 类内部使用了 CAS 操作，通过比较当前 value 变量的值是否与期望值相等，如果相等则修改为新的值，否则不做任何修改，一直循环等待到修改成功为止。</p>
<p>​		这种无锁的方式避免了线程之间的竞争和阻塞，提高了并发操作的效率。同时，AtomicInteger 类还提供了一些常见的原子操作方法，如 getAndAdd()、compareAndSet() 等，方便开发者进行并发操作。</p>
<h3 id="337-java-内存模型是什么哪些区域是线程共享的哪些是不共享">
  3.37 Java 内存模型是什么，哪些区域是线程共享的，哪些是不共享
  <a href="#337-java-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e6%98%af%e4%bb%80%e4%b9%88%e5%93%aa%e4%ba%9b%e5%8c%ba%e5%9f%9f%e6%98%af%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e7%9a%84%e5%93%aa%e4%ba%9b%e6%98%af%e4%b8%8d%e5%85%b1%e4%ba%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Java 内存模型是一种规范，用于规定程序中的线程如何访问共享内存。Java 内存模型定义了线程之间的共享变量在内存中的可见性、有序性和原子性的保证。</p>
<p>​		Java 内存模型中，线程之间共享的区域包括堆、方法区和运行时常量池。堆是用于存放对象实例的区域，方法区是用于存放类信息、常量、静态变量和方法代码的区域，运行时常量池是方法区的一部分，用于存放字面量和符号引用。</p>
<p>​		线程之间不共享的区域包括线程栈和程序计数器。线程栈是用于存放线程私有的方法调用和局部变量的区域，每个线程都有自己的线程栈，线程之间互不干扰。程序计数器是用于记录线程执行位置的区域，每个线程都有自己的程序计数器，也不会共享。</p>
<p>​		由于线程之间的共享变量是存在竞争条件的，因此需要使用同步机制来保证对共享变量的访问是线程安全的。Java 提供了多种同步机制，包括 synchronized 关键字、Lock 接口、volatile 关键字等。</p>
<h3 id="338-hashtable-的-size-方法为什么要做同步">
  3.38 Hashtable 的 size() 方法为什么要做同步
  <a href="#338-hashtable-%e7%9a%84-size-%e6%96%b9%e6%b3%95%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%81%9a%e5%90%8c%e6%ad%a5" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Hashtable 的 size() 方法返回的是哈希表中映射的数量。在多线程的情况下，可能会有多个线程同时对 Hashtable 进行修改，这就可能导致 size() 方法读取到不正确的映射数量。因此，在 size() 方法中需要进行同步来保证读取到的映射数量是正确的。同步可以保证在读取映射数量时，没有其他线程对 Hashtable 进行修改，从而避免了读取到不正确的结果。但是，同步会影响 Hashtable 的性能，因此，如果不需要保证线程安全，可以使用 HashMap 替代 Hashtable。</p>
<h3 id="339-java-中堆和栈有什么不同">
  3.39 Java 中堆和栈有什么不同
  <a href="#339-java-%e4%b8%ad%e5%a0%86%e5%92%8c%e6%a0%88%e6%9c%89%e4%bb%80%e4%b9%88%e4%b8%8d%e5%90%8c" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Java 中，堆和栈都是内存分配的方式，它们的区别在于存储的内容和管理方式。</p>
<p>栈是一种线性数据结构，它按照先进后出（FILO）的原则存储数据。在程序运行时，栈用于存储方法执行时的局部变量、方法参数、方法返回值等。栈的内存管理是由编译器自动进行的，它的内存分配和释放都是自动完成的。</p>
<p>堆是另一种数据结构，它是动态分配的一块内存区域，用于存储 Java 对象。在程序运行时，堆中存储的对象可以被多个线程共享，而栈中存储的数据只能被所在的线程访问。堆的内存管理由 Java 虚拟机（JVM）进行，它的内存分配和释放不是自动完成的，需要由程序员手动管理。</p>
<p>在 Java 中，栈内存是线程私有的，每个线程都有自己的栈内存，用于存储方法调用过程中的临时数据。而堆内存是线程共享的，多个线程可以同时访问同一个对象所在的堆内存。因此，在多线程编程中，需要注意对共享变量的访问，以避免出现线程安全问题。</p>
<h3 id="340-什么是阻塞式方法">
  3.40 什么是阻塞式方法
  <a href="#340-%e4%bb%80%e4%b9%88%e6%98%af%e9%98%bb%e5%a1%9e%e5%bc%8f%e6%96%b9%e6%b3%95" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		阻塞式方法指的是当一个线程执行该方法时，该线程会被阻塞，直到方法执行完成或者出现错误。在阻塞式方法执行期间，该线程无法执行其他任务。</p>
<p>​		常见的阻塞式方法包括输入输出操作中的 read()、write()，线程等待中的 sleep()、wait()，以及锁中的 lock() 等。阻塞式方法的特点是会阻塞当前线程，因此需要谨慎使用。在多线程程序中，如果一个线程长时间地占用了阻塞式方法，可能会导致其他线程长时间等待，影响程序的性能。因此，在使用阻塞式方法时，需要考虑方法执行时间、线程的并发数量等因素，避免出现程序性能瓶颈。</p>
<h3 id="341-提交任务时线程池队列已满会时发会生什么">
  3.41 提交任务时线程池队列已满会时发会生什么
  <a href="#341-%e6%8f%90%e4%ba%a4%e4%bb%bb%e5%8a%a1%e6%97%b6%e7%ba%bf%e7%a8%8b%e6%b1%a0%e9%98%9f%e5%88%97%e5%b7%b2%e6%bb%a1%e4%bc%9a%e6%97%b6%e5%8f%91%e4%bc%9a%e7%94%9f%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>当线程池队列已满时，提交任务的操作可能会有不同的行为取决于使用的线程池的策略。以下是两种常见的策略：</p>
<ol>
<li>抛出异常：如果使用的是有界队列，并且队列已满，则线程池将抛出异常，指示队列已满并且无法再接受任务。这种情况下，可以捕获异常并进行处理，例如重新尝试提交任务。</li>
<li>阻塞：如果使用的是无界队列，那么线程池将一直等待队列可用空间，直到有空间可以接受任务。这样，任务将在队列中等待执行，直到有可用线程来处理它们。这种策略可能会导致任务提交操作阻塞，并且可能会降低整个应用程序的性能。可以通过合理地选择队列容量和线程池大小来缓解这个问题。</li>
</ol>
<h1 id="第4章-jvm">
  第4章 JVM
  <a href="#%e7%ac%ac4%e7%ab%a0-jvm" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="41-说一下-jvm-由那些部分组成运行流程是什么">
  4.1 说一下 JVM 由那些部分组成，运行流程是什么
  <a href="#41-%e8%af%b4%e4%b8%80%e4%b8%8b-jvm-%e7%94%b1%e9%82%a3%e4%ba%9b%e9%83%a8%e5%88%86%e7%bb%84%e6%88%90%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<!-- raw HTML omitted -->
<p>JVM（Java Virtual Machine）是Java虚拟机的缩写，是 Java 程序运行的基础环境。JVM 由以下几个部分组成：</p>
<ol>
<li>ClassLoader（类加载器）：负责加载字节码文件，将类的字节码文件加载到内存中并转化为 Java 虚拟机中的 Class 对象。</li>
<li>Runtime Data Area（运行时数据区）：Java 虚拟机内存区域，主要包括方法区、堆、虚拟机栈、本地方法栈和程序计数器等几个部分。</li>
<li>Execution Engine（执行引擎）：解释执行 Java 字节码文件。</li>
<li>Native Interface（本地接口）：JVM 与本地操作系统的接口，提供了访问本地资源的能力。</li>
</ol>
<p>JVM 的运行流程一般如下：</p>
<ol>
<li>JVM 通过类加载器加载字节码文件到内存中，生成 Class 对象。</li>
<li>JVM 将生成的 Class 对象放入方法区（Method Area）中。</li>
<li>JVM 创建一个新的线程，将线程信息压入虚拟机栈（JVM Stack）中，同时也为栈帧（Stack Frame）分配内存空间。</li>
<li>执行引擎从虚拟机栈中取出一个栈帧，将栈帧中的字节码文件解释执行。</li>
<li>在解释执行字节码文件时，如果需要访问本地系统资源，则通过本地接口调用操作系统提供的接口。</li>
<li>线程执行完毕后，JVM 销毁线程信息，并回收内存空间。</li>
</ol>
<p>需要注意的是，JVM 的实现可能因为厂商或者版本的不同而有所差异，但是 JVM 的基本运行流程和组成部分是相似的。</p>
<h3 id="42-简述一下-jvm-的类加载器">
  4.2 简述一下 JVM 的类加载器
  <a href="#42-%e7%ae%80%e8%bf%b0%e4%b8%80%e4%b8%8b-jvm-%e7%9a%84%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Java 虚拟机（JVM）的类加载器负责将类的二进制数据加载到内存中并转换成 java.lang.Class 类的实例。JVM 的类加载器通常被称为 ClassLoader。ClassLoader 主要负责从 Classpath、jar、zip 等文件中加载类的二进制字节码。</p>
<p>JVM 内置了三种 ClassLoader，分别是：</p>
<ol>
<li>
<p>Bootstrap ClassLoader，也称为引导类加载器，它是 JVM 内置的类加载器，主要用于加载 Java 核心库，如 java.lang 等，是 JVM 中最顶层的类加载器。在 JVM 启动时，Bootstrap ClassLoader 会自动加载并初始化一些重要的类，然后所有的 ClassLoader 都由这些类衍生出来。</p>
</li>
<li>
<p>Extension ClassLoader，也称为扩展类加载器，它是由 Java 实现提供的，主要用于加载 Java 的扩展类库，如 javax 等。它负责加载Java 扩展目录（JAVA_HOME/jre/lib/ext）中的 jar 包中的类。</p>
</li>
<li>
<p>AppClassLoader，也称为应用程序类加载器，是由系统属性 java.class.path 指定的路径中加载类的。如果没有自定义ClassLoader，所有的自定义类都由 AppClassLoader 加载。</p>
</li>
</ol>
<p>​		除了系统提供的 ClassLoader 之外，用户还可以自定义 ClassLoader。自定义 ClassLoader 一般继承自 ClassLoader 类，并实现自己的加载逻辑。自定义 ClassLoader 可以用于实现类隔离等功能，如 Web 容器中每个 Web 应用程序都有自己的 ClassLoader 来实现类隔离。</p>
<p>​		类加载器采用委托机制，即首先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。这样可以确保 Java 核心库中的类不会被自定义的类覆盖，保证 Java 平台的稳定性和安全性。</p>
<h3 id="43-简述一下-jvm-的运行时数据区域">
  4.3 简述一下 JVM 的运行时数据区域
  <a href="#43-%e7%ae%80%e8%bf%b0%e4%b8%80%e4%b8%8b-jvm-%e7%9a%84%e8%bf%90%e8%a1%8c%e6%97%b6%e6%95%b0%e6%8d%ae%e5%8c%ba%e5%9f%9f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>JVM（Java Virtual Machine，Java 虚拟机）的运行时数据区域包括以下几个区域：</p>
<ol>
<li>程序计数器（Program Counter Register）：是当前线程所执行的字节码的行号指示器。线程私有的，每个线程都有一个独立的程序计数器，当线程执行一个 Java 方法时，该方法的计数器会被清零，当方法执行结束时，计数器的值会被设置为返回地址的值。</li>
<li>Java 虚拟机栈（Java Virtual Machine Stack）：也是线程私有的，它描述的是 Java 方法执行的内存模型。每个方法在执行的同时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。栈帧随着方法的执行而入栈，随着方法的结束而出栈。</li>
<li>本地方法栈（Native Method Stack）：与 Java 虚拟机栈类似，只不过是为 JVM 执行本地方法服务的。</li>
<li>Java 堆（Java Heap）：是 JVM 所有线程共享的部分，是用于存储对象实例的地方。Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。Java 堆中又分为新生代（Young Generation）和老年代（Old Generation），新生代又分为 Eden 区域和两个 Survivor 区域。</li>
<li>方法区（Method Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li>
<li>运行时常量池（Runtime Constant Pool）：是方法区的一部分，用于存放编译时生成的各种字面量和符号引用。</li>
<li>直接内存（Direct Memory）：也是 JVM 堆外的一块内存区域，与 Java NIO（New I/O）密切相关。直接内存的分配不会受到 Java 堆大小的限制，但是会受到本机总内存大小以及处理器寻址空间的限制。</li>
</ol>
<h3 id="44-详细介绍下-jvm-方法区">
  4.4 详细介绍下 JVM 方法区
  <a href="#44-%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d%e4%b8%8b-jvm-%e6%96%b9%e6%b3%95%e5%8c%ba" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		JVM 方法区是 Java 虚拟机规范定义的一块内存区域，用于存储类的结构信息，如类的字段、方法、接口、常量池等。它是线程共享的，用于存放已被虚拟机加载的类信息。</p>
<p>​		JVM 方法区的内部结构主要包括常量池、类信息、静态变量、即时编译器编译后的代码等。</p>
<p>​		常量池存放类或接口中的常量，包括编译期生成的各种字面量和符号引用。类信息包括类的全限定名、访问标志、父类、实现的接口、类字段、类方法、构造器等信息。静态变量是指被 static 修饰的变量，它们的值在类初始化时就已经确定，存放在方法区中。即时编译器编译后的代码也会存放在方法区中。</p>
<p>JVM 方法区的主要特点包括：</p>
<ol>
<li>线程共享：方法区是 JVM 中线程共享的内存区域，所有线程都可以访问它。</li>
<li>永久代：在 Java 8 及之前版本的 JVM 中，方法区被实现为永久代（Permanent Generation），用于存放类的元数据信息，永久代的大小是有限的，当加载的类的数量增加时，会导致永久代空间不足。在 Java 8 中，永久代被元空间（Meta Space）取代，元空间并不在虚拟机内存中，而是使用本地内存，因此元空间的大小受限于本地内存的大小。</li>
<li>垃圾回收：方法区同样会被垃圾回收器回收，当一个类不再被使用时，它所占用的方法区空间也会被释放。</li>
<li>优化技术：方法区中存储的字节码可以被即时编译器（JIT）进行优化，提高程序的执行效率。</li>
</ol>
<p>​		总之，JVM 方法区是 Java 虚拟机中的一个重要内存区域，存储了类的结构信息，它的特点是线程共享、可被垃圾回收、可被 JIT 编译器优化。</p>
<h3 id="45-详细介绍下-jvm-的堆区">
  4.5 详细介绍下 JVM 的堆区
  <a href="#45-%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d%e4%b8%8b-jvm-%e7%9a%84%e5%a0%86%e5%8c%ba" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		JVM 的堆区是 Java 虚拟机运行时数据区域中最大的一块，也是被所有线程共享的一块内存区域，用于存放所有的对象实例和数组。JVM 的堆区在 JVM 启动时就被创建，其大小可以通过参数来指定，也可以根据应用程序的需要动态扩展或缩小。堆区的内存空间是连续的，按照从低地址到高地址的顺序进行分配。</p>
<p>​		堆区可以被分为新生代和老年代两部分。新生代是堆区的一部分，用于存放新创建的对象实例和数组。新生代又被划分为一个较大的 Eden 空间和两个较小的 Survivor 空间。当新对象创建时，它们会被分配到 Eden 空间，当 Eden 空间满时，会触发 Minor GC（也称为 Young GC），这时会清理掉没有被引用的对象，并把剩余的对象移动到一个 Survivor 空间中，同时还会对 Survivor 空间中的对象进行一定的年龄检查，将年龄达到一定值的对象移到老年代中。这个过程可能会多次执行，当 Survivor 空间也满了时，就会将对象移动到老年代中。</p>
<p>​		老年代是堆区的另一部分，用于存放长时间存活的对象。当对象在新生代中经历过多次 Minor GC 仍然存活，那么就会被移到老年代中。当老年代空间不足时，会触发 Full GC，这时会清理掉没有被引用的对象，并对整个堆区进行整理。</p>
<p>​		在堆区中还有一个重要的概念是对象的引用。对象的引用是指一个对象指向另一个对象的指针，可以通过对象引用访问到对象的属性和方法。在 Java 中，对象的引用有强引用、软引用、弱引用和虚引用四种类型，不同类型的引用对垃圾回收的行为有不同的影响。</p>
<h3 id="46-详细介绍下-jvm-的虚拟机栈">
  4.6 详细介绍下 JVM 的虚拟机栈
  <a href="#46-%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d%e4%b8%8b-jvm-%e7%9a%84%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		JVM（Java Virtual Machine）的虚拟机栈是一块线程私有的内存区域，每个线程都有自己的虚拟机栈，用于存储线程执行方法时的局部变量、方法参数、返回值和方法调用等信息。虚拟机栈是一个后进先出的栈结构，每个方法在执行时都会创建一个栈帧，栈帧中保存了该方法的信息。</p>
<p>虚拟机栈中的每个栈帧由3部分组成：</p>
<ul>
<li>局部变量表（Local Variable Table）：用于存储方法中定义的局部变量以及方法参数。局部变量表的容量在编译时就已经确定，运行期间不会改变。</li>
<li>操作数栈（Operand Stack）：用于存储方法执行过程中的中间结果。操作数栈的深度在编译时就已经确定，运行期间不会改变。</li>
<li>方法返回地址（Return Address）：指向方法调用者的返回地址。</li>
</ul>
<p>​		虚拟机栈的大小是有限制的，当线程请求的栈深度大于虚拟机栈所允许的深度时，会抛出 StackOverflowError 异常。另外，虚拟机栈还有一个重要的作用，就是保护程序的安全性，防止栈溢出或越界等错误对程序的执行造成影响。</p>
<p>​		需要注意的是，虚拟机栈中保存的是基本数据类型和对象的引用，而不是对象本身。对象本身是存储在堆区中的，虚拟机栈中只保存了对象的引用，所以虚拟机栈中的对象引用可能会指向堆区中的同一个对象，也可能指向不同的对象。另外，在 Java 8 之前，虚拟机栈中的方法调用存在一定的性能开销，Java 8 之后使用了内联缓存技术优化了方法调用的性能。</p>
<h3 id="47-详细介绍下-jvm-的本地方法栈">
  4.7 详细介绍下 JVM 的本地方法栈
  <a href="#47-%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d%e4%b8%8b-jvm-%e7%9a%84%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		JVM 的本地方法栈（Native Method Stack）是 JVM 运行时数据区中的一部分，它与 JVM 栈类似，但是它不是为 Java 方法服务的，而是为 JVM 执行 Native 方法服务的。</p>
<p>​		本地方法栈与虚拟机栈一样，也是线程私有的，它的作用是为 JVM 执行 Native 方法（即使用其他语言编写的方法）提供支持。在执行 Java 代码时，JVM 直接将字节码翻译为机器码执行，但是如果遇到了 Native 方法，JVM 无法直接将其翻译为机器码，需要借助于本地方法栈来执行这些方法。</p>
<p>​		本地方法栈与虚拟机栈的区别在于，虚拟机栈是为执行 Java 方法服务的，而本地方法栈是为执行 Native 方法服务的。本地方法栈和虚拟机栈的结构类似，都是一个栈，但是由于两者服务的对象不同，所以在实现细节上可能会有一些区别。</p>
<p>​		本地方法栈的大小可以通过设置 JVM 参数来调整，与虚拟机栈一样，如果本地方法栈的空间不足以执行某个 Native 方法，JVM 会抛出 StackOverflowError 异常。</p>
<p>​		总之，本地方法栈是为 JVM 执行 Native 方法提供支持的，它与虚拟机栈类似，但是服务的对象不同，是 JVM 运行时数据区中的重要组成部分。</p>
<h3 id="48-详细介绍下-jvm-的程序计数器">
  4.8 详细介绍下 JVM 的程序计数器
  <a href="#48-%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d%e4%b8%8b-jvm-%e7%9a%84%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		JVM（Java Virtual Machine，Java虚拟机）的程序计数器（Program Counter Register）是一块较小的内存空间，用于保存当前线程所执行的字节码指令的地址。每个线程都有一个独立的程序计数器，是线程私有的，线程执行的方法的每个字节码指令都有一个程序计数器值，线程切换时，当前线程的程序计数器值被保存到该线程的线程栈中，下一次该线程被调度执行时，从保存的程序计数器值开始执行。</p>
<p>程序计数器是 JVM 中的一种重要的寄存器，主要有以下几个作用：</p>
<ol>
<li>JVM通过程序计数器来控制字节码的执行，它记录当前线程所执行的字节码的行号指示器。</li>
<li>用于支持 Java 虚拟机的多线程执行，在每个线程中，程序计数器记录的是当前线程正在执行的 Java 方法的 JVM 指令地址或者是native 方法的本地指令地址，它的值是线程私有的，线程之间互不干扰。</li>
<li>在执行 Java 方法的过程中，程序计数器用于记录 Java 虚拟机正在执行的字节码指令地址，如果当前方法是 Native 方法，则程序计数器的值为空（Undefined）。当 Java 虚拟机正在执行 Java 方法时，程序计数器记录的是正在执行的虚拟机字节码指令的地址，如果当前线程正在执行的是 Java 方法，程序计数器的值就是该方法正在被执行的第一条指令的地址；如果当前线程正在执行的是 Native方法，那么程序计数器的值为 undefined。</li>
<li>能够非常快速的切换线程执行，线程切换后，程序计数器重新定位到新线程的执行位置，恢复该线程的继续执行。</li>
</ol>
<p>​		总的来说，程序计数器在 Java 虚拟机中扮演着非常重要的角色，它是 JVM 实现多线程运行和方法调用的关键所在，是 Java 虚拟机中一块非常重要的内存区域。</p>
<h3 id="49-详细介绍下-jvm-的执行引擎">
  4.9 详细介绍下 JVM 的执行引擎
  <a href="#49-%e8%af%a6%e7%bb%86%e4%bb%8b%e7%bb%8d%e4%b8%8b-jvm-%e7%9a%84%e6%89%a7%e8%a1%8c%e5%bc%95%e6%93%8e" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		JVM 的执行引擎是JVM的核心组成部分之一，负责执行字节码指令。JVM 的执行引擎主要分为解释器和即时编译器两种。</p>
<p>​		解释器是 JVM 最基本的执行引擎，通过逐条解释执行字节码指令来执行 Java 程序。由于解释器在每次执行指令时都需要重新解释一次字节码，因此效率较低。为了提高程序的执行效率，JVM 引入了即时编译器。</p>
<p>​		即时编译器是 JVM 的另一种执行引擎，它会将程序中的热点代码（经常被执行的代码）编译成本地机器码，以提高程序的执行效率。即时编译器可以根据不同的编译策略将代码编译成不同的形式，如编译成本地机器码、编译成可移植的中间代码等。</p>
<p>​		在 JVM 中，即时编译器通常是按照方法为单位进行编译的。当一个方法被执行多次时，即时编译器会将该方法编译成本地机器码，并将编译后的代码缓存起来，以便下次直接使用，这个过程被称为即时编译。</p>
<p>​		JVM 的执行引擎还包括一些其他的优化技术，如逃逸分析、方法内联、栈顶替换等。这些优化技术可以进一步提高程序的执行效率，使得 Java 程序能够更好地发挥性能优势。</p>
<h3 id="410-堆和栈的区别是什么">
  4.10 堆和栈的区别是什么
  <a href="#410-%e5%a0%86%e5%92%8c%e6%a0%88%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在计算机编程中，堆和栈是两个常用的内存管理方式。堆和栈都是计算机内存中的区域，它们在内存分配、使用和释放上有很大的不同。</p>
<p>​		栈区是一段连续的内存空间，存放函数的参数、局部变量等，由编译器自动分配和释放，其内存空间的大小是确定的，小于堆区的大小。栈区内存的分配是自动的，只要函数调用完成，系统就会自动地释放栈区的内存空间，不需要手动干预。栈区的内存分配和回收速度非常快。</p>
<p>​		堆区是指没有规定大小的一块区域，用于存放程序中动态分配的内存。堆区的内存空间比栈区大得多。在程序运行过程中，如果需要使用 new 等动态分配内存的语句，就需要使用堆区进行内存分配。在堆区中分配的内存，不会随着函数的调用而释放，而需要手动释放，否则就会出现内存泄露的问题。</p>
<p>​		总体来说，栈区的内存分配和释放速度更快，但是分配的内存空间较小且存储时间较短；堆区则分配的内存空间较大，存储时间较长，但是内存的分配和释放速度相对较慢。同时，由于堆区内存分配需要手动管理，容易产生内存泄漏等问题。</p>
<h3 id="411-深拷贝和浅拷贝的区别">
  4.11 深拷贝和浅拷贝的区别
  <a href="#411-%e6%b7%b1%e6%8b%b7%e8%b4%9d%e5%92%8c%e6%b5%85%e6%8b%b7%e8%b4%9d%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		深拷贝和浅拷贝是针对对象的复制操作的两种方式。</p>
<p>​		浅拷贝是指复制对象时，仅仅复制对象本身及其所有的基本类型成员变量的值，而不复制引用类型成员变量的值。即新对象的引用类型成员变量和原对象的引用类型成员变量都指向同一个对象。</p>
<p>​		深拷贝则是完全复制一个对象，即复制出来的新对象与原对象没有任何关联，其中的引用类型成员变量也会被递归地进行拷贝。</p>
<p>​		可以简单地理解为，浅拷贝只是对对象进行了一次“浅层次”的复制，而深拷贝则是进行了一次“深层次”的复制。</p>
<p>​		Java 中的 <code>clone()</code> 方法实现的是浅拷贝，如果需要实现深拷贝，可以通过实现 <code>Serializable</code> 接口并利用序列化和反序列化来实现，或者手动编写深拷贝方法。</p>
<h3 id="412-java-中会存在内存泄漏吗简述一下">
  4.12 Java 中会存在内存泄漏吗，简述一下
  <a href="#412-java-%e4%b8%ad%e4%bc%9a%e5%ad%98%e5%9c%a8%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%90%97%e7%ae%80%e8%bf%b0%e4%b8%80%e4%b8%8b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Java 中同样可能存在内存泄漏问题。内存泄漏指的是应用程序中已经无用的对象占用了内存，但是垃圾回收器无法识别和回收它们，导致内存的浪费。Java 中的内存泄漏主要是由于程序中不合理的内存使用和管理引起的。</p>
<p>常见的内存泄漏问题包括：</p>
<ol>
<li>静态集合对象未及时清空：静态集合对象会一直存在于内存中，如果在使用完后不及时清空，会导致这些对象的内存一直无法被释放。</li>
<li>对象引用未及时释放：如果对象引用未及时释放，可能导致对象一直存在于内存中。</li>
<li>资源未关闭：如果程序中使用了一些资源，如数据库连接、文件流等，如果在使用后不及时关闭，会导致这些资源一直占用内存。</li>
<li>内存泄漏的框架：一些框架本身存在内存泄漏问题，如果使用不当，也可能导致内存泄漏。</li>
</ol>
<p>为避免内存泄漏，我们可以采取以下措施：</p>
<ol>
<li>及时清空不再使用的对象引用，使得垃圾回收器可以回收无用的对象。</li>
<li>使用 try-with-resources 或者 try-finally 确保资源的释放。</li>
<li>避免使用静态集合对象或者及时清空它们。</li>
<li>定期进行内存泄漏检查，使用一些内存泄漏检查工具。</li>
</ol>
<h3 id="413-什么是-gc-为什么要有-gc">
  4.13 什么是 GC ，为什么要有 GC
  <a href="#413-%e4%bb%80%e4%b9%88%e6%98%af-gc-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%9c%89-gc" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		GC 是垃圾回收 (Garbage Collection) 的缩写，是指自动内存管理的一种机制。当程序运行时，会在内存中分配一些空间来存储变量、对象等数据，而这些数据的生命周期是不同的，有些是短暂的，有些则需要长时间存储。如果内存中的空间被占满了，新的数据就无法被存储，程序就会因为 OutOfMemoryError 而崩溃。因此需要一种机制来自动回收不再使用的内存空间，避免内存泄漏和程序崩溃，这就是垃圾回收机制。</p>
<p>​		GC 机制使得程序员无需显式地手动回收内存，降低了程序开发和维护的难度。同时也有利于优化内存使用和减少内存泄漏的问题。</p>
<h3 id="414-垃圾回收常见问题">
  4.14 垃圾回收常见问题
  <a href="#414-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>以下是垃圾回收常见问题的回答：</p>
<ol>
<li>什么是垃圾回收？ 垃圾回收是一种自动化的内存管理技术，它可以在程序运行期间自动回收不再被程序使用的内存。</li>
<li>垃圾回收是如何工作的？ 垃圾回收器通过扫描内存中的对象，并标记那些不再被程序使用的对象，然后将它们的内存释放出来。垃圾回收器使用不同的算法来实现垃圾回收，比如标记清除、标记整理、复制等算法。</li>
<li>如何避免垃圾回收对程序的影响？ 要避免垃圾回收对程序的影响，可以使用一些技巧，比如尽量减少对象的创建、使用基本数据类型代替对象等。</li>
<li>如何调优垃圾回收器？ 可以通过设置 JVM 的参数来调优垃圾回收器。比如设置堆的大小、设置新生代和老年代的比例、选择不同的垃圾回收器等。</li>
<li>什么是内存泄漏？ 内存泄漏是指程序中的对象占用了内存，但是这些对象不再被程序使用，却没有被释放掉的情况。如果内存泄漏持续发生，会导致程序的内存使用越来越高，最终导致程序崩溃。</li>
<li>如何避免内存泄漏？ 避免内存泄漏的方法包括：尽量避免使用全局变量、确保释放所有申请的内存、及时关闭数据库连接和网络连接等。</li>
<li>什么是内存溢出？ 内存溢出是指程序申请的内存超过了操作系统所能提供的内存大小。如果内存溢出持续发生，会导致程序崩溃。</li>
<li>如何避免内存溢出？ 避免内存溢出的方法包括：增加 JVM 堆大小、及时释放不再使用的内存、避免创建过多的对象等。</li>
</ol>
<h3 id="415-简述一下-java-垃圾回收机制">
  4.15 简述一下 Java 垃圾回收机制
  <a href="#415-%e7%ae%80%e8%bf%b0%e4%b8%80%e4%b8%8b-java-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Java 的垃圾回收机制是通过<strong>自动垃圾回收</strong>（Automatic Garbage Collection，简称AGC）来管理内存的。Java 中的垃圾回收器会自动回收那些不再被程序所使用的对象占用的内存空间，以便为程序提供更多的可用内存。Java 中的垃圾回收机制可以帮助程序员避免内存泄漏和内存溢出等问题，提高程序的稳定性和可靠性。</p>
<p>​		Java 垃圾回收机制的基本原理是通过<strong>标记-清除</strong>（Mark and Sweep）算法来实现的。在程序执行过程中，Java 虚拟机会自动地追踪每个对象的使用情况，并在适当的时候将不再使用的对象标记为垃圾对象。然后，垃圾回收器会扫描整个堆内存，将被标记为垃圾对象的内存空间进行回收和释放，以便为程序提供更多的可用内存。</p>
<p>​		除了标记-清除算法之外，Java 垃圾回收机制还支持其他的垃圾回收算法，如复制算法、标记整理算法和分代算法等，不同的垃圾回收算法具有不同的优缺点，可以根据具体的应用场景来选择合适的算法来进行垃圾回收。</p>
<h3 id="416-垃圾回收的优点和缺点">
  4.16 垃圾回收的优点和缺点
  <a href="#416-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e7%9a%84%e4%bc%98%e7%82%b9%e5%92%8c%e7%bc%ba%e7%82%b9" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		垃圾回收是一种自动管理内存的机制，它能够自动回收不再使用的内存，从而避免了手动释放内存的繁琐过程，减轻了程序员的工作量。垃圾回收的优点主要包括以下几个方面：</p>
<ol>
<li>减少了内存泄漏的风险：由于垃圾回收机制能够检测出不再使用的内存，所以可以避免内存泄漏的风险，提高了程序的稳定性和可靠性。</li>
<li>减少了程序员的工作量：使用垃圾回收机制可以避免手动释放内存的繁琐过程，从而减轻了程序员的工作量，提高了开发效率。</li>
<li>提高了程序的性能：由于垃圾回收机制能够自动回收不再使用的内存，从而避免了内存泄漏的情况，减少了程序的内存占用量，提高了程序的性能。</li>
</ol>
<p>不过，垃圾回收也存在一些缺点：</p>
<ol>
<li>垃圾回收机制需要消耗一定的系统资源，比如 CPU 时间和内存空间等，可能会导致程序的性能下降。</li>
<li>由于垃圾回收机制是自动进行的，所以程序员无法精确控制内存的释放时机，有可能会影响程序的性能和响应速度。</li>
<li>垃圾回收机制可能会导致程序出现停顿现象，从而影响用户体验，特别是对于需要实时响应的应用程序来说，这种影响更加明显。</li>
</ol>
<p>​		因此，在使用垃圾回收机制时，需要权衡它的优缺点，根据具体的应用场景进行选择和优化。</p>
<h3 id="417-垃圾回收器的原理是什么有什么办法进行手动回收">
  4.17 垃圾回收器的原理是什么，有什么办法进行手动回收
  <a href="#417-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8%e7%9a%84%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88%e6%9c%89%e4%bb%80%e4%b9%88%e5%8a%9e%e6%b3%95%e8%bf%9b%e8%a1%8c%e6%89%8b%e5%8a%a8%e5%9b%9e%e6%94%b6" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		垃圾回收器的原理是在程序运行时，定期扫描堆区域，识别出不再被引用的对象，并将其回收释放内存，以便新的对象可以使用这些空间。Java 语言中的垃圾回收机制使程序员可以专注于业务逻辑的实现，而无需手动管理内存，从而提高开发效率。</p>
<p>​		常用的垃圾回收算法有标记-清除、标记-整理、复制算法等，不同的算法有不同的优缺点和适用场景。</p>
<p>​		一般情况下，应该避免手动回收垃圾，因为这可能会引入内存泄漏和错误。Java 语言的垃圾回收机制是自动的，而且垃圾回收器已经被优化得非常好，因此很少需要手动回收垃圾。</p>
<p>​		如果非常确定需要手动回收垃圾，可以使用<code>System.gc()</code>方法，该方法会提示垃圾回收器进行垃圾回收，但不能保证会立即执行垃圾回收操作，也不能保证会回收所有垃圾对象。另外，JDK 9 之后，该方法被标记为弃用，不建议使用。</p>
<h3 id="418-jvm-中都有哪些引用类型">
  4.18 JVM 中都有哪些引用类型
  <a href="#418-jvm-%e4%b8%ad%e9%83%bd%e6%9c%89%e5%93%aa%e4%ba%9b%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 JVM 中，根据对象被引用的程度，可以将引用分为4种类型：</p>
<ol>
<li>强引用（Strong Reference）：最常见的引用类型。如果一个对象具有强引用，垃圾收集器绝不会回收它，即使在内存不足的情况下也不会回收。</li>
<li>软引用（Soft Reference）：如果一个对象只具有软引用，那么当内存不足时，垃圾收集器可能会回收它。软引用通常用来实现内存敏感的缓存。</li>
<li>弱引用（Weak Reference）：如果一个对象只具有弱引用，那么垃圾收集器会在任何时候回收它，即使在内存充足的情况下。弱引用通常用于实现一些只有在对象不再被使用时才需要执行特定操作的情况。</li>
<li>虚引用（Phantom Reference）：虚引用是最弱的引用类型，一个对象如果只有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾收集器回收。虚引用的主要作用是跟踪对象被垃圾回收的状态，虚引用无法通过 get() 方法获得对象的实例。</li>
</ol>
<p>​		除了以上四种引用类型，还有一种被称为 Final Reference 的特殊类型，它指向的对象只能被赋值一次，类似于 Java 中的 final 变量。这种引用类型主要用于实现对象的安全发布。</p>
<h3 id="419-如何判断对象会否可以被回收">
  4.19 如何判断对象会否可以被回收
  <a href="#419-%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e5%af%b9%e8%b1%a1%e4%bc%9a%e5%90%a6%e5%8f%af%e4%bb%a5%e8%a2%ab%e5%9b%9e%e6%94%b6" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Java 中，当一个对象不再被引用时，它将变成垃圾，等待垃圾回收器回收。判断对象是否可以被回收，主要有以下几种方法：</p>
<ol>
<li>引用计数法：通过维护一个计数器来记录对象被引用的次数，当计数器为0时即可被回收。但是，Java 不使用这种算法，因为这种算法无法处理循环引用的情况。</li>
<li>可达性分析法：通过一系列称为 GC Roots 的对象作为起点，遍历对象引用的图谱，判断对象是否可以被 GC Roots 引用到，如果不能，说明对象不可用，可以被回收。这是目前 Java 虚拟机使用的算法。</li>
<li>finalize() 方法：finalize() 是 Object 类中定义的方法，当垃圾回收器准备回收对象时，会先调用对象的 finalize() 方法，如果该方法执行完毕后对象仍然没有被引用，那么该对象就会被回收。但是，finalize() 方法的调用时机是不确定的，因此不能保证对象会被及时回收，也不能保证 finalize() 方法一定会被执行。</li>
</ol>
<p>​		需要注意的是，对象可以被回收并不意味着它会立即被回收。具体回收时间取决于垃圾回收器的算法和内存使用情况。</p>
<h3 id="420-jvm-垃圾回收算法有哪些">
  4.20 JVM 垃圾回收算法有哪些
  <a href="#420-jvm-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e7%ae%97%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>JVM 垃圾回收算法主要分为以下几种：</p>
<ol>
<li>标记-清除算法（Mark-Sweep）：这是最基础的垃圾回收算法，它分为标记和清除两个阶段。标记阶段标记出所有需要回收的对象，清除阶段回收所有被标记的对象，但由于标记和清除过程中会产生大量碎片空间，因此会导致堆空间的碎片化问题。</li>
<li>复制算法（Copying）：这种算法把可用内存空间划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就把还存活的对象复制到另一块上面，然后把这一块内存全部清空，使其成为空闲内存。由于每次都是把存活对象复制到另一块内存，所以不会产生碎片化问题。</li>
<li>标记-整理算法（Mark-Compact）：这种算法在标记阶段和标记-清除算法一样，标记出所有需要回收的对象，但在清除阶段不是直接回收被标记的对象，而是将所有存活的对象向一端移动，然后清空端边界以外的内存。这样就可以保持内存空间的连续性，避免了碎片化问题。</li>
<li>分代收集算法（Generational）：这种算法是针对不同生命周期的对象采取不同的垃圾回收算法。一般情况下，大部分对象的生命周期很短，只活跃在某个特定的时间段内，这种对象被称为新生代对象，因此在新生代对象中，通常采用复制算法。而长时间存活的对象则被称为老年代对象，因此在老年代对象中，通常采用标记-整理算法。</li>
</ol>
<p>可以根据具体的场景，选择不同的垃圾回收算法来优化内存的使用和回收效率。</p>
<h3 id="421-新生代老年代永久代的区别">
  4.21 新生代、老年代、永久代的区别
  <a href="#421-%e6%96%b0%e7%94%9f%e4%bb%a3%e8%80%81%e5%b9%b4%e4%bb%a3%e6%b0%b8%e4%b9%85%e4%bb%a3%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 JVM 中，内存分为多个区域，其中比较重要的是新生代、老年代和永久代，它们各自的特点和作用如下：</p>
<ol>
<li>新生代：新生代主要用于存放新创建的对象，被分为 Eden 区和两个 Survivor 区，通常采用复制算法进行垃圾回收。当 Eden 区满时，会触发 Minor GC（新生代垃圾回收）操作，将存活的对象复制到其中一个 Survivor 区，同时清空 Eden 区和另一个 Survivor 区，这样在下一次 GC 时，会将另一个 Survivor 区的存活对象复制到第一个 Survivor 区，然后清空该 Survivor 区，如此循环往复。</li>
<li>老年代：老年代主要用于存放长期存活的对象，通常采用标记清除或标记整理算法进行垃圾回收。当年老代空间不足时，会触发 Full GC（全局垃圾回收）操作，这时会同时对新生代和老年代进行垃圾回收。</li>
<li>永久代（或元数据区）：永久代用于存放静态类信息、常量等，通常采用标记-清除或标记-整理算法进行垃圾回收。在 JDK8 之后，永久代被彻底移除，被 Metaspace 代替。</li>
</ol>
<p>​		简单来说，新生代用于存放新对象，通过复制算法进行垃圾回收；老年代用于存放长期存活的对象，通过标记清除或标记整理算法进行垃圾回收；永久代用于存放静态类信息、常量等，在 JDK8 之后被 Metaspace 代替。</p>
<h3 id="422-简述分代垃圾回收器是怎么工作的">
  4.22 简述分代垃圾回收器是怎么工作的
  <a href="#422-%e7%ae%80%e8%bf%b0%e5%88%86%e4%bb%a3%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8%e6%98%af%e6%80%8e%e4%b9%88%e5%b7%a5%e4%bd%9c%e7%9a%84" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		分代垃圾回收器是基于分代假设的一种垃圾回收器，它将 Java 堆分为新生代和老年代两个区域，分别使用不同的垃圾回收算法。分代假设是指：不同对象的生命周期不同，新创建的对象更可能很快无用，而经过多次垃圾回收仍然存活的对象则更有可能长期存活。</p>
<p>​		新生代一般采用复制算法，将其分为一个较大的 Eden 区和两个较小的 Survivor 区（通常是 From 和 To 区），对象首先分配到 Eden 区，当 Eden 区满时，触发 Minor GC，将 Eden 区和 Survivor 区中的存活对象复制到 To 区，再将 Eden 区和 From 区清空。在对象经过多次复制后，若仍然存活，则会被晋升到老年代。</p>
<p>​		老年代一般采用标记-清除或标记-整理算法进行垃圾回收。标记-清除算法将已标记对象和未标记对象分别收集，并将未标记对象所占用的内存空间进行回收。标记-整理算法则将存活的对象移动到内存区域的一端，然后直接清理掉端边界以外的内存。标记-整理算法虽然会产生内存空洞，但是在程序运行期间，内存分配也是按照空洞进行分配的，所以空洞并不会影响内存分配。</p>
<p>​		永久代（PermGen）是一种特殊的堆区，主要用于存放类的元数据信息，如类名、方法名、字段名、字节码等。永久代在 JDK 8 中被移除，被称为元空间（Metaspace），元数据信息被存放在本地内存中。</p>
<p>​		分代垃圾回收器的工作原理是将不同对象按其生命周期划分到不同的内存区域，并采用不同的垃圾回收算法对其进行回收。通过这种方式，可以大大提高垃圾回收的效率，减少程序暂停时间。</p>
<h3 id="423-描述一下-jvm-加载-class-文件的原理机制">
  4.23 描述一下 JVM 加载 Class 文件的原理机制
  <a href="#423-%e6%8f%8f%e8%bf%b0%e4%b8%80%e4%b8%8b-jvm-%e5%8a%a0%e8%bd%bd-class-%e6%96%87%e4%bb%b6%e7%9a%84%e5%8e%9f%e7%90%86%e6%9c%ba%e5%88%b6" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>JVM 加载 Class 文件的原理机制可以分为三个步骤：</p>
<ol>
<li>加载：JVM 中的类加载器将编译好的 Java 代码转化为 Class 文件，然后通过类加载器将 Class 文件加载到 JVM 中。JVM 中的类加载器按照一定的顺序，从不同的位置加载类文件，比如：系统默认的类加载器会从 CLASSPATH 环境变量中加载类文件。</li>
<li>链接：当类加载器将 Class 文件加载到 JVM 中后，JVM 会进行验证、准备、解析等操作，这些操作称为链接。其中，验证操作是为了确保 Class 文件符合 JVM 规范；准备操作是为静态变量分配内存并设置默认值；解析操作是将符号引用转换为直接引用。</li>
<li>初始化：当链接完成后，JVM 会进行初始化操作，初始化类的静态变量和静态代码块。在初始化阶段，JVM 会保证一个类只会被初始化一次，即使多个线程同时初始化一个类，JVM 也会保证线程安全。</li>
</ol>
<p>​		在类的生命周期中，类的加载、链接和初始化是不可分割的三个部分，只有当这三个部分都完成后，JVM 才会真正地将类放入到内存中并对其进行使用。</p>
<h3 id="424-说一下类装载的执行过程">
  4.24 说一下类装载的执行过程
  <a href="#424-%e8%af%b4%e4%b8%80%e4%b8%8b%e7%b1%bb%e8%a3%85%e8%bd%bd%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>类的装载过程可以分为加载、验证、准备、解析和初始化五个阶段，下面是具体的执行过程：</p>
<ol>
<li>加载阶段：当程序需要使用一个类时，JVM 会先检查该类是否已经被加载，如果没有，则会执行加载过程。类加载器会首先检查该类的 Class 文件是否存在，如果存在，则将该 Class 文件加载到 JVM 内存中，并为其创建一个 Class 对象，这个对象用于描述该类的类型信息。</li>
<li>验证阶段：在加载完类之后，JVM 会对该类进行验证，以确保该类的字节码是符合 JVM 规范的，同时也保证了该类不会危害 JVM 自身的安全性。</li>
<li>准备阶段：在验证完类之后，JVM 会为该类分配内存，并为其静态变量赋默认值（0或null），这个过程被称为准备阶段。</li>
<li>解析阶段：在准备完类之后，JVM 会对类中的符号引用进行解析，以确定每个符号引用所对应的具体内存地址。解析过程可以在运行时进行，也可以在编译期进行。</li>
<li>初始化阶段：当一个类被首次使用时，JVM 会执行该类的初始化操作，该操作包括执行静态变量赋值语句和静态代码块中的代码。初始化过程只会执行一次，且是线程安全的。</li>
</ol>
<p>​		总的来说，类装载的执行过程涉及到了加载、验证、准备、解析和初始化五个阶段，这些阶段一般是顺序执行的，但是有些情况下可以在加载和验证之间进行解析，或者在初始化之前进行准备操作。</p>
<h3 id="425-什么是双亲委派模型">
  4.25 什么是双亲委派模型
  <a href="#425-%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be%e6%a8%a1%e5%9e%8b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		双亲委派模型（Parent-Delegate Model）是 Java 中的一种<strong>类加载器</strong>（ClassLoader）的工作机制。</p>
<p>​		在 Java 中，每个类都需要被加载到 JVM 中才能被使用。Java 虚拟机使用类加载器（ClassLoader）来动态加载 Java 类。在默认的双亲委派模型中，每个类加载器都有一个父加载器，它们之间形成了一个层次结构。当一个类加载器需要加载一个类时，它会首先委托给它的父加载器去尝试加载这个类。如果父加载器无法加载这个类，那么这个类加载器自己才会尝试去加载这个类。如果还是无法加载这个类，那么它的子加载器就会被尝试加载这个类。</p>
<p>​		这种双亲委派模型可以保证类的唯一性，避免了同一个类被多次加载，也可以保证类的安全性。因为当父类加载器无法加载某个类时，子类加载器会尝试加载这个类，从而避免了在不同的类加载器中出现相同的类名但是实现不同的类的情况。同时，由于类加载器之间的层次结构，每个类加载器只能访问其父加载器和其自身加载的类，这种机制可以保证类的安全性。</p>
<p>​		总的来说，双亲委派模型是一种有效的类加载器机制，使得 Java 应用程序能够以一种安全且有序的方式加载类。</p>
<h3 id="426-常用的性能优化方式有哪些">
  4.26 常用的性能优化方式有哪些
  <a href="#426-%e5%b8%b8%e7%94%a8%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>常用的性能优化方式包括以下几个方面：</p>
<ol>
<li>代码优化：如避免重复计算，避免频繁的创建和销毁对象等，可以通过使用缓存、延迟加载等方式来优化代码。</li>
<li>数据库优化：如增加索引，使用合适的数据类型，避免全表扫描等，可以优化数据库的性能。</li>
<li>缓存优化：如增加缓存命中率，减少缓存失效等，可以提高系统的响应速度和吞吐量。</li>
<li>并发优化：如使用并发编程技术，避免线程间的竞争和阻塞等，可以提高系统的并发能力和性能。</li>
<li>系统架构优化：如通过增加服务器，负载均衡等方式来优化系统架构，提高系统的容错性和性能。</li>
<li>网络优化：如使用 CDN、压缩传输数据、减少 HTTP 请求等，可以提高网络传输的速度和效率。</li>
<li>框架优化：如使用性能更高的框架，避免框架本身的性能瓶颈等，可以提高系统的性能。</li>
</ol>
<p>​		以上是常见的性能优化方式，具体的优化方式需要根据具体的应用场景和问题来确定。</p>
<h1 id="第5章-mysql">
  第5章 MySQL
  <a href="#%e7%ac%ac5%e7%ab%a0-mysql" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="51-关系型数据库事务的-acid-特性">
  5.1 关系型数据库事务的 ACID 特性
  <a href="#51-%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93%e4%ba%8b%e5%8a%a1%e7%9a%84-acid-%e7%89%b9%e6%80%a7" class="h-anchor" aria-hidden="true">#</a>
</h3>
<ul>
<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作<strong>要么全部完成，要么完全不起作用</strong>；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h3 id="52-并发事务带来了哪些问题">
  5.2 并发事务带来了哪些问题
  <a href="#52-%e5%b9%b6%e5%8f%91%e4%ba%8b%e5%8a%a1%e5%b8%a6%e6%9d%a5%e4%ba%86%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<ol>
<li><strong>脏读（Dirty read）</strong></li>
</ol>
<p>​		一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>
<p>​		例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</p>
<ol start="2">
<li><strong>丢失修改（Lost to modify）</strong></li>
</ol>
<p>​		在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>
<p>​		例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p>
<ol start="3">
<li><strong>不可重复读（Unrepeatable read）</strong></li>
</ol>
<p>​		指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
<p>​		例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p>
<ol start="4">
<li><strong>幻读（Phantom read）</strong></li>
</ol>
<p>​		幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<p>​		例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p>
<h3 id="53-sql-标准定义了哪些事务隔离级别">
  5.3 SQL 标准定义了哪些事务隔离级别
  <a href="#53-sql-%e6%a0%87%e5%87%86%e5%ae%9a%e4%b9%89%e4%ba%86%e5%93%aa%e4%ba%9b%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li>
<p><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
</li>
<li>
<p><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p>
</li>
<li>
<p><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。（MySQL 的默认隔离级）</p>
</li>
<li>
<p><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
</li>
</ul>
<!-- raw HTML omitted -->
<h3 id="54-mysql-表级锁和行级锁了解吗有什么区别">
  5.4 MySQL 表级锁和行级锁了解吗，有什么区别
  <a href="#54-mysql-%e8%a1%a8%e7%ba%a7%e9%94%81%e5%92%8c%e8%a1%8c%e7%ba%a7%e9%94%81%e4%ba%86%e8%a7%a3%e5%90%97%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p>
<p>​		行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p>
<p>表级锁和行级锁对比：</p>
<ul>
<li>表级锁：MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li>行级锁：MySQL 中锁定粒度最小的一种锁，是<strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li>
</ul>
<h3 id="55-说说自己对于-mysql-常见的两种存储引擎-myisam-与-innodb-的理解">
  5.5 说说自己对于 MySQL 常见的两种存储引擎： MyISAM 与 InnoDB 的理解
  <a href="#55-%e8%af%b4%e8%af%b4%e8%87%aa%e5%b7%b1%e5%af%b9%e4%ba%8e-mysql-%e5%b8%b8%e8%a7%81%e7%9a%84%e4%b8%a4%e7%a7%8d%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e-myisam-%e4%b8%8e-innodb-%e7%9a%84%e7%90%86%e8%a7%a3" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		MySQL 中常见的两种存储引擎是 MyISAM 和 InnoDB。</p>
<p>​		MyISAM 是 MySQL 的默认存储引擎，它在处理大量简单的查询时具有很高的性能，不支持事务处理和行级锁定。它的表级锁定使它在高并发的情况下性能较差，因为锁定会导致其他线程无法同时访问该表。</p>
<p>​		InnoDB 是 MySQL 5.5 以后的默认存储引擎，它支持事务处理和行级锁定，具有较高的并发处理能力和数据完整性，适合于大规模数据库环境。InnoDB 的行级锁定机制允许多个线程同时访问同一张表的不同数据行，提高了并发性能。</p>
<p>除此之外，MyISAM 和 InnoDB 还有以下区别：</p>
<ol>
<li>存储结构：MyISAM 存储表的行数、数据长度、索引长度等信息，而 InnoDB 则是将数据和索引存放在同一个文件中，表本身就是聚簇索引。</li>
<li>事务支持：MyISAM 不支持事务处理，而 InnoDB 支持事务处理，并支持四种隔离级别。</li>
<li>外键支持：MyISAM 不支持外键，而 InnoDB 支持外键。</li>
<li>全文搜索：MyISAM 支持全文搜索，而 InnoDB 不支持全文搜索（5.6 版本及以后的 InnoDB 引擎已经支持全文搜索）。</li>
<li>性能：对于读操作，MyISAM 的性能较好，对于写操作，InnoDB 的性能较好。因此，当系统对写操作的并发性能有较高要求时，InnoDB 是更好的选择。</li>
</ol>
<h3 id="56-数据库索引了解吗">
  5.6 数据库索引了解吗
  <a href="#56-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b4%a2%e5%bc%95%e4%ba%86%e8%a7%a3%e5%90%97" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		数据库索引是一种数据结构，用于提高查询数据的效率。通过在数据库表的列上创建索引，可以更快地搜索和排序数据，减少查询数据的时间和成本。索引可以类比于字典中的目录，可以加快查询时的查找速度，同时还能够加速数据的插入、更新和删除操作。</p>
<p>​		常见的索引类型包括：B-tree 索引、Hash 索引、全文索引等。</p>
<p>​		其中 B-tree 索引是最常用的一种索引类型。在 B-tree 索引中，每个节点都包含了多个键值和指向其他节点的指针。每个节点的大小通常与磁盘块的大小相当，可以有效地利用磁盘的预读特性，加快查询的速度。B-tree 索引的缺点是不支持全文搜索，且在插入、更新、删除等操作时需要进行频繁的重排，导致性能下降。</p>
<p>​		相比之下，Hash 索引通常比 B-tree 索引速度更快，但是 Hash 索引只适用于精确匹配查询，不支持范围查询和排序，且对数据的插入、更新和删除等操作的效率较低。</p>
<p>​		全文索引是一种用于全文搜索的索引类型，常用于搜索引擎中。全文索引可以对文本内容进行分词，将单词存储在索引中，从而支持全文搜索和模糊搜索。全文索引一般适用于文本搜索，而不适用于数值或日期等其他类型的数据。</p>
<p>​		索引的选择应该根据实际情况进行，根据查询的频率、数据的大小和类型、应用程序的需求等因素进行权衡和选择。</p>
<h3 id="57-为什么索引能提高查询速度">
  5.7 为什么索引能提高查询速度
  <a href="#57-%e4%b8%ba%e4%bb%80%e4%b9%88%e7%b4%a2%e5%bc%95%e8%83%bd%e6%8f%90%e9%ab%98%e6%9f%a5%e8%af%a2%e9%80%9f%e5%ba%a6" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		索引是一种数据结构，它可以帮助数据库系统快速定位和访问表中的特定数据行，从而提高查询速度。具体来说，索引会创建一张“索引表”，这张表记录了表中每个索引字段的值和对应的数据行的物理位置，查询时可以直接根据索引表定位到需要查询的数据行，避免了全表扫描的开销。</p>
<p>通常来说，索引可以提高查询速度的原因如下：</p>
<ol>
<li>索引可以大大减少数据库需要扫描的数据量，从而缩短查询时间。</li>
<li>索引可以将随机 I/O 转换成顺序 I/O，从而加快查询速度。</li>
<li>索引可以帮助数据库系统避免排序和临时表的使用，从而进一步提高查询速度。</li>
</ol>
<p>但是，索引也有一些缺点：</p>
<ol>
<li>索引会占用存储空间，对于大型数据表来说，索引可能会占用大量的磁盘空间。</li>
<li>索引会增加写操作的开销，因为每次对数据表的修改都需要更新索引表。</li>
<li>索引可能会导致查询性能下降，如果索引被滥用，那么查询性能反而可能会下降。因此，在使用索引时需要谨慎考虑，并根据具体情况选择合适的索引策略。</li>
</ol>
<h3 id="58-mysql-如何为表字段添加索引">
  5.8 MySQL 如何为表字段添加索引
  <a href="#58-mysql-%e5%a6%82%e4%bd%95%e4%b8%ba%e8%a1%a8%e5%ad%97%e6%ae%b5%e6%b7%bb%e5%8a%a0%e7%b4%a2%e5%bc%95" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>MySQL 中可以通过 <code>CREATE INDEX</code> 语句和 <code>ALTER TABLE</code> 语句为表字段添加索引。</p>
<ol>
<li><code>CREATE INDEX</code> 语句</li>
</ol>
<p>使用 <code>CREATE INDEX</code> 语句可以在表创建时添加索引，语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> [<span style="color:#66d9ef">UNIQUE</span>] <span style="color:#66d9ef">INDEX</span> index_name <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">table_name</span>(<span style="color:#66d9ef">column_name</span>[(<span style="color:#66d9ef">length</span>)], ...)
</span></span></code></pre></div><p>​		其中，<code>index_name</code> 为索引名称，可选；<code>table_name</code> 为表名；<code>column_name</code> 为要添加索引的列名；<code>length</code> 为索引长度，可选。</p>
<p>例如，在 <code>user</code> 表的 <code>username</code> 字段上创建一个名为 <code>idx_username</code> 的索引，可以使用以下语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">INDEX</span> idx_username <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">user</span>(username);
</span></span></code></pre></div><ol start="2">
<li><code>ALTER TABLE</code> 语句</li>
</ol>
<p>使用 <code>ALTER TABLE</code> 语句可以在表创建后添加索引，语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">table_name</span> <span style="color:#66d9ef">ADD</span> [<span style="color:#66d9ef">UNIQUE</span>] <span style="color:#66d9ef">INDEX</span> index_name (<span style="color:#66d9ef">column_name</span>[(<span style="color:#66d9ef">length</span>)], ...)
</span></span></code></pre></div><p>​		其中，<code>index_name</code> 为索引名称，可选；<code>table_name</code> 为表名；<code>column_name</code> 为要添加索引的列名；<code>length</code> 为索引长度，可选。</p>
<p>例如，在 <code>user</code> 表的 <code>username</code> 字段上添加一个名为 <code>idx_username</code> 的索引，可以使用以下语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">user</span> <span style="color:#66d9ef">ADD</span> <span style="color:#66d9ef">INDEX</span> idx_username (username);
</span></span></code></pre></div><p>​		需要注意的是，添加索引会占用一定的磁盘空间和内存资源，同时也会增加写操作的成本，因此需要根据实际情况进行权衡和优化。</p>
<h3 id="59-对于大表的常见优化手段说一下">
  5.9 对于大表的常见优化手段说一下
  <a href="#59-%e5%af%b9%e4%ba%8e%e5%a4%a7%e8%a1%a8%e7%9a%84%e5%b8%b8%e8%a7%81%e4%bc%98%e5%8c%96%e6%89%8b%e6%ae%b5%e8%af%b4%e4%b8%80%e4%b8%8b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>对于大表的常见优化手段可以从以下几个方面入手：</p>
<ol>
<li>垂直拆分：将一个大表拆分成多个表，使得每个表的数据量变小，以此来降低表的大小，从而提高查询效率。这种方法需要对表结构进行重新设计，并且需要在应用层面进行代码的重构，比较复杂。</li>
<li>水平拆分：将一个大表的数据按照某种规则拆分成多个小表，比如按照日期或者按照用户 ID 等等。这种方法不需要对表结构进行重新设计，但是需要在应用层面进行代码的重构，同时对于跨分区查询的情况，需要在代码层面进行处理。</li>
<li>分区：在表级别对表数据进行分区，使得每个分区的数据量变小，以此来降低表的大小，从而提高查询效率。分区可以按照时间、范围或者哈希等方式进行分区，具体的分区策略需要根据实际情况来定。</li>
<li>索引优化：对于大表，索引的设计尤为重要，需要根据实际情况来设计合适的索引，避免无效的索引和重复索引的出现，同时也需要注意索引的维护和更新。</li>
<li>数据库参数优化：对于大表，数据库的配置参数也需要进行优化，比如缓存大小、线程池大小、并发数等等。需要根据实际情况来调整配置参数，以达到最优的性能。</li>
<li>SQL 优化：对于大表，SQL 语句的优化也尤为重要，需要避免全表扫描、大量的子查询、联合查询等操作，需要尽量使用索引来加速查询。同时也需要注意 SQL 语句的书写规范，以提高查询效率。</li>
</ol>
<p>​		综上所述，对于大表的优化，需要从多个方面入手，综合考虑各种优化手段，以达到最优的性能。</p>
<h1 id="第6章-spring">
  第6章 Spring
  <a href="#%e7%ac%ac6%e7%ab%a0-spring" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="61-什么是-spring-框架">
  6.1 什么是 Spring 框架
  <a href="#61-%e4%bb%80%e4%b9%88%e6%98%af-spring-%e6%a1%86%e6%9e%b6" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inversion of Control：控制反转） 和 AOP（Aspect-Oriented Programming：面向切面编程）、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p>
<h3 id="62-spring-包含的模块有哪些">
  6.2 Spring 包含的模块有哪些
  <a href="#62-spring-%e5%8c%85%e5%90%ab%e7%9a%84%e6%a8%a1%e5%9d%97%e6%9c%89%e5%93%aa%e4%ba%9b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring 是一个非常强大的开源框架，由多个模块组成，每个模块专注于解决特定的问题。以下是 Spring 框架中一些常见的模块：</p>
<ol>
<li>Spring Core：Spring 核心容器，包括 IOC 和 DI 功能，提供了管理 Bean 的机制。</li>
<li>Spring AOP：基于动态代理和字节码操作的面向切面编程（AOP）框架。</li>
<li>Spring JDBC：提供了一个 JDBC 抽象层，简化了数据访问的开发。</li>
<li>Spring ORM：提供了多种 ORM 工具的支持，包括 Hibernate、JPA 等。</li>
<li>Spring Transaction：提供了事务管理的支持，可以通过声明式事务管理或编程式事务管理的方式来控制事务。</li>
<li>Spring Web MVC：提供了一个基于 MVC 模式的 Web 框架，简化了 Web 应用的开发。</li>
<li>Spring WebFlux：基于响应式编程模型的 Web 框架，提供了基于事件驱动的非阻塞 I/O 支持，适用于高并发场景。</li>
<li>Spring Security：提供了基于声明式的安全性支持，用于保护 Web 应用程序的安全性。</li>
<li>Spring Boot：提供了快速构建 Spring 应用程序的脚手架，提供了自动配置和 starter，简化了应用程序的开发过程。</li>
<li>Spring Cloud：基于 Spring Boot 的微服务框架，提供了服务注册与发现、配置管理、负载均衡、断路器等组件。</li>
</ol>
<h3 id="63-spring-的俩大核心概念">
  6.3 Spring 的俩大核心概念
  <a href="#63-spring-%e7%9a%84%e4%bf%a9%e5%a4%a7%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring 框架是一个非常流行的 Java 应用程序框架，它的俩大核心概念是：</p>
<ol>
<li>依赖注入（Dependency Injection，DI）：依赖注入是 Spring 框架的核心思想之一，它通过将对象之间的依赖关系交给容器管理，实现了松耦合的组件之间的协作。通过依赖注入，Spring 框架可以在运行时将一个对象所依赖的其他对象的引用传递给它，从而实现对象之间的解耦。</li>
<li>切面编程（Aspect-Oriented Programming，AOP）：切面编程是 Spring 框架的另一个核心概念，它通过在运行时动态地将代码逻辑插入到程序执行的不同阶段中，实现了对系统的统一控制和管理。通过 AOP，Spring 框架可以将不同的横切关注点（如事务处理、安全性检查等）从业务逻辑中分离出来，实现了系统的解耦和复用。</li>
</ol>
<h3 id="64-什么是-spring-的依赖注入依赖注入的基本原则是什么有什么优势">
  6.4 什么是 Spring 的依赖注入，依赖注入的基本原则是什么，有什么优势
  <a href="#64-%e4%bb%80%e4%b9%88%e6%98%af-spring-%e7%9a%84%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%8e%9f%e5%88%99%e6%98%af%e4%bb%80%e4%b9%88%e6%9c%89%e4%bb%80%e4%b9%88%e4%bc%98%e5%8a%bf" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Spring 的依赖注入（Dependency Injection，DI）是指在对象创建时，由 IoC 容器自动将对象所依赖的其他对象注入到它里面，从而实现对象之间的解耦和复用。</p>
<p>​		依赖注入的基本原则是：应该让依赖关系从代码中解耦出来，而不是在代码中硬编码依赖关系。依赖关系的管理应该交给容器来完成，即控制反转（IoC）。</p>
<p>依赖注入的优势包括：</p>
<ol>
<li>降低了组件之间的耦合度，提高了代码的可维护性和可扩展性。</li>
<li>可以更方便地实现组件的替换和升级，同时也方便了单元测试和集成测试的编写。</li>
<li>可以避免对象之间相互创建、相互依赖，导致代码的混乱和不易维护。</li>
<li>通过依赖注入容器，可以很容易地管理对象的生命周期和作用域，例如单例、原型、请求作用域等。</li>
</ol>
<p>​		总之，依赖注入是 Spring 框架最核心的特性之一，也是 Spring 优秀的设计和良好的扩展性的基础。</p>
<h3 id="65-有哪些不同类型的依赖注入实现方式">
  6.5 有哪些不同类型的依赖注入实现方式
  <a href="#65-%e6%9c%89%e5%93%aa%e4%ba%9b%e4%b8%8d%e5%90%8c%e7%b1%bb%e5%9e%8b%e7%9a%84%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e5%ae%9e%e7%8e%b0%e6%96%b9%e5%bc%8f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Spring 中，有三种常见的依赖注入实现方式：</p>
<ol>
<li>基于构造函数的依赖注入（Constructor-based Dependency Injection）</li>
</ol>
<p>​		基于构造函数的依赖注入是通过对象的构造函数注入依赖。Spring 容器实例化一个 bean 时，会检查它所依赖的其他 bean，然后通过构造函数将依赖注入到 bean 中。</p>
<p>示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Example</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Dependency dependency<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Example</span><span style="color:#f92672">(</span>Dependency dependency<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">dependency</span> <span style="color:#f92672">=</span> dependency<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="2">
<li>基于 Setter 的依赖注入（Setter-based Dependency Injection）</li>
</ol>
<p>​		基于 Setter 的依赖注入是通过对象的 Setter 方法注入依赖。Spring 容器实例化一个 bean 时，会检查它所依赖的其他 bean，然后通过 Setter 方法将依赖注入到 bean 中。示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Example</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Dependency dependency<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setDependency</span><span style="color:#f92672">(</span>Dependency dependency<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">dependency</span> <span style="color:#f92672">=</span> dependency<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="3">
<li>基于字段的依赖注入（Field-based Dependency Injection）</li>
</ol>
<p>​		基于字段的依赖注入是直接将依赖注入到类的字段中。Spring 容器实例化一个 bean 时，会检查它所依赖的其他 bean，然后将依赖注入到 bean 的字段中。</p>
<p>示例代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Example</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Autowired</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Dependency dependency<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>​		需要注意的是，基于字段的依赖注入需要使用 <code>@Autowired</code> 注解来标注依赖注入的字段。</p>
<h3 id="66-构造器依赖注入和-setter-方法注入的区别">
  6.6 构造器依赖注入和 Setter 方法注入的区别
  <a href="#66-%e6%9e%84%e9%80%a0%e5%99%a8%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e5%92%8c-setter-%e6%96%b9%e6%b3%95%e6%b3%a8%e5%85%a5%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		构造器依赖注入和 Setter 方法注入都是 Spring 中常用的依赖注入方式，它们的主要区别在于注入时间和注入方式。</p>
<p>​		构造器依赖注入是在对象实例化时就通过构造方法将依赖注入到对象中，这样在对象实例化完成后，它的所有依赖都已经被注入，对象就可以使用它们了。由于依赖是在对象实例化时注入的，因此构造器依赖注入也被称为“从外部传递依赖”。</p>
<p>​		Setter 方法注入是在对象实例化后，通过调用对象的 Setter 方法将依赖注入到对象中。由于依赖是在对象实例化后注入的，因此Setter方法注入也被称为“从内部生成依赖”。</p>
<p>​		总的来说，构造器依赖注入是通过将依赖注入到对象中来创建对象，而 Setter 方法注入则是通过创建对象来注入依赖。选择哪种方式取决于具体的场景和需要，例如如果一个对象的依赖是必需的，那么应该使用构造器注入，而如果对象的依赖是可选的，则可以使用 Setter 方法注入。</p>
<h3 id="67-spring-的优缺点是什么">
  6.7 Spring 的优缺点是什么
  <a href="#67-spring-%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Spring框架作为一种流行的Java应用程序框架，有以下优缺点：</p>
<p>优点：</p>
<ol>
<li>轻量级：Spring 框架是一个轻量级的框架，只需要很少的配置就可以使用，不需要像其他框架那样繁琐复杂的配置。</li>
<li>依赖注入：Spring 框架通过依赖注入实现了组件之间的松耦合，使得代码更加模块化、可维护和可测试。</li>
<li>AOP：Spring 框架通过 AOP 实现了对系统的统一控制和管理，从而提高了系统的可扩展性和可维护性。</li>
<li>面向接口编程：Spring 框架强制使用面向接口的编程方式，使得代码更加灵活、可扩展和可重用。</li>
<li>丰富的模块化组件：Spring 框架提供了丰富的模块化组件，如 Spring MVC、Spring Security、Spring Data 等，使得开发人员可以快速构建复杂的应用程序。</li>
</ol>
<p>缺点：</p>
<ol>
<li>学习曲线较陡峭：Spring 框架虽然轻量级，但是涉及的知识点比较广泛，学习曲线相对较陡峭。</li>
<li>代码复杂性：由于 Spring 框架提供了丰富的组件和功能，导致代码的复杂性增加，代码维护成本相应增加。</li>
<li>运行时开销：由于 Spring 框架需要进行依赖注入和 AOP 处理，导致框架在运行时需要消耗一定的资源和时间。</li>
<li>配置复杂：虽然 Spring 框架提供了很多的默认配置，但是在特定场景下需要进行一定的配置，导致配置文件变得复杂，增加了开发人员的工作量。</li>
</ol>
<p>​		总之，Spring 框架作为一种成熟的Java应用程序框架，优点远大于缺点，可以帮助开发人员快速构建复杂的应用程序。</p>
<h3 id="68-什么是-spring-beans-一个-spring-bean-定义包含什么">
  6.8 什么是 Spring Beans ，一个 Spring Bean 定义包含什么
  <a href="#68-%e4%bb%80%e4%b9%88%e6%98%af-spring-beans-%e4%b8%80%e4%b8%aa-spring-bean-%e5%ae%9a%e4%b9%89%e5%8c%85%e5%90%ab%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Spring 框架中，一个 Bean 是一个由 Spring 容器创建、管理和维护的对象。Spring Bean 的定义通常包括以下内容：</p>
<ol>
<li>类型（Type）：指定 Bean 的 Java 类型。</li>
<li>ID：一个字符串，作为容器中 Bean 的唯一标识符，通过它来查找和访问 Bean。</li>
<li>Scope：定义 Bean 的作用域，包括 Singleton、Prototype、Request、Session、Global Session 等。</li>
<li>Constructor arguments：Bean 实例化时所需的构造器参数。</li>
<li>Properties：Bean 实例化后需要注入的属性。</li>
<li>Autowiring mode：自动装配模式，定义 Spring 容器在注入 Bean 时如何匹配 Bean 依赖。</li>
<li>Lazy initialization mode：懒加载模式，定义 Bean 是否需要在容器启动时实例化。</li>
<li>Initialization method：定义 Bean 实例化后需要执行的初始化方法。</li>
<li>Destruction method：定义 Bean 销毁时需要执行的清理方法。</li>
<li>Bean inheritance：定义 Bean 是否从另一个 Bean 继承定义信息。</li>
</ol>
<p>​		Spring Bean 的定义可以通过 XML 配置文件、Java 配置类或注解方式进行。</p>
<h3 id="69-spring-有几种配置方式配置文件都包含了哪些信息">
  6.9 Spring 有几种配置方式，配置文件都包含了哪些信息
  <a href="#69-spring-%e6%9c%89%e5%87%a0%e7%a7%8d%e9%85%8d%e7%bd%ae%e6%96%b9%e5%bc%8f%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e9%83%bd%e5%8c%85%e5%90%ab%e4%ba%86%e5%93%aa%e4%ba%9b%e4%bf%a1%e6%81%af" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring 有三种配置方式：</p>
<ol>
<li>基于 XML 的配置方式：通过 XML 文件配置 Spring Beans。</li>
<li>基于注解的配置方式：通过 Java 注解配置 Spring Beans。</li>
<li>基于 Java 的配置方式：通过 Java 类配置 Spring Beans。</li>
</ol>
<p>Spring 配置文件主要包含以下信息：</p>
<ol>
<li>Spring Beans 的定义和配置，包括 Bean 的类名、Bean 的属性和依赖关系等信息。</li>
<li>AOP 相关配置，包括切点、通知和拦截器等信息。</li>
<li>数据库和事务相关配置，包括数据库连接池、事务管理器等信息。</li>
<li>Web 相关配置，包括 MVC 配置、拦截器配置等信息。</li>
<li>其他配置，如国际化、缓存等配置信息。</li>
</ol>
<h3 id="610-spring-bean-的作用域">
  6.10 Spring Bean 的作用域
  <a href="#610-spring-bean-%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li>singleton：IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li>prototype：每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li>request：（仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li>session：（仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li>application/global-session：（仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li>websocket：（仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li>
</ul>
<h3 id="611-spring-如何处理线程并发问题">
  6.11 Spring 如何处理线程并发问题
  <a href="#611-spring-%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e7%ba%bf%e7%a8%8b%e5%b9%b6%e5%8f%91%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring 本身并不提供线程并发处理的功能，但是可以通过一些常见的线程并发处理工具来处理。</p>
<ol>
<li>使用 synchronized 关键字控制并发访问：在多线程并发执行时，使用 synchronized 关键字可以让方法或者代码块同步执行，保证数据的一致性。</li>
<li>使用 ReentrantLock 锁：ReentrantLock 是 JDK 自带的一种锁机制，它支持更多的特性，例如可重入、公平锁、可中断等。使用 ReentrantLock 可以解决 synchronized 无法满足的特殊需求。</li>
<li>使用 ConcurrentHashMap：ConcurrentHashMap 是 JDK 自带的一种并发哈希表，它可以在多线程环境下提供安全、高效的访问。ConcurrentHashMap 使用了分段锁技术，不同的线程可以同时访问不同的分段，因此它的并发性能非常好。</li>
<li>使用 Spring 的事务管理功能：Spring 提供了事务管理功能，可以通过配置事务传播机制、隔离级别等参数来解决并发访问时的数据一致性问题。</li>
<li>使用 Spring 提供的并发工具类：Spring 还提供了一些并发工具类，例如 CountDownLatch、CyclicBarrier、Semaphore 等，这些工具类可以帮助开发人员更加方便地实现线程并发控制。</li>
</ol>
<h3 id="612-解释-spring-框架中-bean-的生命周期">
  6.12 解释 Spring 框架中 bean 的生命周期
  <a href="#612-%e8%a7%a3%e9%87%8a-spring-%e6%a1%86%e6%9e%b6%e4%b8%ad-bean-%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Spring 框架中，每个 bean 都有自己的生命周期，Spring 容器在实例化 bean 时，按照以下顺序调用 bean 中的方法：</p>
<ol>
<li>实例化阶段：在实例化 bean 之前，Spring 首先通过构造函数或工厂方法来创建 bean 实例，这个过程称为实例化。在这个过程中，Spring 会调用 bean 的构造函数或工厂方法来创建 bean 实例。</li>
<li>属性赋值阶段：在实例化阶段完成之后，Spring 会将 bean 的属性值注入到 bean 实例中。Spring 支持多种方式来完成属性注入，包括 Setter 方法注入、构造器注入、字段注入等。</li>
<li>初始化阶段：在属性注入完成之后，Spring 会调用 bean 中的初始化方法，这个方法可以是通过实现 InitializingBean 接口来定义的，也可以是通过在 XML 配置文件中定义 init-method 属性来定义的。</li>
<li>使用阶段：在初始化阶段完成之后，Spring 容器会将 bean 实例交给程序使用。</li>
<li>销毁阶段：当容器关闭时，Spring 会调用 bean 的销毁方法，这个方法可以是通过实现 DisposableBean 接口来定义的，也可以是通过在 XML 配置文件中定义 destroy-method 属性来定义的。</li>
</ol>
<p>​		总的来说，Spring 的 bean 生命周期包括以下阶段：实例化、属性赋值、初始化、使用和销毁。在这些阶段中，可以通过编写回调方法来实现对 bean 的控制和自定义处理。</p>
<h3 id="613-aop-是什么aop在项目中如何使用">
  6.13 AOP 是什么（AOP在项目中如何使用）
  <a href="#613-aop-%e6%98%af%e4%bb%80%e4%b9%88aop%e5%9c%a8%e9%a1%b9%e7%9b%ae%e4%b8%ad%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		AOP（Aspect-Oriented Programming，面向切面编程）是一种编程思想和技术，它通过在程序中定义一些横切关注点（crosscutting concerns），将这些关注点独立出来，然后以一种集中的方式进行管理和应用。</p>
<p>​		AOP 主要用来解决：在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复。</p>
<p>AOP 为什么叫面向切面编程：</p>
<ul>
<li>
<p>切 ：指的是横切逻辑，原有业务逻辑代码不动，只能操作横切逻辑代码，所以面向横切逻辑</p>
</li>
<li>
<p>面 ：横切逻辑代码往往要影响的是很多个方法，每个方法如同一个点，多个点构成一个面。这里有一个面的概念</p>
</li>
</ul>
<p>​		在 Spring 框架中，AOP 是一个重要的功能模块，它可以帮助开发者通过拦截器来增强或修改现有的对象或者方法，从而实现一些通用的功能或者业务逻辑。比如日志记录、性能监控、安全控制、事务管理等等。</p>
<p>以下是在 Spring 项目中使用 AOP 的简单步骤：</p>
<ol>
<li>配置 AOP：在 Spring 配置文件中，通过 <code>aop:config</code> 标签启用 AOP，并配置需要被 AOP 拦截的类或方法。</li>
<li>编写切面：在 Java 类中定义切面（Aspect），切面包含了需要在目标方法执行前或执行后执行的方法，这些方法被称为切点（Pointcut）。通常，切面需要实现 <code>org.aspectj.lang.annotation.Aspect</code> 接口。</li>
<li>配置切面：在 Spring 配置文件中，使用 <code>aop:aspect</code> 标签配置切面，包括切点和通知（Advice）。</li>
<li>使用切面：在需要应用切面的方法中，通过 <code>@Autowired</code> 注解注入切面，然后调用方法即可。</li>
</ol>
<p>例如，下面的代码展示了如何使用 AOP 实现一个简单的日志切面：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Aspect</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@Component</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LogAspect</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Pointcut</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;execution(* com.example.demo.service..*(..))&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">serviceLog</span><span style="color:#f92672">()</span> <span style="color:#f92672">{}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Before</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;serviceLog()&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">beforeService</span><span style="color:#f92672">(</span>JoinPoint joinPoint<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        String className <span style="color:#f92672">=</span> joinPoint<span style="color:#f92672">.</span><span style="color:#a6e22e">getTarget</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        String methodName <span style="color:#f92672">=</span> joinPoint<span style="color:#f92672">.</span><span style="color:#a6e22e">getSignature</span><span style="color:#f92672">().</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Calling method &#34;</span> <span style="color:#f92672">+</span> className <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> methodName<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>​		上述代码中，定义了一个 <code>LogAspect</code> 切面，使用 <code>@Aspect</code> 和 <code>@Component</code> 注解将其声明为一个切面。<code>serviceLog()</code> 方法是切点，表示需要拦截的方法。<code>beforeService()</code> 方法是通知，表示在目标方法执行前执行的代码。在 Spring 配置文件中，使用 <code>aop:config</code> 和 <code>aop:aspect</code> 标签配置切面，然后在需要使用切面的方法中，注入 <code>LogAspect</code> 实例，即可完成 AOP 的配置。</p>
<h3 id="614-ioc-是什么ioc在项目中如何使用">
  6.14 IoC 是什么（IoC在项目中如何使用）
  <a href="#614-ioc-%e6%98%af%e4%bb%80%e4%b9%88ioc%e5%9c%a8%e9%a1%b9%e7%9b%ae%e4%b8%ad%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		IoC （Inversion of control ）控制反转/反转控制。它是一种思想不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题。</p>
<p>例如：现有类 A 依赖于类 B</p>
<ul>
<li>传统的开发方式 ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来</li>
<li>使用 IoC 思想的开发方式 ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可。</li>
</ul>
<p>​		从以上两种开发方式的对比来看：我们 “丧失了一个权力” (创建、管理对象的权力)，从而也得到了一个好处（不用再考虑对象的创建、管理等一系列的事情）</p>
<p>​	为什么叫控制反转：</p>
<ul>
<li>
<p>控制 ：指的是对象创建（实例化、管理）的权力</p>
</li>
<li>
<p>反转 ：控制权交给外部环境（Spring 框架、IoC 容器）</p>
</li>
</ul>
<p>​		IoC 和 DI ：IOC（Inverse of Control:控制反转）是一种设计思想 或者说是某种模式。这个设计思想就是 将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。 IoC 在其他语言中也有应用，并非 Spring 特有。IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value）,Map 中存放的是各种对象。</p>
<p>​		IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。</p>
<p>​		在 Spring 框架中，IoC 容器负责创建和管理对象及其依赖关系。下面简单介绍一下在 Spring 项目中如何使用 IoC：</p>
<ol>
<li>
<p>引入 Spring 相关依赖：在 Maven 项目中，需要在 pom.xml 文件中添加 Spring 相关依赖。</p>
</li>
<li>
<p>配置 IoC 容器：在 Spring 项目中，通常使用 XML 文件配置 IoC 容器。在 XML 文件中，可以配置对象的创建、属性注入、依赖关系等信息。</p>
</li>
<li>
<p>声明 Bean：在 XML 文件中，使用 <code>bean</code> 标签来声明一个 Bean。<code>bean</code> 标签中可以配置 Bean 的属性、依赖关系等信息。例如：</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;userService&#34;</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;com.example.UserService&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;property</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;userDao&#34;</span> <span style="color:#a6e22e">ref=</span><span style="color:#e6db74">&#34;userDao&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/bean&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;bean</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;userDao&#34;</span> <span style="color:#a6e22e">class=</span><span style="color:#e6db74">&#34;com.example.UserDao&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span></code></pre></div><p>​		上述代码中，<code>userService</code> 和 <code>userDao</code> 分别表示一个 UserService 和一个 UserDao，其中 <code>userService</code> 中的 <code>userDao</code> 属性是通过依赖注入方式设置的。</p>
<ol start="4">
<li>获取 Bean：在 IoC 容器初始化完成后，可以通过容器获取配置的 Bean。例如：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ApplicationContext context <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ClassPathXmlApplicationContext<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;applicationContext.xml&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>UserService userService <span style="color:#f92672">=</span> context<span style="color:#f92672">.</span><span style="color:#a6e22e">getBean</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;userService&#34;</span><span style="color:#f92672">,</span> UserService<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><p>​		上述代码中，通过 <code>getBean</code> 方法获取了一个 id 为 <code>userService</code> 的 Bean。</p>
<p>​		以上是 Spring 项目中使用 IoC 的基本流程。除了 XML 文件配置外，Spring 还提供了注解配置和 Java 代码配置等方式来配置 IoC 容器。</p>
<h3 id="615-springspring-mvcspring-boot-spring-cloud-之间什么关系">
  6.15 Spring，Spring MVC，Spring Boot ，Spring Cloud 之间什么关系
  <a href="#615-springspring-mvcspring-boot-spring-cloud-%e4%b9%8b%e9%97%b4%e4%bb%80%e4%b9%88%e5%85%b3%e7%b3%bb" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Spring，Spring MVC，Spring Boot 和 Spring Cloud 是 Spring 生态系统中的不同组件。</p>
<p>​		Spring 是一个用于构建企业级应用程序的开源框架，提供了诸如依赖注入、AOP、事务管理等功能。</p>
<p>​		Spring MVC 是 Spring 框架的一个模块，用于构建 Web 应用程序。它基于 MVC 架构模式，提供了 Controller、View 和 Model 三层组件，可用于处理 HTTP 请求和响应。</p>
<p>​		Spring Boot 是基于 Spring 框架的快速开发应用程序的框架，提供了自动配置、嵌入式 Web 服务器、依赖管理等功能，让开发者可以更快速地构建应用程序。</p>
<p>​		Spring Cloud 是 Spring 框架的一个子项目，用于构建分布式应用程序。它提供了服务注册、配置中心、服务发现、负载均衡等功能，让开发者可以更轻松地构建分布式系统。</p>
<p>​		简而言之，Spring 是整个框架，Spring MVC 用于构建 Web 应用程序，Spring Boot 用于快速开发应用程序，Spring Cloud 用于构建分布式应用程序。</p>
<h3 id="616-spring-都有哪些接口">
  6.16 Spring 都有哪些接口
  <a href="#616-spring-%e9%83%bd%e6%9c%89%e5%93%aa%e4%ba%9b%e6%8e%a5%e5%8f%a3" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring 框架中提供了非常多的接口，下面列出其中的一些主要接口：</p>
<ol>
<li>BeanFactory：定义了 IOC 容器最基本的形式，提供了基本的 DI 功能。</li>
<li>ApplicationContext：是 BeanFactory 的子接口，除了 DI 的功能外，还提供了更多企业级应用的功能。</li>
<li>ServletContextAware：实现了该接口的 Bean 可以获得 ServletContext。</li>
<li>BeanPostProcessor：Bean 后置处理器接口，在 Bean 初始化前后进行一些处理工作。</li>
<li>BeanFactoryPostProcessor：在 IOC 容器实例化 Bean 后对 Bean 进行再加工。</li>
<li>InitializingBean：在 Bean 属性设置后调用，相当于 Bean 的初始化方法。</li>
<li>FactoryBean：工厂 Bean，用来产生其他 Bean 实例。</li>
<li>BeanDefinition：定义 Bean 实例的信息。</li>
<li>BeanDefinitionRegistry：BeanDefinition 注册表，定义了 BeanDefinition 的注册规范。</li>
<li>Environment：Spring 环境信息接口，提供了一些方法来获取环境变量、操作系统信息等。</li>
</ol>
<p>​		除此之外，Spring 还有很多其他接口，如 AOP 相关接口、Web 相关接口等。</p>
<h3 id="617-beanfactory-和-applicationcontext-有什么区别">
  6.17 BeanFactory 和 ApplicationContext 有什么区别
  <a href="#617-beanfactory-%e5%92%8c-applicationcontext-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		BeanFactory 和 ApplicationContext 是 Spring 框架中两个重要的容器，它们都用于管理 Bean 对象的创建、销毁和管理，但有以下几点不同：</p>
<ol>
<li>BeanFactory 是 Spring 框架中最基础的容器，它主要实现了对 Bean 对象的基本管理功能，如对象的创建、初始化、销毁等，而 ApplicationContext 在 BeanFactory 的基础上进行了扩展，增加了许多实用的功能，如国际化处理、资源访问、事件传递、AOP 支持等。</li>
<li>BeanFactory 是懒加载，只有当获取 Bean 对象时才会进行创建，而 ApplicationContext 是提前初始化所有的单例 Bean。</li>
<li>ApplicationContext 支持更多的 Bean 生命周期扩展点，如支持 Bean 的后置处理器、Bean 的自动装配、Bean 的事件机制等。</li>
<li>ApplicationContext 是 BeanFactory 的子接口，提供了更多的高级功能，如 AOP、事务管理、消息处理等。</li>
</ol>
<p>​		综上所述，ApplicationContext 功能更强大，扩展性更好，而 BeanFactory 则更轻量级。因此在实际开发中，一般优先选择使用 ApplicationContext。</p>
<h3 id="618-applicationcontext-通常的实现是什么">
  6.18 ApplicationContext 通常的实现是什么
  <a href="#618-applicationcontext-%e9%80%9a%e5%b8%b8%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>ApplicationContext 的通常实现有以下几种：</p>
<ol>
<li>ClassPathXmlApplicationContext：从类路径下的 XML 配置文件中加载上下文定义，适用于以单个 jar 包或 war 包形式部署的应用；</li>
<li>FileSystemXmlApplicationContext：从文件系统中的 XML 配置文件中加载上下文定义，适用于非 Web 应用的独立应用程序；</li>
<li>AnnotationConfigApplicationContext：从 Java 配置类中加载上下文定义，适用于基于 Java 注解的应用程序；</li>
<li>XmlWebApplicationContext：从 Web 应用的 XML 配置文件中加载上下文定义，适用于基于 Web 的应用程序；</li>
<li>AnnotationConfigWebApplicationContext：从基于 Web 的 Java 注解中加载上下文定义，适用于基于 Web 和 Java 注解的应用程序。</li>
</ol>
<p>​		ApplicationContext 是一个接口，它的实现类可以根据不同的情况选择使用不同的实现方式。</p>
<h3 id="619-spring-怎样开启注解装配">
  6.19 Spring 怎样开启注解装配
  <a href="#619-spring-%e6%80%8e%e6%a0%b7%e5%bc%80%e5%90%af%e6%b3%a8%e8%a7%a3%e8%a3%85%e9%85%8d" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		要开启 Spring 的注解装配功能，需要在 Spring 配置文件中添加 <code>&lt;context:annotation-config/&gt;</code> 或 <code>&lt;context:component-scan base-package=&quot;包名&quot;/&gt;</code>，它们的作用如下：</p>
<ul>
<li><code>&lt;context:annotation-config/&gt;</code>：启用注解驱动的 Bean 容器，告诉 Spring 自动扫描配置文件中所有的注解。</li>
<li><code>&lt;context:component-scan base-package=&quot;包名&quot;/&gt;</code>：启用注解扫描功能，Spring 会自动扫描指定包及其子包下的所有类，查找被 Spring 支持的注解。</li>
</ul>
<p>​		这样，Spring 在启动时就会扫描配置文件中的注解，并创建对应的 Bean，并进行依赖注入，从而简化了 Spring 的配置和开发。</p>
<h3 id="620-spring-都有哪些注解分别都有哪些作用">
  6.20 Spring 都有哪些注解，分别都有哪些作用
  <a href="#620-spring-%e9%83%bd%e6%9c%89%e5%93%aa%e4%ba%9b%e6%b3%a8%e8%a7%a3%e5%88%86%e5%88%ab%e9%83%bd%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bd%9c%e7%94%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring 框架中包含了很多注解，下面列出一些常用的注解及其作用：</p>
<ol>
<li><code>@Autowired</code>: 自动装配，根据类型进行装配，可以放在属性、构造器、方法上使用；</li>
<li><code>@Resource</code>：自动装配，通过名称匹配来注入对应的 Bean 实例；</li>
<li><code>@Component</code>: 标注该类为组件类，自动被 Spring 扫描并进行管理；</li>
<li><code>@Controller</code>: 标注该类为 MVC 控制器；</li>
<li><code>@Service</code>: 标注该类为服务类；</li>
<li><code>@Repository</code>: 标注该类为数据访问对象；</li>
<li><code>@Configuration</code>: 标注该类为配置类；</li>
<li><code>@Bean</code>: 标注该方法为创建对象的方法，返回值为对象实例；</li>
<li><code>@Value</code>: 注入简单类型属性；</li>
<li><code>@Qualifier</code>: 根据名称进行装配；</li>
<li><code>@Scope</code>: 设置对象作用域；</li>
<li><code>@Transactional</code>: 事务注解；</li>
<li><code>@RequestBody</code>：用于接收 HTTP 请求体中的数据。</li>
<li><code>@ResponseBody</code>：用于将返回值作为 HTTP 响应体返回。</li>
<li><code>@RequestMapping</code>：用于映射请求路径和处理器方法。</li>
<li><code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>：用于指定不同的 HTTP 请求类型。</li>
<li><code>@PathVariable</code>: 获取 URL 中的参数</li>
<li><code>@ExceptionHandler</code>: 异常处理器；</li>
<li><code>@PostConstruct</code>: 初始化方法；</li>
<li><code>@PreDestroy</code>: 销毁方法；</li>
<li><code>@Async</code>: 异步方法；</li>
<li><code>@Transactional</code>：用于事务管理。</li>
</ol>
<p>注解的作用主要是简化配置，提高开发效率，使代码更加简洁、清晰。</p>
<h3 id="621-autowired-和-resource-的区别是什么">
  6.21 @Autowired 和 @Resource 的区别是什么
  <a href="#621-autowired-%e5%92%8c-resource-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li>
<li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li>
<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</li>
</ul>
<h3 id="622-required-注解有什么作用">
  6.22 @Required 注解有什么作用
  <a href="#622-required-%e6%b3%a8%e8%a7%a3%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		<code>@Required</code> 是 Spring 框架中的注解之一，用于标记 bean 属性的 setter 方法，表示这个属性必须被设置，否则在容器启动时会抛出 BeanInitializationException 异常。</p>
<p>​		当一个 bean 的某个属性被标记为 <code>@Required</code> 后，Spring 容器会确保这个属性在容器启动时已经被设置，否则就会抛出异常。这可以避免在运行时由于缺失必要的属性而导致的错误。</p>
<p>​		使用 <code>@Required</code> 注解的好处是，在 bean 的属性增加或改变时，能够立即发现是否有属性未被设置。这可以帮助我们在开发和调试过程中快速识别问题，并减少由于未初始化属性而引起的异常。</p>
<h3 id="623-spring-事务中的隔离级别">
  6.23 Spring 事务中的隔离级别
  <a href="#623-spring-%e4%ba%8b%e5%8a%a1%e4%b8%ad%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Spring 事务中，定义了四种事务隔离级别，分别为：</p>
<ol>
<li>读未提交（Read Uncommitted）：最低的隔离级别，它允许一个事务读取另一个事务还未提交的数据。这种隔离级别会导致脏读、不可重复读和幻读问题。</li>
<li>读已提交（Read Committed）：该级别要求一个事务只能读取另一个事务已经提交的数据。这种隔离级别可以解决脏读问题，但是可能出现不可重复读和幻读问题。</li>
<li>可重复读（Repeatable Read）：要求在一个事务中多次读取同样的记录的结果都是一致的。这种隔离级别可以解决脏读和不可重复读问题，但是可能出现幻读问题。</li>
<li>串行化（Serializable）：最高的隔离级别，它要求事务串行执行，避免了幻读问题。但是由于事务是串行执行的，因此效率较低，一般不推荐使用。</li>
</ol>
<p>​		以上四种隔离级别的安全性依次提高，但是并发性能也依次降低。因此，在选择隔离级别时需要根据业务需求权衡安全性和并发性能。在 Spring 中，默认的隔离级别为读已提交。</p>
<h3 id="624-spring-事务中的事务传播行为">
  6.24 Spring 事务中的事务传播行为
  <a href="#624-spring-%e4%ba%8b%e5%8a%a1%e4%b8%ad%e7%9a%84%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e8%a1%8c%e4%b8%ba" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Spring 事务中，事务传播行为是指当一个方法已经在一个具有事务的上下文中运行时，另一个方法被调用时如何处理事务的传播。</p>
<p>Spring 支持如下 7 种事务传播行为：</p>
<ol>
<li>REQUIRED：如果当前没有事务，就新建一个事务。如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</li>
<li>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
<li>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常。</li>
<li>REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 REQUIRED 类似的操作。</li>
</ol>
<p>​		这些传播行为可以在 @Transactional 注解中指定，默认的传播行为是 REQUIRED。选择合适的传播行为有助于优化应用程序的性能和正确性，避免因事务处理错误而导致的数据一致性问题。</p>
<h3 id="625-spring-事务失效的场景">
  6.25 Spring 事务失效的场景
  <a href="#625-spring-%e4%ba%8b%e5%8a%a1%e5%a4%b1%e6%95%88%e7%9a%84%e5%9c%ba%e6%99%af" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring 事务失效的场景主要包括以下几个方面：</p>
<ol>
<li>不是通过代理对象调用方法：Spring 的事务是通过 AOP 的方式实现的，只有通过代理对象调用的方法才会被 Spring 事务管理器拦截并开启事务。如果直接通过 <code>this</code> 调用方法，那么事务是不会生效的。</li>
<li>方法未被 public 修饰：Spring 的事务是通过代理对象实现的，因此被事务管理器拦截的方法必须是 public 修饰的，否则代理对象无法调用。</li>
<li>异常被 catch：Spring 的事务默认只有在抛出 <code>RuntimeException</code> 和 <code>Error</code> 类型的异常时才会回滚事务。如果在方法中使用 try-catch 捕获了异常并处理了，那么 Spring 事务管理器就无法感知到异常，也就无法回滚事务。</li>
<li>事务方法中调用了没有被 Spring 管理的方法：如果在事务方法中调用了另一个没有被 Spring 管理的方法，那么该方法的操作将独立于事务之外，因此事务也就失效了。</li>
<li>多个事务方法之间相互调用：如果多个事务方法之间相互调用，那么 Spring 的事务管理器会在每个事务方法中开启一个独立的事务，这样就会导致事务失效。</li>
<li>嵌套事务：Spring 中的事务支持嵌套事务，也就是一个事务方法中调用另一个事务方法。但是嵌套事务的失效场景与普通事务类似，如果嵌套事务未被正确使用，也会导致事务失效。</li>
</ol>
<h3 id="626-spring-框架的事务管理有哪些优点">
  6.26 Spring 框架的事务管理有哪些优点？
  <a href="#626-spring-%e6%a1%86%e6%9e%b6%e7%9a%84%e4%ba%8b%e5%8a%a1%e7%ae%a1%e7%90%86%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bc%98%e7%82%b9" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring框架的事务管理有以下优点：</p>
<ol>
<li>声明式事务管理：Spring通过使用AOP技术，在代码中声明事务性操作，而不是通过编程的方式在代码中嵌入事务管理代码。这样做使得业务逻辑与事务管理分离，使得代码更加简洁易懂，减少了重复代码。</li>
<li>多种事务管理策略：Spring支持多种事务管理策略，包括本地事务、分布式事务等，用户可以根据具体需求选择适合的事务管理策略。</li>
<li>支持多种数据访问方式：Spring框架对多种数据访问技术提供了支持，包括JDBC、Hibernate、MyBatis等，这使得在不同的数据访问技术之间切换变得更加容易。</li>
<li>可扩展性好：Spring的事务管理是基于AOP技术实现的，所以可以很方便地进行扩展，满足不同场景的需求。</li>
<li>提供了完整的异常处理机制：在使用Spring的事务管理时，发生异常会触发事务回滚，保证了数据的一致性和完整性。同时，Spring提供了完整的异常处理机制，可以捕获并处理异常，使得代码更加健壮。</li>
</ol>
<h3 id="627-解释一下-spring-aop-里面的几个名词">
  6.27 解释一下 Spring AOP 里面的几个名词
  <a href="#627-%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8b-spring-aop-%e9%87%8c%e9%9d%a2%e7%9a%84%e5%87%a0%e4%b8%aa%e5%90%8d%e8%af%8d" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Spring AOP 中，有以下几个名词：</p>
<ol>
<li>切面（Aspect）：一个切面是一个横切关注点的模块化，这个关注点可能会影响到应用程序的多个类及其函数。在 Spring AOP 中，切面可以由切点和通知组成。</li>
<li>切点（Pointcut）：一个切点是一个或者多个连接点的集合，通知可以被应用到这些连接点上。可以使用表达式或者注解定义切点。</li>
<li>通知（Advice）：通知定义了在切点处执行的动作。在 Spring AOP 中，通知类型包括前置通知、后置通知、环绕通知、异常通知和最终通知。</li>
<li>连接点（Join point）：连接点是指在应用程序执行过程中能够插入切面的一个点，这个点可以是调用方法时、抛出异常时等等。</li>
<li>织入（Weaving）：织入是将切面应用到目标对象并创建新的代理对象的过程。</li>
</ol>
<p>​		综上所述，Spring AOP 提供了一种可重用的方式来解决跨越多个类的横切关注点问题，通过定义切面、切点、通知、连接点等元素，使得开发人员可以更加方便地实现横切关注点的功能。</p>
<h3 id="628-什么是-spring-mvcspring-mvc-的优点">
  6.28 什么是 Spring MVC，Spring MVC 的优点
  <a href="#628-%e4%bb%80%e4%b9%88%e6%98%af-spring-mvcspring-mvc-%e7%9a%84%e4%bc%98%e7%82%b9" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Spring MVC 是一种基于 Java 的 MVC（模型-视图-控制器）框架，它是 Spring Framework 的一部分，可以用来构建 Web 应用程序。</p>
<p>Spring MVC 的优点包括：</p>
<ol>
<li>灵活性：Spring MVC 提供了很多配置选项和扩展点，使得开发人员可以根据自己的需要进行灵活的配置和扩展。</li>
<li>易于测试：Spring MVC 的代码结构清晰，容易进行单元测试和集成测试，同时也支持很多测试工具，如 MockMvc、Mockito 等。</li>
<li>松耦合：Spring MVC 采用松耦合的设计思想，将控制器、模型和视图分离，使得系统的各个组件之间解耦，便于维护和升级。</li>
<li>高度可定制化：Spring MVC 可以通过配置和扩展来实现高度可定制化，可以根据具体需求定制自己的 MVC 框架。</li>
<li>支持 RESTful：Spring MVC 对 RESTful 架构提供了很好的支持，可以方便地创建 RESTful Web 服务。</li>
<li>社区活跃：Spring MVC 是一个开源项目，拥有一个庞大的社区和活跃的开发者，可以提供很好的技术支持和文档资料。</li>
</ol>
<h3 id="629-spring-mvc-的主要组件">
  6.29 Spring MVC 的主要组件
  <a href="#629-spring-mvc-%e7%9a%84%e4%b8%bb%e8%a6%81%e7%bb%84%e4%bb%b6" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring MVC 是一个基于 MVC 设计模式的 Web 框架，其主要组件包括：</p>
<ol>
<li>DispatcherServlet：前置控制器，接收客户端的请求并将请求转发给对应的处理器。</li>
<li>HandlerMapping：负责将请求映射到对应的处理器。</li>
<li>HandlerAdapter：负责将请求分发给对应的处理器进行处理。</li>
<li>ViewResolver：负责将处理器处理后的结果视图解析成实际的视图。</li>
<li>View：负责渲染处理器处理后的结果，并将渲染后的结果返回给客户端。</li>
<li>Model：数据模型，负责封装数据并传递给视图渲染。</li>
<li>HandlerInterceptor：拦截器，可以在请求处理前后进行一些额外的处理。</li>
<li>ExceptionResolver：异常处理器，负责处理应用程序中出现的异常，并将异常转化为对应的错误信息。</li>
<li>LocaleResolver：国际化解析器，负责解析客户端请求中的语言信息，并将语言信息传递给应用程序。</li>
<li>ThemeResolver：主题解析器，负责解析客户端请求中的主题信息，并将主题信息传递给应用程序。</li>
</ol>
<h3 id="630-请描述-spring-mvc-的工作流程描述一下-dispatcherservlet-的工作流程">
  6.30 请描述 Spring MVC 的工作流程，描述一下 DispatcherServlet 的工作流程
  <a href="#630-%e8%af%b7%e6%8f%8f%e8%bf%b0-spring-mvc-%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b%e6%8f%8f%e8%bf%b0%e4%b8%80%e4%b8%8b-dispatcherservlet-%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Spring MVC 是一个基于 MVC（Model-View-Controller）设计模式的 Web 框架，它提供了一种灵活的方式来创建 Web 应用程序。</p>
<p>Spring MVC 的工作流程如下：</p>
<ol>
<li>当客户端发送一个请求到 DispatcherServlet 时，DispatcherServlet 会拦截这个请求并根据请求 URL 查找对应的 Controller。</li>
<li>Controller 接收到请求后会调用相应的 Service 进行业务逻辑处理。</li>
<li>Service 处理完业务逻辑后会返回数据给 Controller。</li>
<li>Controller 将返回的数据传递给 View，View 使用模板引擎生成响应内容。</li>
<li>DispatcherServlet 将生成的响应内容发送回客户端。</li>
</ol>
<p>​		在 Spring MVC 中，DispatcherServlet 是前置控制器，它是 Spring MVC 框架的核心组件之一，负责接收所有的请求，并将请求分发到相应的处理程序。</p>
<p>DispatcherServlet 的工作流程如下：</p>
<ol>
<li>当客户端发送一个请求时，请求首先被服务器接收，并将其传递给 DispatcherServlet。</li>
<li>DispatcherServlet 根据请求的 URL 选择一个或多个 HandlerMapping，根据 URL 映射到相应的 Controller。</li>
<li>Controller 进行处理请求并返回 ModelAndView 对象。ModelAndView 包含模型数据和指向视图的逻辑名称。</li>
<li>DispatcherServlet 将 ModelAndView 传递给 ViewResolver，ViewResolver 根据逻辑视图名解析视图对象。</li>
<li>最终将 ModelAndView 中的模型数据填充到视图中，并响应给客户端。</li>
</ol>
<p>总体来说，DispatcherServlet 的作用是将请求分派到不同的组件，这些组件在整个处理流程中协同工作，最终将请求处理并返回给客户端。</p>
<h3 id="631-spring-mvc-常用的注解有哪些注解原理是什么">
  6.31 Spring MVC 常用的注解有哪些，注解原理是什么
  <a href="#631-spring-mvc-%e5%b8%b8%e7%94%a8%e7%9a%84%e6%b3%a8%e8%a7%a3%e6%9c%89%e5%93%aa%e4%ba%9b%e6%b3%a8%e8%a7%a3%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring MVC 常用的注解有以下几种：</p>
<ol>
<li><code>@Controller</code>: 用于标识一个类是 Spring MVC 中的控制器，处理 HTTP 请求。</li>
<li><code>@RequestMapping</code>: 用于标识一个请求处理方法的 URL 路径。</li>
<li><code>@RequestParam</code>: 用于将请求参数绑定到方法的参数上。</li>
<li><code>@PathVariable</code>: 用于将 URL 中的占位符参数绑定到方法的参数上。</li>
<li><code>@ResponseBody</code>: 用于将方法返回值转换成 JSON 或 XML 等格式的响应体。</li>
<li><code>@ModelAttribute</code>: 用于将请求参数绑定到模型对象上，或者将模型对象传递到视图中。</li>
<li><code>@SessionAttributes</code>: 用于指定模型对象的某些属性需要放到会话中。</li>
</ol>
<p>​		注解的原理是基于 Spring 框架中的 AOP（面向切面编程）实现的。通过 AOP，Spring MVC 拦截 HTTP 请求，并将请求转发到相应的处理方法上。在处理方法的执行过程中，Spring MVC 通过注解的方式获取请求参数，并将方法返回值封装成响应对象。最终将响应对象转换成 HTTP 响应，并返回给客户端。</p>
<p>​		这种基于注解的开发方式，相比于传统的 XML 配置方式，更加简洁、灵活，能够提高开发效率和可读性。</p>
<h3 id="632-spring-mvc-怎样设定重定向和转发的">
  6.32 Spring MVC 怎样设定重定向和转发的
  <a href="#632-spring-mvc-%e6%80%8e%e6%a0%b7%e8%ae%be%e5%ae%9a%e9%87%8d%e5%ae%9a%e5%90%91%e5%92%8c%e8%bd%ac%e5%8f%91%e7%9a%84" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Spring MVC 中，重定向和转发可以通过不同的方式来设置。</p>
<ol>
<li>重定向：</li>
</ol>
<p>​		重定向是通过设置响应头来实现的，可以使用 Spring MVC 的 <code>RedirectView</code> 或者直接返回字符串 &ldquo;redirect:&rdquo; 或 &ldquo;redirect:/xxx&rdquo; 实现重定向。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@GetMapping</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/redirect&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">redirect</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;redirect:/index&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>​		这里将会重定向到 <code>/index</code> 请求地址。</p>
<ol start="2">
<li>转发：</li>
</ol>
<p>​		转发是通过 <code>HttpServletRequest</code> 的 <code>forward()</code> 方法来实现的，或者直接返回字符串 &ldquo;forward:&rdquo; 或 &ldquo;forward:/xxx&rdquo; 实现转发。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@GetMapping</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/forward&#34;</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">forward</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;forward:/index&#34;</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>​		这里将会转发到 <code>/index</code> 请求地址。</p>
<p>​		需要注意的是，重定向和转发的区别在于重定向会返回一个新的请求，而转发则是在服务器内部进行请求的转发，因此两者的行为是不同的。</p>
<h3 id="633-如何解决-post-请求中文乱码问题get-的又如何处理呢">
  6.33 如何解决 POST 请求中文乱码问题，GET 的又如何处理呢
  <a href="#633-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3-post-%e8%af%b7%e6%b1%82%e4%b8%ad%e6%96%87%e4%b9%b1%e7%a0%81%e9%97%ae%e9%a2%98get-%e7%9a%84%e5%8f%88%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e5%91%a2" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Spring MVC 中，可以通过设置字符编码来解决 POST 请求中文乱码问题。具体做法是在 Controller 中对请求参数进行编码设置，例如使用 <code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code> 设置请求编码为 UTF-8。</p>
<p>​		对于 GET 请求，可以在请求 URL 中使用 URL 编码对中文进行编码。例如，将中文参数“中国”编码为“%E4%B8%AD%E5%9B%BD”，然后将其拼接到 URL 后面，如“<a href="http://example.com/test?param=%E4%B8%AD%E5%9B%BD%E2%80%9D%E3%80%82">http://example.com/test?param=%E4%B8%AD%E5%9B%BD”。</a> 在 Spring MVC 中，可以通过 <code>@RequestParam</code> 注解指定请求参数，并使用 <code>value</code> 属性指定参数名，例如 <code>@RequestParam(value = &quot;param&quot;) String param</code>，Spring MVC 会自动将 URL 编码后的参数值解码为字符串类型的参数值。</p>
<h3 id="634-介绍下-spring-mvc-里面的拦截器">
  6.34 介绍下 Spring MVC 里面的拦截器
  <a href="#634-%e4%bb%8b%e7%bb%8d%e4%b8%8b-spring-mvc-%e9%87%8c%e9%9d%a2%e7%9a%84%e6%8b%a6%e6%88%aa%e5%99%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Spring MVC 中，拦截器（Interceptor）是一种处理器（Handler）的机制。拦截器可以在处理器执行前、执行中和执行后进行拦截和处理，它可以对请求和响应进行处理，例如：校验用户权限、记录请求日志、记录请求参数、记录响应日志等等。</p>
<p>在 Spring MVC 中，拦截器主要有两种实现方式：</p>
<ol>
<li>实现 HandlerInterceptor 接口： HandlerInterceptor 接口是 Spring MVC 提供的拦截器接口，它定义了在请求处理程序执行之前、之后和之后拦截请求的方法。</li>
<li>继承 HandlerInterceptorAdapter 类： HandlerInterceptorAdapter 类是 HandlerInterceptor 接口的适配器实现，它提供了空的方法体，使得开发人员可以只实现需要的拦截器方法，避免不必要的代码实现。</li>
</ol>
<p>​		拦截器的执行顺序可以通过实现 Ordered 接口来指定，也可以通过在拦截器方法上使用 @Order 注解来指定。</p>
<p>​		拦截器可以在 Spring MVC 配置文件中通过 <!-- raw HTML omitted -->mvc:interceptors<!-- raw HTML omitted --> 标签进行配置，也可以通过 Java 配置方式进行配置。配置的拦截器会按照顺序依次执行，直到最后一个拦截器执行完成后，才会执行请求处理器。</p>
<p>​		拦截器可以对请求进行拦截，并进行预处理，也可以对响应进行拦截，并进行后处理，但是不能对请求和响应进行修改。如果需要对请求和响应进行修改，可以使用过滤器（Filter）来处理。</p>
<h3 id="635-什么是-spring-boot为什么要用-spring-bootspring-boot-与-spring-cloud-区别">
  6.35 什么是 Spring Boot，为什么要用 Spring Boot，Spring Boot 与 Spring Cloud 区别
  <a href="#635-%e4%bb%80%e4%b9%88%e6%98%af-spring-boot%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-spring-bootspring-boot-%e4%b8%8e-spring-cloud-%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Spring Boot 是一个基于 Spring 框架的快速开发框架，提供了一种快速创建 Spring 应用的方式，使得 Spring 应用的开发、部署变得更加简单、快速、便捷。Spring Boot 的目标是简化 Spring 应用的开发，同时提供嵌入式服务器、自动化配置等功能。</p>
<p>使用 Spring Boot 的优点包括：</p>
<ol>
<li>简化配置：Spring Boot 提供了自动配置的功能，通过少量的配置即可构建一个可运行的应用程序。</li>
<li>快速开发：Spring Boot 提供了许多开箱即用的功能，如嵌入式服务器、安全性、数据库访问等，使得开发过程更加快速高效。</li>
<li>易于部署：Spring Boot 应用程序可以直接打包为 jar 包，方便部署到云平台等各种环境。</li>
</ol>
<p>Spring Boot 与 Spring Cloud 的区别在于：</p>
<ol>
<li>Spring Boot 解决的是如何快速开发一个独立的 Spring 应用程序，而 Spring Cloud 则是为构建分布式系统提供了一整套的解决方案。</li>
<li>Spring Boot 侧重于提供可快速开发、简化配置的方式，而 Spring Cloud 则提供了各种服务治理、服务注册、配置中心等分布式系统的解决方案，包括 Netflix Eureka、Spring Cloud Config、Spring Cloud Bus 等。</li>
<li>Spring Cloud 基于 Spring Boot，因此 Spring Boot 和 Spring Cloud 都是使用 Spring Framework 构建的。</li>
</ol>
<h3 id="636-spring-boot-有哪些优点运行-spring-boot-有哪几种方式">
  6.36 Spring Boot 有哪些优点，运行 Spring Boot 有哪几种方式
  <a href="#636-spring-boot-%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bc%98%e7%82%b9%e8%bf%90%e8%a1%8c-spring-boot-%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e6%96%b9%e5%bc%8f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring Boot 具有以下优点：</p>
<ol>
<li>快速开发：Spring Boot 提供了快速应用程序开发的能力，自动配置和内嵌服务器等特性可以帮助开发者快速创建应用程序并快速进行开发。</li>
<li>简化配置：Spring Boot 提供了自动配置和约定优于配置的方式，通过这种方式可以大大简化应用程序的配置。</li>
<li>集成丰富：Spring Boot 集成了大量的第三方框架和库，这些集成使得开发者可以使用这些库而无需进行额外的配置。</li>
<li>易于部署：Spring Boot 应用程序可以以多种方式部署，包括将应用程序打包成 jar 或 war 文件，也可以将应用程序部署到云平台。</li>
<li>易于测试：Spring Boot 提供了易于使用的测试框架，可以帮助开发者轻松编写和运行测试。</li>
<li>微服务支持：Spring Boot 支持构建微服务应用程序，使用 Spring Boot 可以轻松构建基于微服务的应用程序。</li>
</ol>
<p>运行 Spring Boot 有以下几种方式：</p>
<ol>
<li>在 IDE 中运行：可以直接在集成开发环境（IDE）中运行 Spring Boot 应用程序。在 IDE 中运行可以更方便地调试和测试应用程序。</li>
<li>使用 Maven 或 Gradle 运行：可以使用 Maven 或 Gradle 命令来运行 Spring Boot 应用程序。可以使用 <code>mvn spring-boot:run</code> 或 <code>gradle bootRun</code> 命令在命令行中运行应用程序。</li>
<li>打包为可执行 Jar 包：Spring Boot 应用程序可以打包为可执行 Jar 包，并使用 <code>java -jar</code> 命令来运行。</li>
<li>使用 Docker 运行：可以将 Spring Boot 应用程序打包为 Docker 镜像，并在 Docker 容器中运行。使用 Docker 运行可以更方便地部署和管理应用程序。</li>
</ol>
<h3 id="637-spring-boot-的注解有哪些">
  6.37 Spring Boot 的注解有哪些
  <a href="#637-spring-boot-%e7%9a%84%e6%b3%a8%e8%a7%a3%e6%9c%89%e5%93%aa%e4%ba%9b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring Boot 提供了很多注解，以下是其中一些常用的注解：</p>
<ol>
<li>@SpringBootApplication：这是一个组合注解，用于标记一个主要的 Spring Boot 应用程序类，其中包含了自动配置、组件扫描和属性源等注解。</li>
<li>@RestController：用于标记一个类，表示该类的所有方法都是用来处理 HTTP 请求的 RESTful API。</li>
<li>@GetMapping、@PostMapping、@PutMapping、@DeleteMapping：这些注解分别用于处理 HTTP GET、POST、PUT、DELETE 请求。</li>
<li>@Autowired：自动装配 Bean，省去手动配置的过程。</li>
<li>@Value：用于获取属性配置文件中的值。</li>
<li>@ConfigurationProperties：将属性配置文件中的值与 Bean 绑定。</li>
<li>@ComponentScan：用于扫描组件，自动注册 Bean。</li>
<li>@ConditionalOnXXX：条件注解，用于指定某些条件满足时才进行某些操作，如 @ConditionalOnClass、@ConditionalOnBean 等。</li>
<li>@EnableXXX：用于开启某些功能，如 @EnableAutoConfiguration、@EnableScheduling 等。</li>
<li>@Scheduled：用于指定定时任务，类似于 Quartz。</li>
</ol>
<p>​		以上注解只是一部分，Spring Boot 还提供了很多其他注解，不同的注解用于不同的场景和目的。</p>
<h3 id="638-运行-spring-boot-有哪几种方式开启-spring-boot-特性有哪几种方式">
  6.38 运行 Spring Boot 有哪几种方式，开启 Spring Boot 特性有哪几种方式
  <a href="#638-%e8%bf%90%e8%a1%8c-spring-boot-%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e6%96%b9%e5%bc%8f%e5%bc%80%e5%90%af-spring-boot-%e7%89%b9%e6%80%a7%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e6%96%b9%e5%bc%8f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>运行 Spring Boot 有以下几种方式：</p>
<ol>
<li>通过 <code>main</code> 方法运行：在 IDE 中运行包含 <code>main</code> 方法的类，例如使用 <code>SpringApplication.run(Application.class, args)</code> 启动 Spring Boot 应用。</li>
<li>使用 <code>mvn spring-boot:run</code> 命令运行：在项目根目录下运行该命令，会自动编译和启动 Spring Boot 应用。</li>
<li>打包成可执行的 jar 包并运行：使用 <code>mvn clean package</code> 命令将项目打包成可执行的 jar 包，然后使用 <code>java -jar xxx.jar</code> 命令运行。</li>
</ol>
<p>开启 Spring Boot 特性有以下几种方式：</p>
<ol>
<li>在配置文件中设置属性：可以在 <code>application.properties</code> 或 <code>application.yml</code> 文件中设置属性来开启 Spring Boot 的特性，例如开启开发者工具的自动重启功能可以设置 <code>spring.devtools.restart.enabled=true</code>。</li>
<li>在 Maven 或 Gradle 的依赖中加入相应的库：Spring Boot 提供了很多库来实现各种特性，例如开启 Actuator 可以加入 <code>spring-boot-starter-actuator</code> 库。</li>
<li>自定义配置类或 Bean：通过自定义配置类或 Bean 来实现特定的功能，例如通过实现 <code>WebMvcConfigurer</code> 接口来配置 MVC 相关的功能，或者通过自定义 Bean 来配置特定的组件。</li>
</ol>
<h3 id="639--什么是-java-config">
  6.39  什么是 Java Config
  <a href="#639--%e4%bb%80%e4%b9%88%e6%98%af-java-config" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Java Config 是指使用纯 Java 代码来替代 XML 文件进行 Spring 配置的一种方式。通常使用 <code>@Configuration</code> 注解来声明一个配置类，然后使用 <code>@Bean</code> 注解来声明一个 Bean。这种方式的好处是可以避免 XML 配置文件的复杂性，提供了更加灵活、类型安全的配置方式。此外，Java Config 还支持自动化配置和条件化配置等高级特性。</p>
<h3 id="640--spring-boot-的自动配置原理是什么">
  6.40  Spring Boot 的自动配置原理是什么
  <a href="#640--spring-boot-%e7%9a%84%e8%87%aa%e5%8a%a8%e9%85%8d%e7%bd%ae%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Spring Boot 的自动配置原理是基于 Spring Framework 的条件化配置（Conditional Configuration）机制实现的。</p>
<p>​		在 Spring Boot 中，使用了大量的 Starter POM 来提供对各种应用场景的支持，每个 Starter POM 中都包含了一组自动配置类（Auto-configuration），这些自动配置类根据不同的条件进行条件化的自动配置，为我们提供了默认的配置。当 Spring Boot 应用启动时，会根据所引入的 Starter POM 以及应用自身的配置，来决定应用使用哪些自动配置类。如果我们需要定制应用的配置，只需要在应用中定义自己的配置类，使用注解 <code>@Configuration</code>、<code>@Bean</code> 等对应用进行配置即可。</p>
<p>​		自动配置类中的配置内容，通常是以 <code>@ConditionalOn...</code> 等条件注解为前缀的注解，这些注解表示只有在满足某些条件的情况下才会进行自动配置。这些条件通常包括：是否存在某些类、是否存在某些配置、是否启用某些属性等等。通过这些条件的判断，可以让 Spring Boot 自动配置机制具有很强的灵活性和可扩展性。</p>
<p>​		总的来说，Spring Boot 的自动配置机制可以帮助我们快速构建应用，大大减少了应用的配置工作，提升了开发效率。同时，自动配置机制的灵活性和可扩展性，也为我们提供了很好的扩展性和定制性，可以根据具体需求对应用进行定制化的配置。</p>
<h3 id="641-如何理解-spring-boot-配置加载顺序">
  6.41 如何理解 Spring Boot 配置加载顺序
  <a href="#641-%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3-spring-boot-%e9%85%8d%e7%bd%ae%e5%8a%a0%e8%bd%bd%e9%a1%ba%e5%ba%8f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Spring Boot 中，配置加载顺序是指 Spring Boot 在启动时，从不同的地方加载配置文件，并根据一定的优先级顺序进行配置的覆盖和合并。Spring Boot 的配置加载顺序一般可以分为以下几个步骤：</p>
<ol>
<li>命令行参数配置：Spring Boot 可以通过命令行参数进行配置，例如 <code>java -jar myproject.jar --server.port=8080</code> 可以在启动时指定应用的端口号为 8080。</li>
<li><code>application.properties</code> 和 <code>application.yml</code> 文件：Spring Boot 会加载 <code>application.properties</code> 或 <code>application.yml</code> 文件，这些文件通常位于项目的 <code>classpath</code> 路径下或者 <code>config</code> 目录下，用于配置应用程序的各种属性。</li>
<li>环境变量配置：Spring Boot 可以从系统环境变量或操作系统属性中获取配置，例如 <code>$JAVA_HOME</code> 环境变量可以设置 JDK 的安装路径。</li>
<li><code>SpringApplication.setDefaultProperties()</code> 方法：开发人员可以使用 <code>SpringApplication.setDefaultProperties()</code> 方法设置默认的配置属性，这些属性可以被应用程序的其他配置所覆盖。</li>
<li>配置类：开发人员可以使用 <code>@ConfigurationProperties</code> 注解创建配置类，这些类中的属性可以与 <code>application.properties</code> 或 <code>application.yml</code> 文件中的属性相匹配，以实现自动绑定。</li>
<li><code>@Value</code> 注解：开发人员可以使用 <code>@Value</code> 注解直接绑定属性值到 Java 对象上。</li>
</ol>
<p>​		总的来说，Spring Boot 的配置加载顺序非常灵活，可以根据不同的需求进行灵活的配置。同时，由于 Spring Boot 的自动配置和 starter 的特性，开发人员可以非常方便地使用和集成各种常用的开源组件，从而提高开发效率和质量。</p>
<h3 id="642-spring-boot-核心配置文件是什么">
  6.42 Spring Boot 核心配置文件是什么
  <a href="#642-spring-boot-%e6%a0%b8%e5%bf%83%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Spring Boot 核心配置文件是 <code>application.properties</code> 或 <code>application.yml</code>，其中 <code>application.yml</code> 支持更加复杂的结构和语法，可以方便地进行配置管理。这些配置文件位于应用程序的 <code>classpath</code> 路径下，Spring Boot 会自动读取并解析这些配置文件，然后根据配置文件中的属性值进行相应的配置。在这些配置文件中，可以设置各种属性，例如端口号、数据库连接信息、日志级别、缓存策略等等。</p>
<h3 id="643-spring-boot-中的监视器是什么">
  6.43 Spring Boot 中的监视器是什么
  <a href="#643-spring-boot-%e4%b8%ad%e7%9a%84%e7%9b%91%e8%a7%86%e5%99%a8%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Spring Boot 中，监视器（Monitor）是指可以用于监视应用程序性能和健康状态的工具或服务。Spring Boot 中可以使用 Actuator 模块提供的监视器来查看应用程序的运行情况，包括应用程序的健康状况、内存使用情况、请求追踪、配置信息等等。Actuator 提供了一些 RESTful 风格的端点（endpoints），通过这些端点可以获取应用程序的运行时状态信息。</p>
<p>Actuator 默认提供的端点包括：</p>
<ul>
<li>/health：显示应用程序的健康状况</li>
<li>/info：显示应用程序的基本信息</li>
<li>/metrics：显示应用程序的度量指标，例如请求次数、响应时间等等</li>
<li>/trace：显示应用程序的请求追踪信息</li>
<li>/env：显示应用程序的环境变量信息</li>
<li>/configprops：显示应用程序的配置信息</li>
<li>/beans：显示应用程序中定义的所有 Spring bean</li>
<li>/dump：显示应用程序的线程信息</li>
<li>/auditevents：显示应用程序的审计事件</li>
</ul>
<p>​		可以通过配置文件来定制 Actuator 端点的访问路径、安全性等等。另外，也可以自定义监视器来监视应用程序的特定指标和状态。</p>
<h3 id="644-spring-boot-性能如何优化">
  6.44 Spring Boot 性能如何优化
  <a href="#644-spring-boot-%e6%80%a7%e8%83%bd%e5%a6%82%e4%bd%95%e4%bc%98%e5%8c%96" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring Boot 是一个高效的 Java Web 开发框架，但是在实际应用中也可能会遇到性能瓶颈问题，可以通过以下几个方面进行优化：</p>
<ol>
<li>应用配置优化：对于应用程序来说，正确的配置对于性能和稳定性是至关重要的。可以通过对 JVM、数据库连接池、线程池等进行调整优化，以提高应用程序的性能。</li>
<li>代码优化：可以通过对代码进行优化，消除潜在的性能问题。常见的优化包括减少内存使用、避免频繁的 I/O 操作、使用缓存等。</li>
<li>数据库优化：数据库通常是应用程序的瓶颈之一，可以通过使用索引、缓存、批处理等技术来提高数据库的性能。</li>
<li>Web 服务器优化：Web 服务器也是应用程序的瓶颈之一，可以通过使用负载均衡、缓存、静态资源优化等技术来提高 Web 服务器的性能。</li>
<li>日志优化：日志是应用程序中不可避免的一部分，但是过多的日志输出会影响应用程序的性能。可以通过使用日志级别和异步日志等技术来降低日志输出对应用程序性能的影响。</li>
</ol>
<p>​		总之，对于性能优化，需要结合具体的应用场景进行针对性优化。</p>
<h3 id="645-如何重新加载-spring-boot-上的更改而无需重新启动服务器spring-boot-项目如何热部署">
  6.45 如何重新加载 Spring Boot 上的更改，而无需重新启动服务器，Spring Boot 项目如何热部署
  <a href="#645-%e5%a6%82%e4%bd%95%e9%87%8d%e6%96%b0%e5%8a%a0%e8%bd%bd-spring-boot-%e4%b8%8a%e7%9a%84%e6%9b%b4%e6%94%b9%e8%80%8c%e6%97%a0%e9%9c%80%e9%87%8d%e6%96%b0%e5%90%af%e5%8a%a8%e6%9c%8d%e5%8a%a1%e5%99%a8spring-boot-%e9%a1%b9%e7%9b%ae%e5%a6%82%e4%bd%95%e7%83%ad%e9%83%a8%e7%bd%b2" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>为了在 Spring Boot 项目上重新加载更改而无需重新启动服务器，可以使用以下方法之一：</p>
<ol>
<li>使用开发工具的热部署插件：Spring Boot 可以与开发工具（如 Eclipse、IntelliJ IDEA）一起使用，这些工具提供热部署插件，可以在不重新启动服务器的情况下重新加载更改。例如，Spring Boot DevTools 提供了一种热部署机制，可以在修改类文件、属性文件或模板文件时重新加载应用程序。</li>
<li>使用 Spring Boot 的内置热部署功能：Spring Boot 2.4.0 及更高版本支持内置热部署功能，可以在不重新启动服务器的情况下重新加载更改。要启用此功能，可以在项目的 pom.xml 文件中添加以下依赖项：</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;groupId&gt;</span>org.springframework.boot<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;artifactId&gt;</span>spring-boot-devtools<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;optional&gt;</span>true<span style="color:#f92672">&lt;/optional&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>同时，需要在应用程序的配置文件中添加以下配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-properties" data-lang="properties"><span style="display:flex;"><span><span style="color:#a6e22e">spring.devtools.restart.enabled</span><span style="color:#f92672">=</span><span style="color:#e6db74">true</span>
</span></span></code></pre></div><p>​		在应用程序运行时，可以使用 Ctrl + Shift + F9（Windows）或 Cmd + Shift + F9（Mac）来重新加载更改。注意，此功能仅适用于修改了类文件，对于修改了资源文件（如属性文件、模板文件）的更改需要手动触发重新加载。</p>
<p>​		总之，热部署可以帮助开发人员快速查看代码更改的效果，加快开发调试的效率。但是，需要注意的是，热部署会消耗一定的资源，可能会影响应用程序的性能，因此在生产环境中应该避免使用。</p>
<h3 id="646-spring-boot-微服务中如何实现-session-共享">
  6.46 Spring Boot 微服务中如何实现 session 共享
  <a href="#646-spring-boot-%e5%be%ae%e6%9c%8d%e5%8a%a1%e4%b8%ad%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0-session-%e5%85%b1%e4%ba%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在传统的单体应用中，session 通常存储在内存中，可以在多个请求之间共享。但是，在微服务架构中，每个服务都是独立的进程，它们没有共享的内存。因此，如果要实现 session 共享，需要引入一个中间件来管理 session，从而使多个服务可以共享 session。</p>
<p>​		常见的实现方式是使用分布式缓存技术，例如 Redis、Memcached 等。在 Spring Boot 中，可以通过 Spring Session 框架来实现 session 共享，它可以将 session 数据存储到 Redis、MongoDB、JDBC 等持久化存储中，并提供了一套统一的 API 来操作 session。</p>
<p>使用 Spring Session 需要进行以下几个步骤：</p>
<ol>
<li>引入依赖</li>
</ol>
<p>在 pom.xml 中引入 Spring Session 相关的依赖：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;dependency&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;groupId&gt;</span>org.springframework.session<span style="color:#f92672">&lt;/groupId&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;artifactId&gt;</span>spring-session-data-redis<span style="color:#f92672">&lt;/artifactId&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/dependency&gt;</span>
</span></span></code></pre></div><ol>
<li>配置 Redis 连接</li>
</ol>
<p>在 application.properties 中配置 Redis 连接信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-properties" data-lang="properties"><span style="display:flex;"><span><span style="color:#a6e22e">spring.redis.host</span><span style="color:#f92672">=</span><span style="color:#e6db74">localhost</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">spring.redis.port</span><span style="color:#f92672">=</span><span style="color:#e6db74">6379</span>
</span></span></code></pre></div><ol>
<li>使用 @EnableRedisHttpSession 注解</li>
</ol>
<p>在 Spring Boot 启动类上使用 @EnableRedisHttpSession 注解启用 Spring Session：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@SpringBootApplication</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@EnableRedisHttpSession</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyApp</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        SpringApplication<span style="color:#f92672">.</span><span style="color:#a6e22e">run</span><span style="color:#f92672">(</span>MyApp<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">,</span> args<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>​		通过以上配置，就可以将 session 数据存储到 Redis 中，并实现 session 共享。在多个服务之间共享 session 数据时，需要将每个服务都配置为相同的 Redis 地址和端口，以便它们可以访问同一个 Redis 实例。</p>
<h3 id="647-spring-boot-中的-starter-到底是什么">
  6.47 Spring Boot 中的 starter 到底是什么
  <a href="#647-spring-boot-%e4%b8%ad%e7%9a%84-starter-%e5%88%b0%e5%ba%95%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Spring Boot 中，一个 starter 是一个预定义的依赖集合，它可以简化应用程序的依赖项管理，并帮助您快速启动各种技术堆栈。简单来说，starter 是一个“快速启动包”，它可以一次性引入多个相关的依赖项，以便您可以更轻松地开始构建应用程序。</p>
<p>Spring Boot 提供了许多 starter，例如：</p>
<ul>
<li>spring-boot-starter-web：适用于构建 Web 应用程序的依赖项集合，包括 Spring MVC 和 Tomcat。</li>
<li>spring-boot-starter-data-jpa：适用于使用 Spring Data JPA 访问数据库的依赖项集合，包括 Hibernate 和 Spring Data JPA。</li>
<li>spring-boot-starter-test：适用于编写测试的依赖项集合，包括 JUnit 和 Spring Test。</li>
</ul>
<p>​		starter 的命名约定是“spring-boot-starter-{technology}”，其中“{technology}”表示相关技术的名称。例如，如果您要使用 Thymeleaf 模板引擎，则可以使用 spring-boot-starter-thymeleaf starter，它包括 Thymeleaf、Spring MVC 和 Spring Boot 自动配置的所有必要依赖项。</p>
<h3 id="648-spring-boot-中如何实现定时任务">
  6.48 Spring Boot 中如何实现定时任务
  <a href="#648-spring-boot-%e4%b8%ad%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 Spring Boot 中实现定时任务有两种方式：基于注解的方式和基于配置的方式。</p>
<ol>
<li>基于注解的方式</li>
</ol>
<p>使用 <code>@Scheduled</code> 注解，该注解可用于方法上，用来指定方法的调用规则，例如下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Component</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScheduledTasks</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> SimpleDateFormat dateFormat <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SimpleDateFormat<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;HH:mm:ss&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Scheduled</span><span style="color:#f92672">(</span>fixedRate <span style="color:#f92672">=</span> <span style="color:#ae81ff">5000</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reportCurrentTime</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;现在时间：&#34;</span> <span style="color:#f92672">+</span> dateFormat<span style="color:#f92672">.</span><span style="color:#a6e22e">format</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Date<span style="color:#f92672">()));</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>​		上述代码中，<code>@Scheduled(fixedRate = 5000)</code> 指定了方法 <code>reportCurrentTime()</code> 每隔 5 秒执行一次。</p>
<ol start="2">
<li>基于配置的方式</li>
</ol>
<p>在 Spring Boot 的配置文件中，使用 <code>spring.task.scheduling</code> 属性配置定时任务。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">spring</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">task</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">scheduling</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">pool</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">size</span>: <span style="color:#ae81ff">5</span>
</span></span></code></pre></div><p>​		在上述配置中，<code>spring.task.scheduling.pool.size</code> 属性指定了线程池的大小为 5。</p>
<p>​		除此之外，还可以在配置文件中使用 Cron 表达式来指定定时任务的执行时间，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">spring</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">task</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">scheduling</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">cron</span>: <span style="color:#e6db74">&#34;0 0 12 * * ?&#34;</span>
</span></span></code></pre></div><p>​		上述配置指定了在每天中午 12 点执行定时任务。</p>
<p>无论使用哪种方式，都需要在启动类上加上 <code>@EnableScheduling</code> 注解，以启用定时任务的支持。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@SpringBootApplication</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@EnableScheduling</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Application</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        SpringApplication<span style="color:#f92672">.</span><span style="color:#a6e22e">run</span><span style="color:#f92672">(</span>Application<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">,</span> args<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>​		这样就可以在 Spring Boot 中实现定时任务了。</p>
<h3 id="649-spring-boot-starter-parent-有什么用">
  6.49 spring-boot-starter-parent 有什么用
  <a href="#649-spring-boot-starter-parent-%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		<code>spring-boot-starter-parent</code> 是 Spring Boot 官方提供的一个 Maven Parent POM，可以被其他 Spring Boot 项目继承，主要提供以下功能：</p>
<ol>
<li>默认依赖管理：继承了 <code>spring-boot-starter-parent</code> 后，可以自动获得 Spring Boot 的默认依赖管理。例如，如果要使用 Spring Boot 的默认版本的 Spring MVC，只需要添加 <code>spring-boot-starter-web</code> 依赖即可，无需显式声明 Spring MVC 的版本号和其他相关依赖。</li>
<li>插件管理：继承了 <code>spring-boot-starter-parent</code> 后，可以自动继承 Spring Boot 的默认 Maven 插件配置，包括 Maven Clean 插件、Maven Resources 插件、Maven Compiler 插件、Maven Surefire 插件等。</li>
<li>版本管理：继承了 <code>spring-boot-starter-parent</code> 后，可以自动获得 Spring Boot 的版本管理。例如，如果需要使用 Spring Boot 的 2.5.x 版本，只需要在 pom.xml 中声明 <code>spring-boot-starter-parent</code> 的版本为 <code>2.5.0</code> 即可。</li>
</ol>
<p>​		综上所述，<code>spring-boot-starter-parent</code> 简化了项目的 Maven 配置，提供了默认的依赖管理和插件配置，可以让开发人员更专注于业务逻辑的开发。</p>
<h3 id="650-spring-boot-如何实现打包">
  6.50 Spring Boot 如何实现打包
  <a href="#650-spring-boot-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%89%93%e5%8c%85" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Spring Boot 提供了一种方便的方式来打包应用程序，即使用 Maven 或 Gradle 构建工具进行打包。</p>
<p>对于 Maven，可以使用以下命令进行打包：</p>
<pre tabindex="0"><code>mvn package
</code></pre><p>这将在 target 目录中创建一个可执行的 jar 文件，可以使用以下命令运行该应用程序：</p>
<pre tabindex="0"><code>java -jar &lt;appname&gt;.jar
</code></pre><p>对于 Gradle，可以使用以下命令进行打包：</p>
<pre tabindex="0"><code>gradle bootJar
</code></pre><p>这将在 build/libs 目录中创建一个可执行的 jar 文件，可以使用以下命令运行该应用程序：</p>
<pre tabindex="0"><code>java -jar &lt;appname&gt;.jar
</code></pre><p>​		在打包时，Spring Boot 还提供了许多选项来配置打包行为。例如，可以将应用程序打包为 war 文件而不是 jar 文件，或者可以将应用程序打包为可执行的 zip 或 tar 文件。</p>
<h3 id="651-spring-boot-打包成的-jar-和普通的-jar-有什么区别">
  6.51 Spring Boot 打包成的 jar 和普通的 jar 有什么区别
  <a href="#651-spring-boot-%e6%89%93%e5%8c%85%e6%88%90%e7%9a%84-jar-%e5%92%8c%e6%99%ae%e9%80%9a%e7%9a%84-jar-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Spring Boot 打包成的 jar 和普通的 jar 有几个区别：</p>
<ol>
<li>内嵌的 Web 服务器：Spring Boot 打包的 jar 包中包含了内嵌的 Web 服务器，可以直接运行，而不需要安装 Tomcat 或者其他的 Web 服务器。</li>
<li>依赖管理：Spring Boot 使用 Maven 或 Gradle 等构建工具，通过 starter 机制自动引入需要的依赖，简化了项目的配置和管理。</li>
<li>入口类：Spring Boot 打包的 jar 包中会包含一个特殊的入口类，用于启动应用程序，并加载所有需要的配置。</li>
<li>配置文件：Spring Boot 打包的 jar 包中可以包含一个默认的配置文件 application.properties 或 application.yml，可以通过修改配置文件来修改应用程序的行为。</li>
<li>优化的性能：Spring Boot 使用了一些技术来优化应用程序的性能，例如使用嵌入式的 Web 服务器、使用高效的模板引擎等。</li>
</ol>
<p>​		综上所述，Spring Boot 打包成的 jar 与普通的 jar 相比，具有更强的自包含性和易用性，可以快速地构建和部署应用程序。</p>
<h3 id="652-什么是-spring-cloud-说说-spring-cloud-的优缺点">
  6.52 什么是 Spring Cloud ，说说 Spring Cloud 的优缺点
  <a href="#652-%e4%bb%80%e4%b9%88%e6%98%af-spring-cloud-%e8%af%b4%e8%af%b4-spring-cloud-%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Spring Cloud 是基于 Spring Boot 构建的一系列框架和工具的集合，用于简化分布式系统的开发和部署。它为开发人员提供了一种创建分布式系统的方式，这些系统具有可伸缩性、弹性、高可用性和可配置性等特性。</p>
<p>Spring Cloud 主要提供以下功能：</p>
<ol>
<li>服务注册与发现：通过服务注册与发现，实现服务的自动发现、负载均衡和故障转移等功能。</li>
<li>配置管理：通过统一的配置中心，管理应用程序的配置信息。</li>
<li>消息总线：通过消息总线，实现应用程序之间的通信，以及应用程序与配置中心之间的通信。</li>
<li>路由与网关：通过路由与网关，实现应用程序的统一入口和出口。</li>
<li>分布式跟踪：通过分布式跟踪，实现对分布式系统的监控和调用链追踪等功能。</li>
</ol>
<p>Spring Cloud 的优点：</p>
<ol>
<li>简化分布式系统的开发和部署：Spring Cloud 提供了一系列的框架和工具，可以帮助开发人员更容易地构建和部署分布式系统。</li>
<li>提高应用程序的可伸缩性和弹性：Spring Cloud 提供了负载均衡、故障转移等功能，可以帮助应用程序更好地应对高负载和故障情况。</li>
<li>提高应用程序的可配置性：通过配置中心，可以更方便地管理应用程序的配置信息，以及对应用程序进行动态配置。</li>
</ol>
<p>Spring Cloud 的缺点：</p>
<ol>
<li>学习曲线较陡峭：Spring Cloud 的学习曲线相对较陡峭，需要掌握一定的分布式系统的知识。</li>
<li>复杂性较高：Spring Cloud 是一系列框架和工具的集合，需要理解和掌握多个组件的使用方法和工作原理。</li>
<li>依赖于其他开源组件：Spring Cloud 依赖于多个其他的开源组件，需要对这些组件的使用方法和工作原理有一定的了解。</li>
</ol>
<h3 id="653-spring-cloud-由什么组成">
  6.53 Spring Cloud 由什么组成
  <a href="#653-spring-cloud-%e7%94%b1%e4%bb%80%e4%b9%88%e7%bb%84%e6%88%90" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Spring Cloud 是一个基于 Spring Boot 实现的用于构建分布式系统的开发工具包，提供了一整套分布式系统的解决方案，包括服务注册与发现、配置中心、负载均衡、熔断器、路由、微代理、事件总线、分布式 Session、集群状态管理等组件，可以让开发者快速地构建出基于 Spring Cloud 的分布式应用程序。</p>
<p>Spring Cloud 由以下几个核心组件组成：</p>
<ol>
<li>Spring Cloud Netflix：集成了 Netflix 公司开发的 Eureka（服务注册与发现）、Ribbon、Hystrix（熔断器）、Zuul（路由）等组件。</li>
<li>Spring Cloud Config：提供了分布式配置管理的解决方案，可以集中管理分布式环境下的配置信息。</li>
<li>Spring Cloud Bus：基于消息代理（如 RabbitMQ、Kafka）实现的消息总线，可以用来实现分布式系统中的消息广播和事件驱动等功能。</li>
<li>Spring Cloud Security：为 Spring Boot 应用程序提供安全控制。</li>
<li>Spring Cloud Stream：基于 Spring Integration 实现的消息驱动微服务的解决方案，可以将消息中间件作为消息传输的抽象层，简化了微服务之间的通信。</li>
<li>Spring Cloud Task：通过简单的应用程序，实现 Spring Boot 应用程序的任务管理。</li>
<li>Spring Cloud Data Flow：用于简化大数据微服务应用程序的构建、部署和协调的工具。</li>
<li>Spring Cloud OpenFeign：基于 Netflix Feign 实现的声明式的 HTTP 客户端，可以简化 HTTP 客户端的开发。</li>
<li>Spring Cloud Sleuth：提供了分布式跟踪的解决方案，可以通过 Trace ID 将整个分布式请求串联起来，便于进行日志分析和故障排查。</li>
<li>Spring Cloud Gateway：提供了一种基于 WebFlux 的 API 网关解决方案，可以进行路由转发、安全控制、负载均衡等操作。</li>
</ol>
<p>优点：</p>
<ol>
<li>便于搭建分布式系统：Spring Cloud 提供了一整套分布式系统的解决方案，可以让开发者快速地构建出基于 Spring Cloud 的分布式应用程序。</li>
<li>高度可扩展：Spring Cloud 支持多种服务注册与发现的方式，可以选择适合自己的方式进行集成。</li>
<li>开箱即用：Spring Cloud 集成了多种分布式系统解决方案，开发者可以直接使用已经实现好的组件，无需自己实现。</li>
<li>生态丰富：Spring Cloud 与 Spring Boot 生态高度契合，可以方便地集成 Spring 生态圈中的其他组件。</li>
</ol>
<p>缺点：</p>
<ol>
<li>学习成本较高：Spring Cloud 集成了多种分布式系统解决方案，学习成本较高。</li>
<li>依赖较多：Spring Cloud 集成了多种分布式系统解决方案，依赖较多。</li>
<li>一些组件更新不及时：一些组件的更新不及时，需要开发者自行解决。</li>
</ol>
<h3 id="654-什么是-nginx为什么要用-nginxnginx-的优缺点有哪些">
  6.54 什么是 Nginx，为什么要用 Nginx，Nginx 的优缺点有哪些
  <a href="#654-%e4%bb%80%e4%b9%88%e6%98%af-nginx%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-nginxnginx-%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9%e6%9c%89%e5%93%aa%e4%ba%9b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Nginx 是一款高性能的开源 Web 服务器和反向代理服务器，它支持负载均衡、动态 HTTP 缓存、SSL/TLS 加密等功能，因其高性能、高并发、低内存消耗等特点，被广泛用于高负载的 Web 服务和大规模的网站。</p>
<p>使用 Nginx 的优点包括：</p>
<ol>
<li>高性能：Nginx 采用异步非阻塞的事件驱动模型，可以处理大量并发请求，同时能够快速响应客户端请求，提供更好的性能和可靠性。</li>
<li>高并发：Nginx 支持多进程和多线程，并且可以有效地处理高并发请求，以及长连接和大文件传输等高负载场景。</li>
<li>低内存消耗：Nginx 的内存占用很低，对系统资源的占用也很少，这使得 Nginx 很适合在资源受限的环境下运行。</li>
<li>灵活配置：Nginx 的配置文件简单易懂，可以轻松配置反向代理、负载均衡、缓存、SSL/TLS 加密等功能，而且支持动态模块加载，可以根据实际需求动态调整配置。</li>
<li>高可靠性：Nginx 支持自动故障转移和恢复，可以有效地保障服务的可用性和可靠性。</li>
</ol>
<p>Nginx 的缺点主要包括：</p>
<ol>
<li>学习成本：Nginx 的配置相对比较复杂，需要一定的学习成本。</li>
<li>功能有限：相对于 Apache 等其他 Web 服务器，Nginx 功能相对简单，不支持一些高级功能，如动态内容生成等。</li>
<li>配置不易维护：Nginx 的配置文件分散在多个文件中，难以进行统一的管理和维护，而且不支持类似 Apache 的 .htaccess 文件。</li>
</ol>
<p>​		总体来说，Nginx 是一款高性能、高可靠性的 Web 服务器和反向代理服务器，适用于高负载的 Web 服务和大规模的网站，但使用时需要注意其学习成本和配置维护的问题。</p>
<h1 id="第7章-mybatis">
  第7章 MyBatis
  <a href="#%e7%ac%ac7%e7%ab%a0-mybatis" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="71-mybatis-是什么并说出它的优缺点">
  7.1 MyBatis 是什么，并说出它的优缺点
  <a href="#71-mybatis-%e6%98%af%e4%bb%80%e4%b9%88%e5%b9%b6%e8%af%b4%e5%87%ba%e5%ae%83%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		MyBatis 是一款基于 Java 的持久层框架，它通过 XML 或注解的方式将 SQL 语句与 Java 代码相分离，避免了传统 JDBC 开发中 SQL 语句硬编码的问题。MyBatis 提供了丰富的映射标签和 SQL 标签，使得开发人员可以方便地进行 SQL 映射和查询操作，同时也支持一些高级特性，如一级缓存、二级缓存、懒加载等。</p>
<p>MyBatis 的优点包括：</p>
<ol>
<li>简单易用：相对于 Hibernate 等 ORM 框架，MyBatis 的学习曲线较为平缓，API 简单易懂，上手容易。</li>
<li>灵活性好：MyBatis 采用 SQL 语句和 Java 代码相分离的方式，开发人员可以自由地进行 SQL 的编写和修改，具有较高的灵活性。</li>
<li>扩展性强：MyBatis 的底层框架可以通过插件机制进行扩展，可以实现自定义插件以满足不同的需求。</li>
<li>映射灵活：MyBatis 支持丰富的映射标签，可以自由地进行对象属性和数据库字段的映射。</li>
</ol>
<p>MyBatis 的缺点包括：</p>
<ol>
<li>需要手写 SQL：相对于 Hibernate 等 ORM 框架，MyBatis 需要开发人员手写 SQL 语句，对开发人员的 SQL 技能有一定要求，同时也可能导致 SQL 语句的重复编写。</li>
<li>需要进行大量配置：MyBatis 需要进行大量的 XML 配置或注解配置，配置过程相对繁琐。</li>
<li>不适合复杂查询：由于 MyBatis 需要手写 SQL 语句，对于较为复杂的查询可能会比较麻烦，不如使用 Hibernate 等 ORM 框架方便。</li>
</ol>
<p>​		总的来说，MyBatis 是一款简单易用、灵活性好、扩展性强的持久层框架，但需要开发人员具备一定的 SQL 编写能力，适用于中小型项目和对 SQL 掌握较好的开发人员。</p>
<h3 id="72-mybatis-的核心对象都有哪些">
  7.2 Mybatis 的核心对象都有哪些
  <a href="#72-mybatis-%e7%9a%84%e6%a0%b8%e5%bf%83%e5%af%b9%e8%b1%a1%e9%83%bd%e6%9c%89%e5%93%aa%e4%ba%9b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Mybatis 的核心对象包括：</p>
<ol>
<li>SqlSessionFactoryBuilder：用于创建 SqlSessionFactory 对象的构建器。</li>
<li>SqlSessionFactory：用于创建 SqlSession 对象的工厂。</li>
<li>SqlSession：用于执行 SQL 语句的对象，提供了对数据库的增删改查操作。</li>
<li>Configuration：Mybatis 的配置对象，包括 Mybatis 的全局配置、数据库连接信息、映射文件信息等。</li>
<li>MappedStatement：映射语句的封装对象，包括 SQL 语句、参数类型、结果类型等信息。</li>
<li>Executor：SQL 执行器，定义了数据库操作的具体执行方式。</li>
<li>StatementHandler：语句处理器，用于执行 SQL 语句并将结果集映射到 Java 对象中。</li>
<li>ParameterHandler：参数处理器，用于设置 SQL 语句中的参数。</li>
<li>ResultSetHandler：结果集处理器，用于将 SQL 语句的结果集映射到 Java 对象中。</li>
<li>TypeHandler：类型处理器，用于实现 Java 对象与数据库类型之间的相互转换。</li>
</ol>
<p>​		这些对象相互协作，构成了 Mybatis 的执行流程。其中，SqlSession、Configuration、MappedStatement、Executor 是 Mybatis 最核心的四个对象。</p>
<h3 id="73-hibernate-和-mybatis-的区别">
  7.3 Hibernate 和 MyBatis 的区别
  <a href="#73-hibernate-%e5%92%8c-mybatis-%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Hibernate 和 MyBatis 都是 Java 中比较常用的 ORM（对象关系映射）框架，它们的主要区别如下：</p>
<ol>
<li>SQL 生成方式不同：</li>
</ol>
<ul>
<li>Hibernate 使用 HQL（Hibernate Query Language），通过面向对象的方式操作数据库，不需要编写 SQL 语句，Hibernate 会将 HQL 转换为底层的 SQL 语句。</li>
<li>MyBatis 直接编写 SQL 语句，并提供了较为灵活的 SQL 映射方式。</li>
</ul>
<ol start="2">
<li>对象映射不同：</li>
</ol>
<ul>
<li>Hibernate 提供了很多的默认映射策略，可以通过注解或 XML 配置来进行扩展和修改。</li>
<li>MyBatis 则需要手动进行属性到列的映射。</li>
</ul>
<ol start="3">
<li>缓存机制不同：</li>
</ol>
<ul>
<li>Hibernate 有一级缓存和二级缓存，一级缓存是 Session 级别的缓存，二级缓存是 SessionFactory 级别的缓存，可以提高性能，但也容易出现脏数据问题。</li>
<li>MyBatis 提供了本地缓存和二级缓存，其中本地缓存是 SqlSession 级别的缓存，二级缓存是全局缓存，需要手动配置，也容易出现脏数据问题。</li>
</ul>
<ol start="4">
<li>懒加载支持不同：</li>
</ol>
<ul>
<li>Hibernate 支持对实体的关联对象进行懒加载，只有在使用时才会加载关联对象。</li>
<li>MyBatis 也支持懒加载，但需要手动配置。</li>
</ul>
<ol start="5">
<li>性能不同：</li>
</ol>
<ul>
<li>由于 Hibernate 采用了大量的缓存机制，它在高并发场景下的性能可能不如 MyBatis，但是在一些不需要高并发场景下，Hibernate 通过缓存机制可以提高访问速度，降低数据库的访问频率。</li>
<li>MyBatis 相比于 Hibernate，更加轻量级，没有过多的缓存机制，性能相对较好，但是需要手动编写 SQL，开发的难度较高。</li>
</ul>
<p>​		综上所述，Hibernate 适合需要大量缓存和对象关系复杂的场景，而 MyBatis 适合需要高性能和灵活性的场景。</p>
<h3 id="74-orm-是什么为什么说-mybatis-是半自动-orm-映射工具它与全自动的区别在哪里">
  7.4 ORM 是什么，为什么说 Mybatis 是半自动 ORM 映射工具，它与全自动的区别在哪里
  <a href="#74-orm-%e6%98%af%e4%bb%80%e4%b9%88%e4%b8%ba%e4%bb%80%e4%b9%88%e8%af%b4-mybatis-%e6%98%af%e5%8d%8a%e8%87%aa%e5%8a%a8-orm-%e6%98%a0%e5%b0%84%e5%b7%a5%e5%85%b7%e5%ae%83%e4%b8%8e%e5%85%a8%e8%87%aa%e5%8a%a8%e7%9a%84%e5%8c%ba%e5%88%ab%e5%9c%a8%e5%93%aa%e9%87%8c" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		ORM（Object-Relational Mapping，对象关系映射）是指将关系型数据库中的数据转换为对象，使得应用程序可以像操作对象一样操作数据库，避免了手写 SQL 语句的繁琐和易错。</p>
<p>​		MyBatis 是一款半自动 ORM（Object-Relational Mapping）映射工具。它被称为“半自动”，是因为在使用 MyBatis 进行数据操作时，需要开发者自己手写 SQL 语句。MyBatis 不会根据 Java 对象自动生成 SQL 语句，而是通过 XML 或注解配置 SQL 语句，然后将 Java 对象与 SQL 语句进行映射，最终将查询结果转换为 Java 对象返回。</p>
<p>​		相比之下，全自动 ORM 映射工具如 Hibernate 则可以根据 Java 对象自动生成 SQL 语句，从而避免手写 SQL 语句带来的繁琐和易错。然而，由于自动生成的 SQL 语句可能存在性能问题或者不符合需求，因此使用全自动 ORM 映射工具可能需要开发者花费更多时间在 SQL 优化和调整上，而半自动 ORM 映射工具则可以更灵活地满足开发者的需求。</p>
<h3 id="75-传统-jdbc-开发存在什么问题">
  7.5 传统 JDBC 开发存在什么问题
  <a href="#75-%e4%bc%a0%e7%bb%9f-jdbc-%e5%bc%80%e5%8f%91%e5%ad%98%e5%9c%a8%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>传统 JDBC（Java Database Connectivity）开发存在以下几个问题：</p>
<ol>
<li>大量的样板代码：传统 JDBC 开发需要进行大量的样板代码编写，如加载数据库驱动、创建连接、创建语句、处理异常等。</li>
<li>处理 SQL 语句和结果集的过程繁琐：传统 JDBC 开发需要手动处理 SQL 语句的生成和结果集的处理，代码量大且易出错。</li>
<li>数据库连接管理问题：传统 JDBC 开发需要手动管理数据库连接，需要手动创建和释放连接，处理连接池等问题。</li>
<li>缺乏面向对象的映射：传统 JDBC 开发需要手动进行数据的映射，即将结果集的数据逐个封装到对象中，这个过程比较繁琐。</li>
</ol>
<p>​		相比于传统 JDBC 开发，ORM（Object Relational Mapping）框架可以解决这些问题。MyBatis 是一款轻量级的半自动 ORM 映射工具，它的优点在于：</p>
<ol>
<li>简化 SQL 语句和结果集处理：MyBatis 可以通过 XML 或注解配置 SQL 语句和结果集的处理，大大减少了开发人员的工作量。</li>
<li>自动化数据库连接管理：MyBatis 提供了数据库连接池和事务管理等功能，开发人员可以直接使用，无需手动管理数据库连接。</li>
<li>提供了面向对象的映射：MyBatis 提供了面向对象的映射，将查询结果映射到对象中，减少了手动映射的代码量。</li>
<li>灵活性高：MyBatis 不依赖于任何 ORM 框架，可以与 Spring、Hibernate 等其他框架集成使用。</li>
</ol>
<p>​		缺点方面，由于 MyBatis 是半自动 ORM 映射工具，需要开发人员手动编写 SQL 语句和进行结果集的映射，因此开发成本略高。此外，MyBatis 对于复杂查询的支持相对较弱，难以应对复杂的业务需求。</p>
<h3 id="76-mybatis-和-hibernate-的适用场景">
  7.6 MyBatis 和 Hibernate 的适用场景
  <a href="#76-mybatis-%e5%92%8c-hibernate-%e7%9a%84%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		MyBatis 和 Hibernate 都是 Java 持久化框架，虽然它们都是 ORM 框架，但它们的思想和用法是不同的，适用于不同的场景。</p>
<p>MyBatis 的适用场景：</p>
<ol>
<li>
<p>对 SQL语 句有精细的控制需求，例如，需要对查询结果进行定制化的映射、执行复杂的批量操作、使用存储过程等。</p>
</li>
<li>
<p>需要对现有的 SQL 语句进行优化或重构，以提高系统的性能。</p>
</li>
<li>
<p>需要使用MyBatis提供的特定的功能，例如，缓存控制、延迟加载、动态 SQL 等。</p>
</li>
</ol>
<p>Hibernate 的适用场景：</p>
<ol>
<li>
<p>需要使用面向对象的方式操作数据库，不希望编写复杂的 SQL 语句。</p>
</li>
<li>
<p>需要使用 Hibernate 提供的 ORM 功能，例如，自动映射、缓存管理、延迟加载、事务控制等。</p>
</li>
<li>
<p>需要使用 Hibernate 的持久化层提供的高级特性，例如，多态关联、继承映射、版本控制等。</p>
</li>
</ol>
<p>​		总的来说，MyBatis 更适合需要精细控制 SQL 语句的场景，而 Hibernate 则更适合需要使用 ORM 功能的场景。</p>
<h3 id="77-mybatis-编程步骤是什么样的并说说它的工作原理">
  7.7 MyBatis 编程步骤是什么样的，并说说它的工作原理
  <a href="#77-mybatis-%e7%bc%96%e7%a8%8b%e6%ad%a5%e9%aa%a4%e6%98%af%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e5%b9%b6%e8%af%b4%e8%af%b4%e5%ae%83%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>MyBatis 的编程步骤通常如下：</p>
<ol>
<li>编写 SQL 语句：编写需要执行的 SQL 语句。</li>
<li>编写 Mapper 接口：创建一个 Java 接口，该接口定义了 SQL 语句的名称和参数。</li>
<li>编写 Mapper.xml 文件：在该文件中定义 SQL 语句和结果映射。</li>
<li>配置数据源和 MyBatis：配置数据源和 MyBatis，包括 JDBC 驱动、连接 URL、用户名和密码等。</li>
<li>通过 SqlSessionFactoryBuilder 创建 SqlSessionFactory 对象：SqlSessionFactoryBuilder 是一个工厂，用于创建 SqlSessionFactory，而 SqlSessionFactory 则用于创建 SqlSession。</li>
<li>通过 SqlSessionFactory 创建 SqlSession 对象：SqlSession 是与数据库交互的核心对象。</li>
<li>在 Java 代码中调用 Mapper 接口中的方法：调用 Mapper 接口中定义的方法，MyBatis 将会动态地生成代理类，并将 Mapper 接口与 XML 文件进行绑定。</li>
</ol>
<p>MyBatis 的工作原理：</p>
<ol>
<li>首先，MyBatis 通过 SqlSessionFactoryBuilder 创建 SqlSessionFactory。</li>
<li>接着，SqlSessionFactory 创建 SqlSession 对象。</li>
<li>然后，通过 SqlSession 对象调用 Mapper 接口中的方法，MyBatis 会动态地生成代理类，并将 Mapper 接口与 XML 文件进行绑定。</li>
<li>最后，MyBatis 会将 SQL 语句交给 JDBC 进行执行，获取结果，并将结果映射为 Java 对象返回。</li>
</ol>
<p>​		MyBatis 的工作流程相对简单，而且可以通过 XML 文件进行配置，使得开发人员能够更加方便地进行 SQL 语句的编写和调试。同时，MyBatis 支持动态 SQL 语句的生成，可以灵活地应对复杂的查询需求。但是，MyBatis 依赖于手写 SQL 语句，需要开发人员具备较强的 SQL 技能，而且对于复杂的 ORM 映射关系，需要手动进行配置，工作量较大。</p>
<h3 id="78-为什么需要预编译">
  7.8 为什么需要预编译
  <a href="#78-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e9%a2%84%e7%bc%96%e8%af%91" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		预编译（Prepared Statement）是指在程序执行 SQL 语句之前，先将 SQL 语句发送到数据库管理系统进行预处理，将其中的变量用占位符代替，然后编译生成一个执行计划。这个执行计划可以被重复使用，只需要将具体的参数传递进来就可以执行。与之相对的是动态 SQL 语句，它的执行计划是每次执行时都需要编译生成，相比之下效率较低。</p>
<p>使用预编译有以下好处：</p>
<p>1.提高了数据库的性能：因为每个 PreparedStatement 都只需要编译一次，可以被多次重复利用，减少了对数据库服务器的负荷。</p>
<p>2.防止 SQL 注入攻击：使用占位符代替变量可以有效防止 SQL 注入攻击。</p>
<p>3.提高了代码的可读性和可维护性：使用占位符代替变量可以使 SQL 语句更清晰易懂，易于维护。</p>
<h3 id="79-mybatis-都有哪些-executor-执行器它们之间的区别是什么">
  7.9 Mybatis 都有哪些 Executor 执行器，它们之间的区别是什么
  <a href="#79-mybatis-%e9%83%bd%e6%9c%89%e5%93%aa%e4%ba%9b-executor-%e6%89%a7%e8%a1%8c%e5%99%a8%e5%ae%83%e4%bb%ac%e4%b9%8b%e9%97%b4%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		MyBatis 有三种 Executor 执行器：SimpleExecutor、ReuseExecutor 和 BatchExecutor，它们之间的区别主要在于缓存的使用、执行方式和范围。</p>
<ol>
<li>SimpleExecutor：每次执行操作时，都会创建一个 Statement 对象，执行完后立即关闭 Statement 对象。不支持二级缓存，也不支持批量处理操作，所以不适合于多次执行相同 SQL 的情况。</li>
<li>ReuseExecutor：重用执行器，如果两次执行相同 SQL 语句，则第二次直接从缓存中获取 Statement 对象。支持一级缓存，但不支持二级缓存，也不支持批量处理操作。</li>
<li>BatchExecutor：批量执行器，适合于批量操作，支持一级缓存和二级缓存，每次执行操作时，先将 SQL 语句和参数缓存到批处理列表中，等到积攒到一定数量后再批量执行。但是，由于需要积攒一定数量的操作，所以不能立即得到执行结果。</li>
</ol>
<p>​		在默认情况下，MyBatis 使用 ReuseExecutor 执行器。可以通过在 Mapper.xml 文件中配置来指定使用哪种 Executor 执行器。例如，可以使用 <!-- raw HTML omitted --> 来指定使用 BatchExecutor 执行器。</p>
<h3 id="710--和--的区别是什么">
  7.10 #{} 和 ${} 的区别是什么
  <a href="#710--%e5%92%8c--%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 MyBatis 中，#{} 和 ${} 都是用来在 SQL 语句中插入参数的占位符。它们的区别如下：</p>
<ol>
<li>#{} 是预编译语句中的参数占位符，可以防止 SQL 注入攻击，同时也可以自动进行参数类型转换，比如将 String 类型的参数自动转换为 int 类型。${} 是直接替换成参数的值，无法防止 SQL 注入攻击。</li>
<li>#{} 是使用 PreparedStatement 进行预编译的，可以重复使用已经编译好的语句，提高了性能。${} 是直接替换成参数的值，每次都需要重新编译语句，性能较差。</li>
<li>#{} 可以防止 SQL 注入攻击，因为 #{} 将参数值转义后，将其放入一个安全的预编译语句中，而 ${} 直接替换成参数的值，容易被恶意用户篡改或注入恶意代码。</li>
<li>#{} 适用于所有的 SQL 语句，包括 SELECT、INSERT、UPDATE 和 DELETE 等，而 ${} 适用于部分 SQL 语句，如只能用于 SELECT 语句中的列名或表名。</li>
</ol>
<p>​		总的来说，#{} 是更加安全和可靠的参数占位符，也是 MyBatis 推荐使用的方式。而 ${} 则应该谨慎使用，避免造成 SQL 注入攻击。</p>
<h3 id="711-模糊查询-like-语句该怎么写">
  7.11 模糊查询 like 语句该怎么写
  <a href="#711-%e6%a8%a1%e7%b3%8a%e6%9f%a5%e8%af%a2-like-%e8%af%ad%e5%8f%a5%e8%af%a5%e6%80%8e%e4%b9%88%e5%86%99" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 MyBatis 中进行模糊查询可以使用 LIKE 关键字，示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;select</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;selectUserByName&#34;</span> <span style="color:#a6e22e">resultType=</span><span style="color:#e6db74">&#34;User&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  SELECT * FROM users WHERE name LIKE CONCAT(&#39;%&#39;, #{name}, &#39;%&#39;)
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/select&gt;</span>
</span></span></code></pre></div><p>​		上述 SQL 语句中使用了 CONCAT 函数来拼接字符串，% 表示匹配任意字符，这里使用了两个 % 表示匹配字符串中的任意字符。</p>
<p>在执行查询时，可以在参数值中传入需要匹配的字符串，示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List<span style="color:#f92672">&lt;</span>User<span style="color:#f92672">&gt;</span> users <span style="color:#f92672">=</span> sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">selectList</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;selectUserByName&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;%Tom%&#34;</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><p>​		在这个示例中，%Tom% 表示需要模糊匹配的字符串，MyBatis 会将其传递给 SQL 语句中的参数 #{name}。</p>
<h3 id="712-在-mapper-中如何传递多个参数">
  7.12 在 Mapper 中如何传递多个参数
  <a href="#712-%e5%9c%a8-mapper-%e4%b8%ad%e5%a6%82%e4%bd%95%e4%bc%a0%e9%80%92%e5%a4%9a%e4%b8%aa%e5%8f%82%e6%95%b0" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在 MyBatis 中，我们可以通过以下方式传递多个参数：</p>
<ol>
<li>将多个参数包装成一个 Map 或者 JavaBean 对象，然后将这个对象传递给 Mapper 方法。</li>
</ol>
<p>例如，我们有两个参数 name 和 age，可以将它们封装到一个 JavaBean 对象中，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">User</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String name<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 省略 getter 和 setter 方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>然后在 Mapper.xml 中定义方法，参数类型为 User：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;select</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;getUserByNameAndAge&#34;</span> <span style="color:#a6e22e">resultType=</span><span style="color:#e6db74">&#34;User&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    select * from user where name = #{name} and age = #{age}
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/select&gt;</span>
</span></span></code></pre></div><p>然后在 Java 代码中调用该方法，将参数封装到 User 对象中，再将 User 对象传递给 Mapper 方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>User user <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> User<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>user<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;张三&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>user<span style="color:#f92672">.</span><span style="color:#a6e22e">setAge</span><span style="color:#f92672">(</span><span style="color:#ae81ff">20</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>User result <span style="color:#f92672">=</span> sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">selectOne</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;getUserByNameAndAge&#34;</span><span style="color:#f92672">,</span> user<span style="color:#f92672">);</span>
</span></span></code></pre></div><ol start="2">
<li>在 Mapper.xml 中使用 @Param 注解为多个参数起别名，并在 Mapper 方法中按顺序使用这些别名。</li>
</ol>
<p>例如，我们有两个参数 name 和 age，可以在 Mapper.xml 中使用 @Param 注解为它们起别名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;select</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;getUserByNameAndAge&#34;</span> <span style="color:#a6e22e">resultType=</span><span style="color:#e6db74">&#34;User&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    select * from user where name = #{nameParam} and age = #{ageParam}
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/select&gt;</span>
</span></span></code></pre></div><p>然后在 Java 代码中调用该方法时，使用 @Param 注解为参数起别名：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>User result <span style="color:#f92672">=</span> sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">selectOne</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;getUserByNameAndAge&#34;</span><span style="color:#f92672">,</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Param</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;nameParam&#34;</span><span style="color:#f92672">)</span> String name<span style="color:#f92672">,</span> <span style="color:#a6e22e">@Param</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ageParam&#34;</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">);</span>
</span></span></code></pre></div><p>注意，在使用 @Param 注解时，方法参数的顺序与 Mapper.xml 中使用的别名顺序要一致。</p>
<ol start="3">
<li>直接在 Mapper 方法中按顺序使用多个参数。</li>
</ol>
<p>例如，我们有两个参数 name 和 age，可以在 Mapper.xml 中定义方法时，按顺序使用这些参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;select</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;getUserByNameAndAge&#34;</span> <span style="color:#a6e22e">resultType=</span><span style="color:#e6db74">&#34;User&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    select * from user where name = #{0} and age = #{1}
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/select&gt;</span>
</span></span></code></pre></div><p>然后在 Java 代码中调用该方法时，直接按顺序传递多个参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>User result <span style="color:#f92672">=</span> sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">selectOne</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;getUserByNameAndAge&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;张三&#34;</span><span style="color:#f92672">,</span> <span style="color:#ae81ff">20</span><span style="color:#f92672">);</span>
</span></span></code></pre></div><p>注意，在直接按顺序使用多个参数时，需要保证参数的顺序与 Mapper.xml 中定义方法时的顺序一致。</p>
<h3 id="713-mybatis-如何执行批量操作">
  7.13 Mybatis 如何执行批量操作
  <a href="#713-mybatis-%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e6%89%b9%e9%87%8f%e6%93%8d%e4%bd%9c" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		MyBatis 提供了两种方式执行批量操作：基于 <code>BatchExecutor</code> 的方式和基于 <code>BatchStatement</code> 的方式。</p>
<p>​		基于 <code>BatchExecutor</code> 的方式需要通过 <code>SqlSession</code> 对象的 <code>flushStatements()</code> 方法将所有的 SQL 语句缓存到内存中，当执行完所有的 SQL 后再通过 <code>SqlSession</code> 对象的 <code>commit()</code> 方法一次性提交所有的 SQL 语句到数据库中。这种方式需要手动管理事务，需要在提交前开启事务，提交后关闭事务。</p>
<p>​		基于 <code>BatchStatement</code> 的方式则是将多条 SQL 语句合并成一条 SQL 语句，通过一次性执行一条 SQL 语句来实现批量操作。这种方式不需要手动管理事务，MyBatis 会自动为每个批量操作开启事务并在批量操作结束后提交事务。</p>
<p>以下是基于 <code>BatchExecutor</code> 的示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>SqlSession sqlSession <span style="color:#f92672">=</span> sqlSessionFactory<span style="color:#f92672">.</span><span style="color:#a6e22e">openSession</span><span style="color:#f92672">(</span>ExecutorType<span style="color:#f92672">.</span><span style="color:#a6e22e">BATCH</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  Mapper mapper <span style="color:#f92672">=</span> sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">getMapper</span><span style="color:#f92672">(</span>Mapper<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Object obj <span style="color:#f92672">:</span> objs<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    mapper<span style="color:#f92672">.</span><span style="color:#a6e22e">insert</span><span style="color:#f92672">(</span>obj<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">flushStatements</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>  sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">commit</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Exception e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">rollback</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>以下是基于 <code>BatchStatement</code> 的示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>SqlSession sqlSession <span style="color:#f92672">=</span> sqlSessionFactory<span style="color:#f92672">.</span><span style="color:#a6e22e">openSession</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  Mapper mapper <span style="color:#f92672">=</span> sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">getMapper</span><span style="color:#f92672">(</span>Mapper<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  List<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> objs <span style="color:#f92672">=</span> <span style="color:#f92672">...;</span>
</span></span><span style="display:flex;"><span>  mapper<span style="color:#f92672">.</span><span style="color:#a6e22e">insertBatch</span><span style="color:#f92672">(</span>objs<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">commit</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>Exception e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">rollback</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  sqlSession<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>其中，<code>insertBatch</code> 方法需要在 Mapper 接口中定义：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertBatch</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> objs<span style="color:#f92672">);</span>
</span></span></code></pre></div><h3 id="714-dao-接口的工作原理是什么dao接口里的方法参数不同时方法能重载吗">
  7.14 Dao 接口的工作原理是什么，Dao接口里的方法，参数不同时，方法能重载吗
  <a href="#714-dao-%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88dao%e6%8e%a5%e5%8f%a3%e9%87%8c%e7%9a%84%e6%96%b9%e6%b3%95%e5%8f%82%e6%95%b0%e4%b8%8d%e5%90%8c%e6%97%b6%e6%96%b9%e6%b3%95%e8%83%bd%e9%87%8d%e8%bd%bd%e5%90%97" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Dao（Data Access Object）接口是一种为了方便持久层代码开发而抽象出来的接口。它主要用于定义数据库操作的方法，并将这些方法的实现交由具体的实现类来完成。</p>
<p>​		Dao 接口定义了对数据库进行操作的方法，这些方法可以通过 MyBatis 框架自动映射到对应的 SQL 语句。通过接口方式来定义持久层的操作方法，可以大大降低代码的耦合度，让开发者更加专注于业务代码的实现。</p>
<p>​		在 Dao 接口中，方法名称和方法参数类型对应了对应 SQL 语句的 ID 和参数类型，方法返回值则表示查询结果的类型。</p>
<p>​		在 Java 中，方法的重载是通过方法的参数列表来实现的，而 Dao 接口中的方法也可以根据参数类型的不同进行方法重载。但是，如果同一个方法名称、相同参数类型，但返回值类型不同，那么在 Dao 接口中是不能够实现方法的重载的。这是因为，MyBatis 框架根据方法名称、参数类型和返回值类型来确定对应的 SQL 语句，如果有多个方法名称和参数类型相同，但是返回值类型不同的方法，那么 MyBatis 框架就无法确定应该映射到哪一个 SQL 语句，因此会报错。</p>
<h3 id="715-mybatis-的-xml-映射文件中不同的-xml-映射文件-id-是否可以重复">
  7.15 Mybatis 的 Xml 映射文件中，不同的 Xml 映射文件 ID 是否可以重复
  <a href="#715-mybatis-%e7%9a%84-xml-%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6%e4%b8%ad%e4%b8%8d%e5%90%8c%e7%9a%84-xml-%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6-id-%e6%98%af%e5%90%a6%e5%8f%af%e4%bb%a5%e9%87%8d%e5%a4%8d" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Mybatis 的 XML 映射文件中，不同的 XML 映射文件的 ID 可以重复，因为每个 XML 映射文件都是独立的，它们之间没有关联。但是在同一个 XML 映射文件中，ID 是不能重复的，因为 ID 是用来唯一标识一个 SQL 语句的。如果在同一个 XML 映射文件中出现了重复的 ID，会导致解析 XML 映射文件的时候出现异常，从而无法正常执行 SQL 语句。</p>
<h3 id="716-简述-mybatis-的-xml-映射文件和-mybatis-内部数据结构之间的映射关系">
  7.16 简述 Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系
  <a href="#716-%e7%ae%80%e8%bf%b0-mybatis-%e7%9a%84-xml-%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6%e5%92%8c-mybatis-%e5%86%85%e9%83%a8%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b9%8b%e9%97%b4%e7%9a%84%e6%98%a0%e5%b0%84%e5%85%b3%e7%b3%bb" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Mybatis 的 Xml 映射文件和 Mybatis 内部数据结构之间的映射关系可以通过 Mybatis 的 Configuration 对象进行管理。当 Mybatis 加载配置文件时，它会创建 Configuration 对象，将其中的映射文件信息解析成内部数据结构，并将其缓存到 Configuration 对象中。同时，Mybatis 会为每个映射文件中定义的 select、insert、update、delete 等语句创建对应的 MappedStatement 对象，并将其也缓存到 Configuration 对象中。</p>
<p>​		每个 MappedStatement 对象都包含了对应的 SQL 语句以及输入参数和输出结果的映射关系。当应用程序发起一个数据库操作请求时，Mybatis 会根据请求的 statementId（即映射文件中定义的 id 属性）从 Configuration 对象中获取对应的 MappedStatement 对象，进而得知 SQL 语句以及输入参数和输出结果的映射关系。Mybatis 会将输入参数转化为 SQL 语句中对应的占位符，并执行 SQL 语句，最终将数据库返回的结果转化为 Java 对象，并返回给应用程序。</p>
<p>​		因此，可以看出 Mybatis 的 Xml 映射文件和内部数据结构之间的映射关系是通过 Configuration 对象来维护和管理的。而每个映射文件中的 id 属性需要保证唯一，否则会导致映射文件解析错误。</p>
<h3 id="717-介绍一下-configuration-对象">
  7.17 介绍一下 Configuration 对象
  <a href="#717-%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-configuration-%e5%af%b9%e8%b1%a1" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 MyBatis 中，Configuration 对象是 MyBatis 的核心对象之一，它在 MyBatis 启动时被创建，并被用来存储 MyBatis 的所有配置信息，如数据库连接信息、映射器、插件、属性、缓存等等。Configuration 对象还提供了对映射语句和结果映射的解析，以及对插件和缓存的管理等功能。</p>
<p>​		Configuration 对象的主要作用是存储 MyBatis 的全局配置信息，同时还负责管理多个映射器（Mapper）和多个 SQL 语句的映射，提供了对映射器的管理和对 SQL 语句的解析、编译和执行等功能。在 MyBatis 启动时，Configuration 对象会读取并解析 MyBatis 配置文件，根据配置文件中的配置信息初始化自身的属性，并初始化所有的 Mapper 接口，生成 MapperProxy 对象并存储在内部的 Map 中，以便后续使用。</p>
<p>​		此外，Configuration 对象还提供了一些方法来获取和管理各种类型的对象，如：获取所有的 Mapper 接口、获取 TypeHandler 解析器、获取全局配置信息、获取所有已经映射的 Statement、获取所有的缓存实现类、获取所有的插件等。</p>
<p>​		需要注意的是，每个 SqlSession 对象都有自己的 Configuration 对象实例，即每个 SqlSession 对象都是独立的，它们之间的 Configuration 对象实例是不共享的。这也就意味着，在不同的 SqlSession 中，即使是相同的 Mapper 接口，也会有不同的代理对象实例。</p>
<h3 id="718-xml-映射文件中除了常见的-selectinsertupdatedelete-标签之外还有哪些标签">
  7.18 Xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签
  <a href="#718-xml-%e6%98%a0%e5%b0%84%e6%96%87%e4%bb%b6%e4%b8%ad%e9%99%a4%e4%ba%86%e5%b8%b8%e8%a7%81%e7%9a%84-selectinsertupdatedelete-%e6%a0%87%e7%ad%be%e4%b9%8b%e5%a4%96%e8%bf%98%e6%9c%89%e5%93%aa%e4%ba%9b%e6%a0%87%e7%ad%be" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>除了常见的 select、insert、update、delete 标签，Mybatis 的 Xml 映射文件中还有以下标签：</p>
<ol>
<li>resultMap：用于定义结果集映射规则，将查询结果集映射到 Java 对象中。</li>
<li>parameterMap：用于定义入参映射规则，将 Java 对象映射成查询参数。</li>
<li>sql：用于定义可重用的 SQL 片段，可以在其他语句中引用，提高代码复用性。</li>
<li>include：用于将其他的 SQL 片段引入到当前语句中，提高代码复用性。</li>
<li>cache：用于配置二级缓存，缓存查询结果以提高查询性能。</li>
<li>flushCache：用于配置是否刷新缓存。</li>
<li>selectKey：用于在插入数据时获取自增主键的值。</li>
<li>update 和 insert 标签的 useGeneratedKeys 属性：用于在插入数据时获取自增主键的值。</li>
</ol>
<p>除此之外，Mybatis 还支持一些高级功能的标签，如动态 SQL 标签、插件标签等。</p>
<h3 id="719-mybatis-能执行一对多一对一的联系查询吗有哪些实现方法">
  7.19 Mybatis 能执行一对多，一对一的联系查询吗，有哪些实现方法
  <a href="#719-mybatis-%e8%83%bd%e6%89%a7%e8%a1%8c%e4%b8%80%e5%af%b9%e5%a4%9a%e4%b8%80%e5%af%b9%e4%b8%80%e7%9a%84%e8%81%94%e7%b3%bb%e6%9f%a5%e8%af%a2%e5%90%97%e6%9c%89%e5%93%aa%e4%ba%9b%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>MyBatis 可以执行一对多、一对一等联系查询，以下是一些实现方法：</p>
<ol>
<li>嵌套查询（Nested Query）：使用 select 标签嵌套 select 标签进行一对多或多对一查询，需要在嵌套查询中使用外部查询的参数进行筛选，且存在N+1问题。</li>
<li>嵌套结果（Nested Result）：使用 association 和 collection 标签实现一对多和多对一查询。association 用于表示一对一关系，collection 用于表示一对多关系。此方法会将多条数据查询出来然后组装成一个对象，但存在 SQL 语句重复执行的问题。</li>
<li>ResultMap：使用 ResultMap 来映射查询结果，可以通过 resultMap 中定义的 association 和 collection 标签，一次性查询出所有相关的信息，避免了 SQL 语句重复执行的问题。</li>
<li>Discriminator：使用 Discriminator 标签实现根据查询结果不同来判断使用哪个 ResultMap 映射查询结果，适合使用在一对多查询中的多个子类型返回的情况。</li>
</ol>
<p>​		总之，Mybatis 提供了多种实现一对多和一对一联系查询的方法，开发者可以根据具体业务需求选择不同的方式。</p>
<h3 id="720-mybatis-是否可以映射-enum-枚举类">
  7.20 Mybatis 是否可以映射 Enum 枚举类
  <a href="#720-mybatis-%e6%98%af%e5%90%a6%e5%8f%af%e4%bb%a5%e6%98%a0%e5%b0%84-enum-%e6%9e%9a%e4%b8%be%e7%b1%bb" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Mybatis 可以映射 Enum 枚举类。在映射文件中，可以使用<code>#{}</code>或<code>${}</code>获取枚举对象，具体取决于使用的参数类型。</p>
<p>例如，如果枚举类是这样定义的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> Gender <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    MALE<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;M&#34;</span><span style="color:#f92672">),</span>
</span></span><span style="display:flex;"><span>    FEMALE<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;F&#34;</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String code<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Gender<span style="color:#f92672">(</span>String code<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">code</span> <span style="color:#f92672">=</span> code<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> code<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>那么，在 Mybatis 映射文件中可以这样使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;insert</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;insertUser&#34;</span> <span style="color:#a6e22e">parameterType=</span><span style="color:#e6db74">&#34;User&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    insert into user (name, gender) values (#{name}, #{gender, typeHandler=org.apache.ibatis.type.EnumTypeHandler})
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/insert&gt;</span>
</span></span></code></pre></div><p>​		在这个例子中，<code>#{gender}</code>表示获取<code>User</code>对象中的<code>gender</code>属性，<code>org.apache.ibatis.type.EnumTypeHandler</code>是Mybatis内置的枚举类型处理器，用于将Java中的枚举值映射到数据库中。</p>
<h3 id="721-mybatis-动态-sql-是做什么的都有哪些动态-sql能简述一下动态-sql-的执行原理吗">
  7.21 Mybatis 动态 sql 是做什么的，都有哪些动态 sql，能简述一下动态 sql 的执行原理吗
  <a href="#721-mybatis-%e5%8a%a8%e6%80%81-sql-%e6%98%af%e5%81%9a%e4%bb%80%e4%b9%88%e7%9a%84%e9%83%bd%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8a%a8%e6%80%81-sql%e8%83%bd%e7%ae%80%e8%bf%b0%e4%b8%80%e4%b8%8b%e5%8a%a8%e6%80%81-sql-%e7%9a%84%e6%89%a7%e8%a1%8c%e5%8e%9f%e7%90%86%e5%90%97" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Mybatis 动态 SQL 是为了解决在构建 SQL 语句时需要根据实际情况动态添加 SQL 片段的需求。Mybatis 提供了一组标签来支持动态SQL，包括 if、choose、when、otherwise、foreach、trim、where、set 等。可以根据实际需求灵活组合使用。</p>
<p>​		动态 SQL 的执行原理主要分为两步：首先根据动态 SQL 标签生成一个包含占位符的 SQL 语句；其次，将占位符替换成具体的参数值，最终生成可执行的 SQL 语句。Mybatis 使用 OGNL 表达式语言对动态 SQL 标签中的表达式进行解析和计算，将结果与 SQL 语句组合生成最终的可执行 SQL。</p>
<p>​		举例来说，如果要根据不同的查询条件来动态构建 SQL 语句，可以使用if标签进行条件判断，使用 where 标签来生成 WHERE 子句。示例如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;select</span> <span style="color:#a6e22e">id=</span><span style="color:#e6db74">&#34;queryUserList&#34;</span> <span style="color:#a6e22e">resultMap=</span><span style="color:#e6db74">&#34;userResultMap&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  SELECT * FROM user
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&lt;where&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;if</span> <span style="color:#a6e22e">test=</span><span style="color:#e6db74">&#34;name != null and name != &#39;&#39;&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      AND name like &#39;%${name}%&#39;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/if&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;if</span> <span style="color:#a6e22e">test=</span><span style="color:#e6db74">&#34;age != null&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>      AND age = #{age}
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/if&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&lt;/where&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/select&gt;</span>
</span></span></code></pre></div><p>​		这段代码中，if 标签用于根据不同的查询条件生成不同的 SQL 语句，where 标签用于生成 WHERE 子句，test 属性指定了条件判断的表达式。</p>
<p>​		对于动态 SQL 的标签组合，Mybatis 会根据标签类型和位置进行组合，生成包含占位符的 SQL 语句。例如上面的示例中，如果没有满足查询条件的数据，生成的 SQL 语句可能是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">user</span>
</span></span></code></pre></div><p>​		而如果查询条件包含名称和年龄，生成的 SQL 语句可能是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">user</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">WHERE</span> name <span style="color:#66d9ef">like</span> <span style="color:#e6db74">&#39;%张三%&#39;</span> <span style="color:#66d9ef">AND</span> age <span style="color:#f92672">=</span> <span style="color:#ae81ff">18</span>
</span></span></code></pre></div><p>​		动态 SQL 的实现原理相对复杂，但使用起来非常方便灵活。通过合理使用动态 SQL 标签，可以在不同的查询条件下动态构建 SQL 语句，大大提高了 SQL 语句的复用性和灵活性。</p>
<h3 id="722-mybatis-是如何进行分页的分页插件的原理是什么">
  7.22 Mybatis 是如何进行分页的，分页插件的原理是什么
  <a href="#722-mybatis-%e6%98%af%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e5%88%86%e9%a1%b5%e7%9a%84%e5%88%86%e9%a1%b5%e6%8f%92%e4%bb%b6%e7%9a%84%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Mybatis 支持两种方式进行分页：基于物理分页和基于逻辑分页。</p>
<ol>
<li>基于物理分页</li>
</ol>
<p>基于物理分页是指在 SQL 语句中使用 LIMIT 子句来实现分页，具体语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> column1, column2, ... <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table_name</span> <span style="color:#66d9ef">LIMIT</span> <span style="color:#66d9ef">offset</span>, <span style="color:#66d9ef">row_count</span>;
</span></span></code></pre></div><p>其中，offset 表示偏移量，row_count 表示行数。假设每页显示 n 条记录，那么第 i 页的查询语句就应该是：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> column1, column2, ... <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table_name</span> <span style="color:#66d9ef">LIMIT</span> (i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>n, n;
</span></span></code></pre></div><p>Mybatis 中使用基于物理分页需要在 SQL 语句中手动添加 LIMIT 子句，具体实现可以使用 RowBounds 类或者自定义插件来实现。</p>
<ol start="2">
<li>基于逻辑分页</li>
</ol>
<p>​		基于逻辑分页是指在查询结果集中，只取出当前页需要的数据，而不是查询全部数据后再进行分页，这种方式也称为内存分页。Mybatis 中可以使用 <code>PageHelper</code> 插件来实现基于逻辑分页。</p>
<p>​		分页插件的原理是通过拦截 Executor 对象的 <code>query()</code> 方法，在执行 SQL 之前修改 SQL 语句，增加分页的语句，如 LIMIT 子句。同时，在查询结果返回前，将分页的结果集保存到 Page 对象中。分页插件通常会提供很多配置项，如页码参数名、每页记录数参数名、是否启用 count 查询等，可以根据需求进行设置。</p>
<h3 id="723-简述-mybatis-的插件运行原理">
  7.23 简述 Mybatis 的插件运行原理
  <a href="#723-%e7%ae%80%e8%bf%b0-mybatis-%e7%9a%84%e6%8f%92%e4%bb%b6%e8%bf%90%e8%a1%8c%e5%8e%9f%e7%90%86" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Mybatis 的插件可以在四个对象上进行拦截处理，这四个对象分别是：Executor、StatementHandler、ParameterHandler 和 ResultSetHandler。插件通过动态代理，将需要拦截的对象进行代理，当方法被执行时，会通过插件的拦截器链进行拦截和处理。</p>
<p>插件运行原理：</p>
<ol>
<li>编写拦截器实现类，实现 Mybatis 提供的 Interceptor 接口，并在实现类上添加 @Intercepts 注解，指定需要拦截的方法和参数类型；</li>
<li>通过 Mybatis 提供的 Plugin 类，调用 wrap 方法生成代理对象，并传入拦截器实现类；</li>
<li>将生成的代理对象添加到 Mybatis 的插件列表中。</li>
</ol>
<p>​		在 Mybatis 初始化时，会通过 Configuration 对象获取插件列表，当执行数据库操作时，会通过插件列表对需要拦截的对象进行代理，并按照插件配置的顺序进行拦截处理。</p>
<h3 id="724-mybatis-的一级二级缓存懒加载">
  7.24 Mybatis 的一级、二级缓存，懒加载
  <a href="#724-mybatis-%e7%9a%84%e4%b8%80%e7%ba%a7%e4%ba%8c%e7%ba%a7%e7%bc%93%e5%ad%98%e6%87%92%e5%8a%a0%e8%bd%bd" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		MyBatis 的缓存分为一级缓存和二级缓存。其中，一级缓存是基于 SqlSession 的缓存，是一个内置的缓存机制。二级缓存是基于 Mapper namespace 的缓存，是一个全局的缓存机制。</p>
<p>​		一级缓存是 SqlSession 范围内的缓存，它可以减少对数据库的重复查询，提升系统性能。默认情况下，一级缓存是开启的，它会缓存查询到的结果集，如果对同一个查询语句进行了多次查询，那么第二次及以后的查询都可以从缓存中获取结果，而不需要再次向数据库发出查询请求。但是，当同一个 SqlSession 进行了修改、删除、插入操作后，缓存将会被清空。</p>
<p>​		二级缓存是 Mapper namespace 范围内的缓存，它是一个全局的缓存机制，不同的 SqlSession 可以共享同一个二级缓存。默认情况下，二级缓存是关闭的，需要手动配置开启。二级缓存可以减少对数据库的访问次数，提高查询效率，但是它也有缺点，因为多个 SqlSession 可以共享同一个缓存，所以在并发环境下会出现脏读的问题，需要进行适当的控制。</p>
<p>​		懒加载是一种优化技术，它可以减少查询语句的数量，提升查询效率。在 MyBatis 中，通过在 Mapper XML 文件中配置 lazyLoadingEnabled 和 aggressiveLazyLoading 属性来控制懒加载行为。当 lazyLoadingEnabled 为 true 时，表示启用懒加载；当 aggressiveLazyLoading 为 true 时，表示懒加载的对象被多次引用时也会触发懒加载，这样可以避免一次性查询大量数据导致性能问题。懒加载的实现原理是基于动态代理技术，当需要访问延迟加载的属性时，MyBatis 会通过动态代理生成代理对象，在代理对象中实现延迟加载的逻辑。</p>
<h3 id="725-restful-api-规范">
  7.25 RESTful API 规范
  <a href="#725-restful-api-%e8%a7%84%e8%8c%83" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​	GET-SELEST、POST-INSERT、PUT-UPDATE、DELECT-DELECT</p>
<h1 id="第8章-redis">
  第8章 Redis
  <a href="#%e7%ac%ac8%e7%ab%a0-redis" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="81-redis-常用的数据结构有哪些">
  8.1 Redis 常用的数据结构有哪些
  <a href="#81-redis-%e5%b8%b8%e7%94%a8%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%9c%89%e5%93%aa%e4%ba%9b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<ul>
<li>5 种基础数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li>3 种特殊数据结构：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li>
</ul>
<p>​		这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p>
<p>Redis 基本数据结构的底层数据结构实现如下：</p>
<!-- raw HTML omitted -->
<p>​		Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。</p>
<h3 id="82-redis-的-list-是用什么实现的有什么特点">
  8.2 Redis 的 list 是用什么实现的，有什么特点
  <a href="#82-redis-%e7%9a%84-list-%e6%98%af%e7%94%a8%e4%bb%80%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84%e6%9c%89%e4%bb%80%e4%b9%88%e7%89%b9%e7%82%b9" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Redis 的 List 是通过<strong>双向链表</strong>来实现的，每个节点包含一个值和两个指针，分别指向前一个节点和后一 个节点。Redis 的 List 是支持在两端进行快速添加和删除元素的，因为它们是通过双向链表来实现的。此外，Redis 的 List 还支持一些其他的操作，如从列表的开头或结尾弹出元素、获取列表的元素数量等。</p>
<p>Redis 的 List 有以下特点：</p>
<ol>
<li>线性结构：Redis 的 List 是一种线性结构，它按照元素的添加顺序排列。</li>
<li>支持重复元素：Redis 的 List 是允许重复元素的，因为它是一个链表而不是集合。</li>
<li>支持高效的头尾操作：由于 Redis 的 List 是通过双向链表来实现的，因此在头部或尾部添加或删除元素都非常高效。</li>
<li>索引访问：Redis 的 List 还支持通过索引来访问元素，这使得它可以作为一个数组来使用。</li>
<li>支持阻塞式操作：Redis 的 List 还支持阻塞式操作，可以在列表为空时进行弹出元素的操作，并阻塞等待直到列表中有新元素可用为止。</li>
</ol>
<h3 id="83-为什么要用-redis-缓存">
  8.3 为什么要用 Redis 缓存
  <a href="#83-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-redis-%e7%bc%93%e5%ad%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Redis 是一种高性能的缓存数据库，其主要优点包括：</p>
<ol>
<li>高性能：Redis 的数据存储在内存中，可以达到非常高的读写速度，特别适合高并发、大流量的场景。</li>
<li>数据结构丰富：Redis 支持多种数据结构，包括字符串、哈希表、列表、集合和有序集合等，可以满足各种不同的需求。</li>
<li>持久化支持：Redis 支持数据的持久化，可以将数据存储到磁盘上，保证数据的可靠性和持久性。</li>
<li>分布式支持：Redis 支持分布式部署，可以将数据分布到多个节点上，提高系统的可扩展性和可用性。</li>
<li>丰富的功能：Redis 还提供了丰富的功能，如发布/订阅、事务、Lua 脚本、集群管理等，可以满足各种不同的需求。</li>
</ol>
<p>​		因此，Redis 是一种非常适合用作缓存的数据库，可以提高系统的性能和可扩展性。在实际项目中，可以将经常访问的数据放到Redis中，从而减轻数据库的压力，提高系统的吞吐量。</p>
<h3 id="84-为什么要用-redis-而不用-mapguava-做缓存">
  8.4 为什么要用 Redis 而不用 map/guava 做缓存
  <a href="#84-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-redis-%e8%80%8c%e4%b8%8d%e7%94%a8-mapguava-%e5%81%9a%e7%bc%93%e5%ad%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Redis 相比于使用 Java 内存数据结构（如 Map 或 Guava Cache）作为缓存有以下优点：</p>
<ol>
<li>Redis 支持数据持久化：Redis 提供了多种持久化方式，可以将内存中的数据异步或同步地保存到硬盘中，避免了数据丢失的风险。</li>
<li>Redis 支持高并发：Redis 的单线程模型虽然看起来不如多线程的缓存实现性能高，但是 Redis 实现了高效的 I/O 多路复用机制，能够处理高并发请求。</li>
<li>Redis 支持分布式：Redis 支持数据分片、主从复制和 Sentinel 高可用等功能，可以构建高可用的分布式缓存系统。</li>
<li>Redis 支持更多的数据结构和操作：Redis 支持字符串、列表、哈希表、集合和有序集合等多种数据结构，支持丰富的操作，如原子操作、过期时间、分布式锁等。</li>
</ol>
<p>​		综上所述，Redis 相比于 Java 内存数据结构作为缓存，具有更好的<strong>数据持久化</strong>、<strong>高并发</strong>、<strong>分布式</strong>和更丰富的<strong>数据结构和操作</strong>等优点。</p>
<h3 id="85-redis-和-memcached-的区别">
  8.5 Redis 和 memcached 的区别
  <a href="#85-redis-%e5%92%8c-memcached-%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Redis 和 Memcached 都是分布式内存缓存系统，主要用于缓存数据加速访问。它们的主要区别如下：</p>
<ol>
<li>数据类型：Redis支持多种数据类型，包括 String（字符串）、List（列表）、Set（集合）、Hash（哈希表）和 Zset（有序集合）。而 Memcached 只支持键值对存储。</li>
<li>内存管理：Redis 采用内存淘汰机制来控制内存使用，当内存不足时，Redis 会自动删除最久未使用的键值对。而 Memcached 使用LRU（Least Recently Used）算法来管理内存。</li>
<li>存储容量：Redis 最大支持 512 MB，而 Memcached 最大支持 1 GB。</li>
<li>存储持久化：Redis 支持 **RDB（Redis DataBase）**和 **AOF（Append Only File）**两种持久化方式，RDB 是在指定的时间间隔内将数据集快照写入磁盘，而 AOF 则是将每个写操作追加到磁盘文件中。而 Memcached 不支持数据持久化。</li>
<li>高级功能：Redis 支持事务、发布/订阅、Lua 脚本等高级功能，而 Memcached 不支持这些高级功能。</li>
<li>性能表现：由于 Redis 支持多种数据类型，所以在某些场景下，Redis 的性能表现更优，比如对于某些需要用到集合、哈希表等数据类型的场景。而对于纯粹的键值对缓存场景，Memcached 的性能可能更好。</li>
</ol>
<p>​		综上所述，Redis 和 Memcached 都有各自的优势和适用场景。在选择缓存系统时，应根据具体业务需求和场景选择合适的方案。</p>
<h3 id="86-redis-常见数据结构以及使用场景分析stringhashlistsetsorted-set">
  8.6 Redis 常见数据结构以及使用场景分析（String，Hash，List，Set，Sorted Set）
  <a href="#86-redis-%e5%b8%b8%e8%a7%81%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%bb%a5%e5%8f%8a%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af%e5%88%86%e6%9e%90stringhashlistsetsorted-set" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Redis 支持的常见数据结构包括 String、Hash、List、Set 和 Sorted Set，它们的使用场景如下：</p>
<ol>
<li>String：适用于存储<strong>单个</strong>的字符串值，比如存储用户的姓名、年龄等信息，也可以用于存储整数和浮点数等数据类型。</li>
<li>Hash：适用于存储<strong>多个</strong>字段和值的对象，比如存储用户的详细信息，可以将每个字段存储为一个键值对。</li>
<li>List：适用于存储<strong>列表</strong>类型的数据，比如存储用户的消息队列，可以用于实现队列、栈等数据结构。</li>
<li>Set：适用于存储<strong>多个唯一</strong>的值的集合，比如存储用户的喜好、标签等信息。</li>
<li>Sorted Set：适用于存储多个唯一的值，并且可以根据得分（score）排序的集合，比如存储用户的排行榜、热门商品等信息。</li>
</ol>
<p>​		在实际应用中，可以根据具体的业务需求选择合适的数据结构。同时，Redis 还提供了丰富的命令和功能，可以方便地对这些数据结构进行操作和管理。</p>
<h3 id="87-redis-设置过期时间">
  8.7 Redis 设置过期时间
  <a href="#87-redis-%e8%ae%be%e7%bd%ae%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		在 Redis 中，可以使用 <code>EXPIRE</code> 命令为键设置过期时间。该命令需要两个参数：键和过期时间。过期时间可以指定为秒或毫秒。例如，以下命令会为键 <code>mykey</code> 设置过期时间为 10 秒：</p>
<pre tabindex="0"><code>EXPIRE mykey 10
</code></pre><p>​		还可以使用 <code>SETEX</code> 命令为键设置过期时间，该命令需要三个参数：键、过期时间和值。例如，以下命令会为键 <code>mykey</code> 设置过期时间为 10 秒，并将值设置为 <code>hello</code>：</p>
<pre tabindex="0"><code>SETEX mykey 10 hello
</code></pre><p>​		在使用 Redis 客户端设置键值时，通常会提供一个可选的参数来指定过期时间，例如 <code>SET mykey hello EX 10</code>，其中 <code>EX 10</code> 表示过期时间为 10 秒。</p>
<h3 id="88-redis-内存淘汰机制-mysql-里有2000w数据redis-中只存20w的数据如何保证-redis-中的数据都是热点数据">
  8.8 Redis 内存淘汰机制（ MySQL 里有2000w数据，Redis 中只存20w的数据，如何保证 Redis 中的数据都是热点数据）
  <a href="#88-redis-%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e6%9c%ba%e5%88%b6-mysql-%e9%87%8c%e6%9c%892000w%e6%95%b0%e6%8d%aeredis-%e4%b8%ad%e5%8f%aa%e5%ad%9820w%e7%9a%84%e6%95%b0%e6%8d%ae%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81-redis-%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e9%83%bd%e6%98%af%e7%83%ad%e7%82%b9%e6%95%b0%e6%8d%ae" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Redis 内存淘汰机制是 Redis 中一种重要的机制，它主要是用来解决 Redis 内存占用过多的问题，通过一些策略去淘汰一些数据，让出内存空间，以便给新数据使用。</p>
<p>Redis 支持多种不同的内存淘汰策略，如下：</p>
<ol>
<li>noeviction（默认）：表示不做淘汰处理，新的写入操作如果导致 Redis 内存不足时会直接返回错误信息。</li>
<li>allkeys-lru：表示在所有键空间中按照 LRU 算法淘汰数据，即最近最少使用的数据会被淘汰。</li>
<li>allkeys-random：表示在所有键空间中随机淘汰数据。</li>
<li>volatile-lru：表示在设置了过期时间的键空间中按照 LRU 算法淘汰数据。</li>
<li>volatile-random：表示在设置了过期时间的键空间中随机淘汰数据。</li>
<li>volatile-ttl：表示在设置了过期时间的键空间中按照键值的过期时间淘汰数据，越早过期的数据越优先被淘汰。</li>
</ol>
<p>​		对于 MySQL 中有 2000w 条数据，但 Redis 只存储 20w 条数据的情况，如何保证 Redis 中的数据都是热点数据，可以采取以下两种方式：</p>
<ol>
<li>设置合理的过期时间：将 Redis 中的数据设置合理的过期时间，让不常用的数据自动过期，减少 Redis 中冷数据的存储量。</li>
<li>根据业务场景设置优先级：根据业务场景设置不同数据的优先级，比如热门商品、热门文章等，将优先级高的数据存储到 Redis 中，降低冷数据的存储量。可以采用 Redis 的 Sorted Set 数据结构来实现，将优先级作为 Score，将数据作为 Member，实现优先级排序和淘汰。</li>
</ol>
<p>​		综上所述，通过合理设置过期时间和优先级，可以保证 Redis 中存储的数据都是热点数据，提高 Redis 的性能和使用效率。</p>
<h3 id="89-redis-持久化机制怎么保证-redis-挂掉之后再重启数据可以进行恢复">
  8.9 Redis 持久化机制（怎么保证 redis 挂掉之后再重启数据可以进行恢复）
  <a href="#89-redis-%e6%8c%81%e4%b9%85%e5%8c%96%e6%9c%ba%e5%88%b6%e6%80%8e%e4%b9%88%e4%bf%9d%e8%af%81-redis-%e6%8c%82%e6%8e%89%e4%b9%8b%e5%90%8e%e5%86%8d%e9%87%8d%e5%90%af%e6%95%b0%e6%8d%ae%e5%8f%af%e4%bb%a5%e8%bf%9b%e8%a1%8c%e6%81%a2%e5%a4%8d" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Redis提供了两种持久化机制：RDB（Redis DataBase）和 AOF（Append Only File）。</p>
<ol>
<li>RDB 持久化：将当前时刻的数据快照（snapshot）保存到硬盘上，以便在 Redis 重启时恢复使用。在设定的时间间隔内，如果有一定量的键值对被修改，则Redis会执行一个后台进程来创建 RDB 文件。RDB 的优点是对于数据恢复速度较快，缺点是会丢失最后一次快照之后的所有数据。</li>
<li>AOF 持久化：将 Redis 执行的每个写命令都记录到 AOF 文件中。当 Redis 重新启动时，可以重新执行所有的写命令，从而恢复数据。AOF 提供了比 RDB 更可靠的数据保护，但由于记录每个写命令，因此可能会降低 Redis 的性能。</li>
</ol>
<p>​		在实际使用中，为了更好地保证数据的可靠性和恢复性，通常会同时使用 RDB 和 AOF 持久化机制，以便在一个持久化机制出现问题时，能够及时进行恢复。可以在 Redis 配置文件中配置持久化机制以及对应的参数，如 RDB 文件名和路径、AOF 文件名和路径、AOF 重写条件等。</p>
<p>​		对于如何保证 Redis 在重启后数据可以进行恢复，可以在 Redis 启动时通过加载持久化文件进行恢复。如果同时使用 RDB 和 AOF 持久化，Redis 会先尝试使用 AOF 文件进行恢复，如果 AOF 文件不存在或者损坏，则会尝试使用 RDB 文件进行恢复。如果两者都不存在，则 Redis 会启动一个空数据库。因此，为了保证 Redis 可以在重启后恢复数据，需要定期进行数据持久化，并备份好持久化文件，以便在需要时进行恢复。</p>
<h3 id="810-redis-事务">
  8.10 Redis 事务
  <a href="#810-redis-%e4%ba%8b%e5%8a%a1" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		事务（Transaction）是一组数据库操作，它们被视为一个逻辑单元，要么全部执行成功，要么全部回滚，即执行失败后回滚到事务开始前的状态。事务可以用来确保数据的一致性和完整性，即使在并发环境下也能保证数据的正确性。事务通常具有以下四个特性，通常被称为ACID特性：</p>
<ul>
<li>
<p>原子性（Atomicity）：一个事务中的所有操作要么全部成功，要么全部失败，不允许部分成功部分失败。</p>
</li>
<li>
<p>一致性（Consistency）：事务执行后，数据库的状态必须是一致的，即满足所有的约束条件和完整性规则。</p>
</li>
<li>
<p>隔离性（Isolation）：多个事务并发执行时，它们之间应该互相隔离，一个事务的执行不应该影响其他事务的执行。</p>
</li>
<li>
<p>持久性（Durability）：事务完成后，对数据库的修改应该是永久性的，即使系统出现故障或崩溃，数据也不应该丢失。</p>
</li>
</ul>
<p>​		事务通常通过将一组操作打包到一个单独的执行单元来实现，这些操作可以是读取、写入或修改数据库中的数据。在执行期间，这些操作被视为一个整体，要么全部成功，要么全部失败。如果事务中的任何一个操作失败，整个事务就会回滚到事务开始前的状态，这可以确保数据的一致性和完整性。</p>
<h3 id="811-为什么可以使用-redis-的-setnx-命令来实现分布式锁">
  8.11 为什么可以使用 Redis 的 SETNX 命令来实现分布式锁？
  <a href="#811-%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8f%af%e4%bb%a5%e4%bd%bf%e7%94%a8-redis-%e7%9a%84-setnx-%e5%91%bd%e4%bb%a4%e6%9d%a5%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Redis的<code>SETNX</code>命令（SET if Not eXists）可以用于设置一个 key - value 对，只有当指定的 key 不存在时才会进行设置。这个命令的特点是原子性的，可以保证在多个客户端同时尝试获取同一个锁时，只有一个客户端能够成功地设置该 key，而其他客户端会因为该 key已经存在而设置失败。因此，<code>SETNX</code>命令可以用来实现分布式锁，其中 key 表示锁的名称，value 表示一个唯一的标识符，可以是一个随机数或 UUID。</p>
<p>​		当一个客户端成功地使用<code>SETNX</code>命令设置了锁的 key 时，该客户端可以认为自己获得了锁，并且需要设置一个过期时间，以确保锁能够在一定时间后自动释放，即使持有锁的客户端异常终止或断开连接。在这个过期时间内，其他客户端无法获得该锁，因为它们无法使用<code>SETNX</code>命令设置该 key。</p>
<p>​		使用<code>SETNX</code>命令实现分布式锁的优点是实现简单，适用于只有一个客户端能够获得锁的场景。但是，它无法支持锁的续租和删除，需要手动处理锁的过期时间和删除操作。因此，在实际生产环境中，更常使用带有过期时间的<code>SET</code>命令和<code>DEL</code>命令来实现分布式锁。</p>
<h3 id="812-redis-中单点和集群的区别">
  8.12 Redis 中单点和集群的区别
  <a href="#812-redis-%e4%b8%ad%e5%8d%95%e7%82%b9%e5%92%8c%e9%9b%86%e7%be%a4%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Redis 是一款高性能的 NoSQL 数据库，支持单点和集群部署。在单点部署中，Redis 只运行在一个节点上，所有的数据都存储在该节点的内存中。而在集群部署中，Redis 可以运行在多个节点上，数据会被分散存储在不同的节点中，以实现水平扩展和高可用性。</p>
<p>下面是单点和集群部署的主要区别：</p>
<ol>
<li>性能和容量：单点 Redis 的性能和容量受限于单个节点的内存和 CPU，而集群 Redis 可以水平扩展，支持在多个节点上存储和处理数据，因此具有更高的性能和容量。</li>
<li>高可用性：在单点 Redis 中，如果节点故障或宕机，整个系统就会失效。而在集群 Redis 中，即使某个节点宕机，系统仍然可以继续运行，因为数据会被复制到其他节点，并在其他节点上实现自动故障转移。</li>
<li>部署和维护：单点 Redis 只需要在一个节点上安装和部署，维护起来相对简单。而集群 Redis 需要在多个节点上安装和部署，并需要进行集群配置和管理，维护起来较为复杂。</li>
<li>一致性和可靠性：在单点 Redis 中，数据写入和读取是一致的，并且对于单个节点的操作是可靠的。而在集群 Redis 中，由于数据分散在不同的节点中，因此需要确保数据的一致性和可靠性，以避免数据丢失或数据冲突的问题。</li>
</ol>
<p>​		总的来说，单点 Redis 适用于小规模应用和开发阶段，而集群 Redis 适用于大规模应用和生产环境。</p>
<h3 id="813-redis-生产问题">
  8.13 Redis 生产问题
  <a href="#813-redis-%e7%94%9f%e4%ba%a7%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<ul>
<li>缓存穿透：</li>
</ul>
<p>​		缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<!-- raw HTML omitted -->
<ul>
<li>缓存击穿：</li>
</ul>
<p>​		缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据存在于数据库中，但<strong>不存在于缓存</strong>中（通常是因为缓存中的那份数据已经过期）。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<!-- raw HTML omitted -->
<ul>
<li>缓存雪崩：</li>
</ul>
<p>​		实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>​		另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>
<!-- raw HTML omitted -->
<h3 id="814-缓存雪崩和缓存穿透问题解决方案">
  8.14 缓存雪崩和缓存穿透问题解决方案
  <a href="#814-%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9%e5%92%8c%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f%e9%97%ae%e9%a2%98%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		缓存雪崩和缓存穿透是常见的缓存问题，需要采取一些措施来避免和解决。</p>
<p>​		缓存雪崩是指在同一时间内，缓存中的大量数据同时失效，导致大量请求直接落在数据库上，压垮数据库。为了避免缓存雪崩，可以采用以下方案：</p>
<ol>
<li>设置不同的缓存失效时间：避免在同一时间内，大量数据同时失效。</li>
<li>使用分布式锁：在缓存失效时，使用分布式锁来避免大量请求同时访问数据库。</li>
<li>热点数据永不过期：对于一些热点数据，可以设置永不过期。</li>
</ol>
<p>​		缓存穿透是指查询一个不存在的数据，导致所有的请求都落在数据库上。为了避免缓存穿透，可以采用以下方案：</p>
<ol>
<li>对于不存在的数据，也在缓存中设置一个值，如 null，避免对数据库的频繁访问。</li>
<li>使用布隆过滤器：在缓存层面使用布隆过滤器来过滤一些不存在的数据请求。</li>
<li>数据预热：在系统启动时，将一些常用的数据加载到缓存中，避免冷启动的缓存穿透问题。</li>
</ol>
<p>​		以上方案可以根据实际场景进行选择和结合使用，以达到更好的缓存效果。</p>
<h3 id="815-如何解决-redis-的并发竞争-key-问题">
  8.15 如何解决 Redis 的并发竞争 Key 问题
  <a href="#815-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3-redis-%e7%9a%84%e5%b9%b6%e5%8f%91%e7%ab%9e%e4%ba%89-key-%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Redis 的并发竞争 Key 问题主要是由于多个客户端同时对同一个 key 进行读写操作，导致数据的不一致性或者丢失。常见的解决方案有以下几种：</p>
<ol>
<li>锁机制：在 Redis 中，可以通过 SETNX（SET if Not eXists）或者 Lua 脚本来实现分布式锁机制。当一个客户端要对某个 key 进行写操作时，可以先加锁，其他客户端如果要对该 key 进行写操作，则需要等待锁释放后才能进行操作。但是这种方式需要注意死锁的问题。</li>
<li>使用 Redis 事务：通过 Redis 的事务机制可以实现对多个命令的原子性操作，即要么全部执行成功，要么全部失败。可以通过 Redis 的 WATCH 命令来监控一个 key，当这个 key 的值被其他客户端改变时，事务会被中断。这种方式可以避免并发竞争 key 时的数据不一致问题。</li>
<li>分片：将一个 Redis 的实例拆分成多个实例，每个实例存储部分数据。可以通过一致性哈希算法来进行分片，这样每个实例只需要处理一部分 key，从而降低了并发竞争 key 的概率。</li>
<li>增加 Redis 实例：增加 Redis 实例的数量可以增加 Redis 的吞吐量，从而减少并发竞争 key 的概率。可以使用 Redis 集群来实现自动分片和负载均衡。</li>
</ol>
<h3 id="816-如何保证缓存与数据库双写时的数据一致性">
  8.16 如何保证缓存与数据库双写时的数据一致性
  <a href="#816-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%bc%93%e5%ad%98%e4%b8%8e%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8f%8c%e5%86%99%e6%97%b6%e7%9a%84%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>在缓存与数据库双写时，为保证数据一致性，需要在以下两个方面做出保证：</p>
<ol>
<li>数据库写入后再写缓存：在数据写入数据库时，先将数据写入数据库，再将数据写入缓存，这样就能保证在缓存中的数据一定是最新的，从而保证了数据一致性。写入缓存时，可以使用 Redis 的“先删后加”机制，即先删除原有的缓存，再添加新的缓存。</li>
<li>先删除缓存再写数据库：在数据从数据库删除时，先删除缓存中的数据，然后再删除数据库中的数据。在数据更新时，先更新数据库中的数据，再删除缓存中的数据，这样下一次访问时就会从数据库中读取最新的数据并写入缓存，保证了数据一致性。</li>
</ol>
<p>​		需要注意的是，以上两种方式都需要确保操作的<strong>原子性</strong>，以避免因为多个操作之间的时间差导致数据不一致的情况。在实现时可以使用事务来保证操作的原子性。另外，需要注意缓存与数据库中数据的过期时间，以避免过期数据的读取与写入。</p>
<h3 id="817-通过异步处理提高系统性能削峰减少响应所需时间">
  8.17 通过异步处理提高系统性能（削峰、减少响应所需时间）
  <a href="#817-%e9%80%9a%e8%bf%87%e5%bc%82%e6%ad%a5%e5%a4%84%e7%90%86%e6%8f%90%e9%ab%98%e7%b3%bb%e7%bb%9f%e6%80%a7%e8%83%bd%e5%89%8a%e5%b3%b0%e5%87%8f%e5%b0%91%e5%93%8d%e5%ba%94%e6%89%80%e9%9c%80%e6%97%b6%e9%97%b4" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>通过异步处理可以提高系统的性能，主要有以下两种方式：</p>
<ol>
<li>削峰</li>
</ol>
<p>​		在高并发场景下，同一时间可能有大量的请求同时到达后端，如果这些请求全部同步处理，可能会导致服务器崩溃或者响应变慢。因此，可以使用消息队列来进行异步处理，将请求写入消息队列中，然后由后台服务异步地消费这些请求，避免大量请求同时到达后端造成的压力。</p>
<ol start="2">
<li>减少响应所需时间</li>
</ol>
<p>​		在某些场景下，请求的处理时间可能比较长，如果同步处理，客户端需要等待很长时间才能收到响应，这会降低用户的体验。因此，可以将请求放入异步队列中，由后台服务异步地进行处理，然后将处理结果返回给客户端。这样可以让客户端快速收到响应，而不用等待请求的处理完成。</p>
<p>​		以上两种方式都需要使用异步队列，将请求放入队列中，然后由后台服务异步地进行处理。常用的异步队列有消息队列和任务队列，其中消息队列主要用于解耦和削峰，而任务队列主要用于异步处理任务。</p>
<h3 id="818-降低系统耦合性">
  8.18 降低系统耦合性
  <a href="#818-%e9%99%8d%e4%bd%8e%e7%b3%bb%e7%bb%9f%e8%80%a6%e5%90%88%e6%80%a7" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		降低系统耦合性是一种软件设计原则，其目的是尽可能减少模块或组件之间的依赖关系，以便于维护和扩展系统。</p>
<p>以下是一些降低系统耦合性的方法：</p>
<ol>
<li>模块化设计：将系统划分为多个相互独立的模块，每个模块只关注自己的任务，并且通过接口来与其他模块通信。这样，每个模块的内部实现可以自由改变，而不会影响其他模块。</li>
<li>接口设计：定义清晰的接口，使得模块之间的通信只通过接口进行，而不需要知道对方的具体实现。接口的定义应该尽可能简单、清晰，遵循<strong>高内聚</strong>、<strong>低耦合</strong>的设计原则。</li>
<li>依赖注入：通过依赖注入的方式，将模块之间的依赖关系从代码中移除。这样可以减少代码中的硬编码，使得系统更加灵活和可扩展。</li>
<li>解耦框架：使用解耦框架来帮助降低系统的耦合性，如Spring框架，通过控制反转和依赖注入等机制，帮助开发者构建低耦合的应用程序。</li>
<li>发布-订阅模式：使用发布-订阅模式，将发布者和订阅者解耦。发布者只需要发布消息，而订阅者则可以自由选择订阅哪些消息，从而实现松散耦合。</li>
</ol>
<p>​		通过以上方法，可以帮助开发者设计出松散耦合的系统，使得系统更加易于维护和扩展。</p>
<h1 id="第9章-mq">
  第9章 MQ
  <a href="#%e7%ac%ac9%e7%ab%a0-mq" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="91-kafkarocket-mq-和-rabbit-mq-的区别">
  9.1 Kafka，Rocket MQ 和 Rabbit MQ 的区别
  <a href="#91-kafkarocket-mq-%e5%92%8c-rabbit-mq-%e7%9a%84%e5%8c%ba%e5%88%ab" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Kafka、Rocket MQ 和 Rabbit MQ 都是流行的消息队列系统，它们都提供了可靠的消息传递和高效的异步通信能力。以下是它们的主要区别：</p>
<ol>
<li>语言：Kafka 是用 Scala 编写的，Rocket MQ 是用 Java 编写的，而 Rabbit MQ 是用 Erlang 编写的。</li>
<li>架构：Kafka 和 Rocket MQ 都是分布式的，可以通过添加节点来扩展性能和容量。Rabbit MQ 是中心化的，所有消息都经过中央服务器进行路由和分发。</li>
<li>协议：Kafka 和 Rocket MQ 都使用自定义协议来实现消息传递，而 Rabbit MQ 使用 AMQP（Advanced Message Queuing Protocol）协议。</li>
<li>性能：Kafka 和 Rocket MQ 都具有高吞吐量和低延迟的特点，并且可以处理大量的消息。Rabbit MQ 则更注重消息传递的可靠性和稳定性。</li>
<li>功能：Kafka 和 Rocket MQ 都支持消息发布和订阅模型，而 Rabbit MQ 还支持一些高级特性，如队列优先级、延迟消息、RPC 等。</li>
<li>使用场景：Kafka 适用于大规模数据处理和流式数据处理场景。Rocket MQ 适用于互联网领域的异步通信和数据传输。Rabbit MQ 适用于企业内部通信和任务分发。</li>
</ol>
<p>​		总的来说，这三个消息队列系统都有自己的优势和适用场景，具体选择哪一个取决于应用的需求和场景。</p>
<!-- raw HTML omitted -->
<p>​		消息队列是一种用于在不同应用程序之间传递消息的技术。它基本上是一种在生产者和消费者之间传递异步消息的中间件，可以实现不同应用程序之间的解耦、并行处理、削峰填谷等功能。</p>
<p>消息队列可以应用于各种场景，包括但不限于以下情况：</p>
<ol>
<li>异步处理：当一个应用程序需要调用另一个应用程序完成某些任务，但不想等待该任务完成时，可以使用消息队列实现异步处理。</li>
<li>应用解耦：当两个或多个应用程序需要紧密集成时，消息队列可以用于解耦它们，使它们相互独立。</li>
<li>削峰填谷：当一个应用程序需要处理大量的请求时，可以使用消息队列平滑地处理这些请求，以避免系统过载。</li>
<li>数据缓冲：当一个应用程序需要将数据发送到另一个应用程序时，可以使用消息队列进行数据缓冲，从而避免因数据发送失败而导致的数据丢失。</li>
</ol>
<p>​		综上所述，消息队列是一种非常有用的技术，可以应用于各种场景，提高应用程序的可扩展性、可靠性和性能。</p>
<h3 id="93-消息队列有什么用">
  9.3 消息队列有什么用？
  <a href="#93-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>通常来说，使用消息队列能为我们的系统带来下面三点好处：</p>
<ol>
<li>通过异步处理提高系统性能。（减少响应所需时间）</li>
<li>削峰/限流。</li>
<li>降低系统耦合性。</li>
</ol>
<h3 id="94-消息队列会带来哪些问题">
  9.4 消息队列会带来哪些问题？
  <a href="#94-%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e4%bc%9a%e5%b8%a6%e6%9d%a5%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		系统可用性降低：系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了。</p>
<p>​		系统复杂性提高：加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</p>
<p>​		一致性问题：消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了。</p>
<h3 id="95-使用消息队列带来的一些问题">
  9.5 使用消息队列带来的一些问题
  <a href="#95-%e4%bd%bf%e7%94%a8%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e5%b8%a6%e6%9d%a5%e7%9a%84%e4%b8%80%e4%ba%9b%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>使用消息队列可以提高系统的性能和可伸缩性，但也会带来一些问题，例如：</p>
<ol>
<li>消息积压：如果消息队列处理不及时，消息可能会积压在队列中，导致系统变慢或者不可用。</li>
<li>消息丢失：由于网络等原因，消息有可能在传输过程中丢失，如果消息没有被正确处理和备份，可能会导致数据丢失。</li>
<li>消息重复：在某些情况下，消息可能会被重复发送，导致系统出现异常或者数据错误。</li>
<li>队列容量限制：由于存储的限制，消息队列可能无法处理大量数据，限制了系统的扩展能力。</li>
<li>维护复杂度增加：使用消息队列需要考虑到消息队列本身的维护和管理，增加了系统的复杂度和管理成本。</li>
</ol>
<p>​		为了解决这些问题，需要在系统设计和实现过程中，考虑到消息队列的容量、可用性、备份和监控等方面，以确保系统的高可用性和可靠性。同时，对于每个消息需要考虑到幂等性和重复性等问题，以确保数据的正确性和完整性。</p>
<h3 id="96-jms-两种消息模型">
  9.6 JMS 两种消息模型
  <a href="#96-jms-%e4%b8%a4%e7%a7%8d%e6%b6%88%e6%81%af%e6%a8%a1%e5%9e%8b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		JMS（Java Message Service）定义了两种消息模型：点对点（Point-to-Point，P2P）和发布/订阅（Publish/Subscribe，Pub/Sub）。</p>
<ol>
<li>点对点模型： 在点对点模型中，消息被发送到一个特定的接收者。发送者称为生产者，接收者称为消费者。生产者将消息发送到一个消息队列中，消费者从队列中接收消息。一条消息只能被一个消费者接收，但可以被多个消费者消费。在点对点模型中，每个消息只有一个消费者，如果消息被多个消费者接收，那么只有一个消费者能够消费消息。</li>
<li>发布/订阅模型： 在发布/订阅模型中，消息被发送到一个主题中。发布者将消息发布到主题中，订阅者订阅主题。当一条消息被发布到主题中时，所有订阅该主题的订阅者都会收到这条消息。在发布/订阅模型中，消息可以被多个消费者消费，但一个消费者只能消费属于它订阅的主题的消息。</li>
</ol>
<h3 id="97-jms-五种不同的消息正文格式">
  9.7 JMS 五种不同的消息正文格式
  <a href="#97-jms-%e4%ba%94%e7%a7%8d%e4%b8%8d%e5%90%8c%e7%9a%84%e6%b6%88%e6%81%af%e6%ad%a3%e6%96%87%e6%a0%bc%e5%bc%8f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>JMS（Java Message Service）规范定义了5种不同的消息正文格式，分别是：</p>
<ol>
<li>TextMessage：消息正文是普通文本，通常用于发送短文本消息。</li>
<li>MapMessage：消息正文是一组键值对，键和值都是字符串类型，通常用于发送一些小的配置信息。</li>
<li>BytesMessage：消息正文是一个字节数组，通常用于发送一些二进制数据，例如图片、音频等。</li>
<li>StreamMessage：消息正文是一个流，可以传输多种不同类型的数据，通常用于发送一些复杂的数据结构。</li>
<li>ObjectMessage：消息正文是一个Java对象，通常用于发送一些复杂的业务数据。</li>
</ol>
<p>不同的消息类型适用于不同的业务场景，开发人员应根据实际需求选择合适的消息类型。</p>
<h3 id="98-常见的消息队列对比">
  9.8 常见的消息队列对比
  <a href="#98-%e5%b8%b8%e8%a7%81%e7%9a%84%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e5%af%b9%e6%af%94" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>常见的消息队列有多种，下面对其中几种进行简要对比：</p>
<ol>
<li>Redis：是一个<strong>内存数据库</strong>，同时也支持消息队列的功能，使用简单，性能优异，适用于<strong>高速缓存</strong>和<strong>实时消息传递</strong>等场景。</li>
<li>Kafka：使用 Scala 实现，是一个分布式、高吞吐量的发布/订阅消息系统，支持多租户，可以保证消息的持久性和可靠性，适合处理大规模的数据流。</li>
<li>RocketMQ：使用 Java 实现，是阿里巴巴开源的分布式消息队列系统，支持多种消息模式，包括点对点、发布/订阅等，具有高可用性、高性能、低延迟、高吞吐量等优点。</li>
<li>RabbitMQ：使用 Erlang 实现，可以提供 AMQP、STOMP 等多种协议，支持多种消息模式，包括发布/订阅、路由、RPC、请求/响应等，具有高可靠性、高可用性和高性能等优点。</li>
<li>ActiveMQ：使用 Java 实现，支持 JMS 规范，提供多种消息模式，包括点对点、发布/订阅等，支持多种协议，包括 AMQP、STOMP、OpenWire 等，具有高可用性、高性能、可扩展性等优点。</li>
</ol>
<p>​		以上是常见的几种消息队列，不同的场景需要选择适合自己的消息队列。例如，如果需要处理大规模的数据流，可以选择 Kafka；如果需要支持多种消息模式，可以选择 RabbitMQ；如果需要高可用性和可扩展性，可以选择 ActiveMQ。见的负载均衡技术包括硬件负载均衡、软件负载均衡和 DNS 负载均衡等。</p>
<h1 id="第10章-分布式">
  第10章 分布式
  <a href="#%e7%ac%ac10%e7%ab%a0-%e5%88%86%e5%b8%83%e5%bc%8f" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="101-什么是分布式">
  10.1 什么是分布式
  <a href="#101-%e4%bb%80%e4%b9%88%e6%98%af%e5%88%86%e5%b8%83%e5%bc%8f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		分布式（Distributed）指的是系统或应用程序的不同组件或模块在多台计算机或服务器上运行和协作工作，以实现更高效、更可靠和更灵活的处理方式。在分布式系统中，每个组件或模块都是独立的，它们可以在不同的计算机上运行，通过网络进行通信和协作，共同完成系统或应用程序的功能。</p>
<p>​		分布式系统通常被用于处理大规模数据或流量，以及提供高可用性和容错能力，因为即使某个节点或服务器出现故障，整个系统仍然可以继续运行。分布式系统也可以帮助提高系统的扩展性和性能，因为它可以通过添加更多的计算资源来增加系统的吞吐量和处理能力。</p>
<p>​		分布式系统可以应用于各种领域，例如云计算、大数据分析、物联网、区块链等。</p>
<h3 id="102-什么是-rpcrpc-原理是什么">
  10.2 什么是 RPC，RPC 原理是什么
  <a href="#102-%e4%bb%80%e4%b9%88%e6%98%af-rpcrpc-%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		RPC（Remote Procedure Call）是一种<strong>远程过程调用协议</strong>，允许像调用本地服务一样调用远程服务。RPC 框架在分布式系统中有广泛应用，可以实现跨语言、跨平台的服务调用。</p>
<p>​		RPC 的原理是基于代理模式和序列化的技术。当客户端发起请求时，RPC 框架会通过动态代理生成代理对象，并将请求参数序列化成二进制数据传输到服务端。服务端接收到请求后将二进制数据反序列化成参数，调用对应的服务方法，并将返回值序列化为二进制数据传输到客户端，客户端再将返回值反序列化得到结果。</p>
<p>​		RPC 框架通常包含了编解码、服务发现、负载均衡、超时重试等功能。常见的 RPC 框架有 Dubbo、gRPC、Thrift 等。</p>
<h3 id="103-解释一下什么是负载均衡">
  10.3 解释一下什么是负载均衡
  <a href="#103-%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8b%e4%bb%80%e4%b9%88%e6%98%af%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		负载均衡是指将<strong>网络</strong>或<strong>计算资源</strong>分配给多个服务器、网络连接或磁盘驱动器，以提高系统的可靠性、效率和可扩展性。负载均衡的目标是使系统的负载在各个组件之间均衡分配，以避免某些组件负载过高而影响整个系统的性能和可用性。通常情况下，负载均衡会将网络流量、服务请求或数据流等均衡分布到多个服务器上，从而实现高可用性、高吞吐量和低延迟等性能指标。常</p>
<h3 id="103-什么是-dubbo为什么要用-dubbo">
  10.3 什么是 Dubbo，为什么要用 Dubbo
  <a href="#103-%e4%bb%80%e4%b9%88%e6%98%af-dubbo%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-dubbo" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Dubbo 是一个高性能、轻量级的开源 Java RPC 框架，由阿里巴巴公司开源，主要解决分布式系统中服务调用的问题。</p>
<p>​		在分布式系统中，服务之间的调用通常采用 RPC（Remote Procedure Call）方式，即远程过程调用，RPC 可以将一次远程调用封装成本地调用的方式，使得开发人员可以像调用本地方法一样去调用远程服务，简化了分布式系统的开发难度。</p>
<p>​		Dubbo 提供了高性能的远程调用能力和负载均衡，可以满足高并发、低延迟的分布式服务调用需求。它还提供了服务治理、服务降级、服务熔断、服务限流等功能，能够提升分布式系统的可用性和稳定性。此外，Dubbo 还提供了可扩展的插件机制，可以与其他框架进行无缝集成。</p>
<h3 id="104-dubbo-工作原理">
  10.4 Dubbo 工作原理
  <a href="#104-dubbo-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Dubbo 是一种高性能、轻量级的开源 RPC 框架，它采用了分层设计和扩展点机制，支持多种协议、多种注册中心、多种序列化方式、多种负载均衡策略等特性，为分布式应用提供高性能、透明化的 RPC 远程服务调用方案。</p>
<p>Dubbo 的工作原理如下：</p>
<ol>
<li>服务提供者（Provider）在启动时，将自己提供的服务以及服务的元数据（包括服务接口名、版本号、协议、IP 等）注册到注册中心中。</li>
<li>服务消费者（Consumer）在启动时，从注册中心获取服务提供者的 IP 地址，然后根据服务接口、版本号、负载均衡策略等信息选择一个服务提供者。</li>
<li>服务消费者通过网络请求服务提供者提供的服务，Dubbo 底层通过代理技术将服务调用转换成本地方法调用，实现了远程服务调用的透明化。</li>
<li>服务提供者将处理结果返回给服务消费者，Dubbo 底层将处理结果进行序列化并通过网络传输到服务消费者。</li>
<li>服务消费者将处理结果反序列化，并返回给应用程序。</li>
</ol>
<p>​		在 Dubbo 中，服务提供者、服务消费者和注册中心之间的通信都是通过 RPC 实现的，Dubbo 默认使用 Netty 作为底层通信框架，使用 Hessian 或者 Protobuf 进行序列化。同时，Dubbo 还提供了多种协议和注册中心的实现，可以根据需要进行选择和配置。</p>
<h3 id="105-看看-dubbo-提供的负载均衡策略">
  10.5 看看 Dubbo 提供的负载均衡策略
  <a href="#105-%e7%9c%8b%e7%9c%8b-dubbo-%e6%8f%90%e4%be%9b%e7%9a%84%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e7%ad%96%e7%95%a5" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Dubbo 提供了多种负载均衡策略，可以根据实际场景进行选择。以下是 Dubbo 提供的负载均衡策略：</p>
<ol>
<li>Random LoadBalance：随机调用一个可用的服务提供者。</li>
<li>RoundRobin LoadBalance：轮询调用可用的服务提供者。</li>
<li>LeastActive LoadBalance：调用活跃度最低的服务提供者，即当前处理请求最少的服务提供者。</li>
<li>ConsistentHash LoadBalance：基于一致性 Hash 算法的负载均衡，根据请求参数的某个属性进行哈希，然后选择相应的服务提供者。</li>
</ol>
<p>可以通过在 Dubbo 的配置文件中配置 <code>loadbalance</code> 属性指定使用的负载均衡策略，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;dubbo:reference</span> <span style="color:#a6e22e">interface=</span><span style="color:#e6db74">&#34;com.xxx.XxxService&#34;</span> <span style="color:#a6e22e">loadbalance=</span><span style="color:#e6db74">&#34;leastactive&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span></code></pre></div><h3 id="106-什么是-netty为什么要用-netty">
  10.6 什么是 Netty，为什么要用 Netty
  <a href="#106-%e4%bb%80%e4%b9%88%e6%98%af-netty%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-netty" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Netty 是一个基于 Java NIO 的客户端/服务器框架，用于快速开发可维护的高性能协议服务器和客户端。它是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。Netty 使得开发者可以轻松地创建基于 TCP、UDP、HTTP、WebSocket 等协议的网络应用程序，而无需关注底层网络细节和复杂性。</p>
<p>​		Netty 通过提供一组易于使用的抽象和实现，使网络应用程序开发更加容易。它提供了各种协议的支持和工具，如 HTTP、SMTP、DNS、Memcached、WebSocket 等，同时还提供了一些高级特性，如线程池、内存池、编解码器、SSL/TLS 支持等，可以满足各种复杂的网络应用程序的需求。</p>
<p>​		Netty 是一个基于 Java 的高性能网络编程框架，它可以帮助开发者快速、方便地开发高性能、可扩展的网络应用程序。下面是一些使用 Netty 的主要原因：</p>
<ol>
<li>高性能：Netty 的核心是基于 NIO（Non-blocking I/O）的异步事件驱动模型，可以极大地提高网络应用程序的性能。与传统的阻塞 I/O 相比，Netty 的 NIO 实现可以在一个线程中处理大量的并发连接和请求。</li>
<li>可扩展性：Netty 的设计和实现具有高度的可扩展性。它提供了一组灵活的组件和工具，可以帮助开发者构建可重用和可扩展的应用程序。</li>
<li>协议支持：Netty 提供了广泛的协议支持，包括 HTTP、WebSocket、SSL/TLS、SMTP、POP3、IMAP 等。</li>
<li>易于使用：Netty 的 API 易于使用，提供了丰富的功能和选项，可以帮助开发者快速构建网络应用程序。</li>
<li>社区活跃：Netty 是一个开源框架，拥有一个活跃的社区，提供了大量的文档、示例和工具，可以帮助开发者更好地理解和使用 Netty。</li>
</ol>
<p>​		总之，使用 Netty 可以帮助开发者快速构建高性能、可扩展、可靠的网络应用程序，并且它的使用也越来越广泛。</p>
<h3 id="107-netty-工作原理">
  10.7 Netty 工作原理
  <a href="#107-netty-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Netty 的核心是基于 NIO（Non-blocking I/O）的异步事件驱动模型，它通过以下方式工作：</p>
<ol>
<li>Reactor 模式：Netty 使用 Reactor 模式作为事件处理模型。在 Reactor 模式中，一个或多个线程（即 Reactor 线程）负责监听并接受事件（如客户端连接请求、数据读取等），然后将事件分发给对应的处理器（即 Handler），处理器负责处理事件并执行相应的逻辑。</li>
<li>Channel 和 ChannelPipeline：Netty 中的 Channel 表示一个连接，每个 Channel 包含一个 ChannelPipeline，Pipeline 是一系列 ChannelHandler 的有序集合，用于处理数据流。当数据通过 Channel 传输时，它会经过 ChannelPipeline 中的每个 Handler 进行处理，直到达到最终的目的地或最终的 Handler。</li>
<li>异步操作：Netty 的异步操作是通过 Future 和 Callback 实现的。当一个操作发起时，它返回一个 Future 对象，该对象可以用于异步等待操作结果。当操作完成时，Future 对象会被通知，并触发相应的回调函数（即 Callback）。</li>
<li>EventLoop：Netty 的 EventLoop 是一个执行任务的线程，它负责处理所有的 I/O 事件和执行任务。EventLoop 会不断地轮询 Channel 上的事件，当有事件发生时，它会将事件分配给相应的处理器进行处理。</li>
</ol>
<p>​		总之，Netty 通过 Reactor 模式、Channel 和 ChannelPipeline、异步操作和 EventLoop 等技术实现了高性能、可扩展的网络编程。它可以帮助开发者快速、方便地构建高性能、可靠、可扩展的网络应用程序。</p>
<h3 id="108-什么是-zookeeper为什么要用-zookeeper">
  10.8 什么是 Zookeeper，为什么要用 Zookeeper
  <a href="#108-%e4%bb%80%e4%b9%88%e6%98%af-zookeeper%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-zookeeper" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Zookeeper 是一个分布式协调服务框架，它提供了一系列的分布式基础服务，如统一命名服务、配置管理、分布式锁、分布式队列等，同时它也是 Apache 的一个开源项目。</p>
<p>​		在分布式系统中，通常需要协调多个进程之间的交互，比如服务发现、负载均衡、集群管理等。这些工作需要一个统一的协调者来保证分布式系统的正确性和可靠性。Zookeeper 就提供了这样的协调服务，它可以作为一个分布式系统的中心化管理工具，确保分布式系统的一致性和可靠性。</p>
<p>​		Zookeeper 提供了一个高可用的分布式服务，它的核心是一个高效的分布式数据存储系统和一个可靠的协调服务。Zookeeper 将数据存储在内存中，并将数据的修改异步写入到磁盘中。它利用了 Paxos 算法保证了数据的一致性和可靠性。Zookeeper 还提供了丰富的 API，可以方便地实现各种分布式应用。</p>
<h3 id="109-zookeeper-工作原理">
  10.9 Zookeeper 工作原理
  <a href="#109-zookeeper-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Zookeeper 是一个分布式协调服务，主要用于维护和协调分布式系统中的元数据。它是一个基于 Paxos 算法的实现，用于解决分布式系统中的一致性问题。Zookeeper 主要有两个核心功能：一是提供分布式锁服务，二是提供发布/订阅服务。</p>
<p>Zookeeper 的工作原理主要包括以下几个方面：</p>
<ol>
<li>集群管理：Zookeeper 集群是由若干个服务器组成的，其中一个是 Leader，其余的是 Follower。Leader 负责处理客户端请求，更新状态并同步到 Follower。</li>
<li>数据管理：Zookeeper 采用类似文件系统的层次结构来管理数据，每个节点被称为 znode，每个 znode 都有一个路径名和一个数据内容。</li>
<li>会话管理：每个客户端与 Zookeeper 的交互都需要建立一个会话，会话是由 Zookeeper 服务器分配的一个全局唯一的编号。客户端可以根据会话 ID 访问 Zookeeper 中的数据。</li>
<li>Watcher 机制：Watcher 机制是 Zookeeper 实现分布式协调的核心机制。客户端可以向 Zookeeper 注册 Watcher，一旦节点发生变化，Zookeeper 就会通知客户端。</li>
</ol>
<p>​		总之，Zookeeper 是一个高性能、可靠的分布式协调服务，可用于实现诸如分布式锁、分布式队列、配置管理、命名服务等应用。</p>
<h3 id="1010-zookeeper-宕机与-dubbo-直连的情况">
  10.10 Zookeeper 宕机与 Dubbo 直连的情况
  <a href="#1010-zookeeper-%e5%ae%95%e6%9c%ba%e4%b8%8e-dubbo-%e7%9b%b4%e8%bf%9e%e7%9a%84%e6%83%85%e5%86%b5" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		当 ZooKeeper 宕机时，Dubbo 注册中心的服务列表无法更新，但此时已经与注册中心建立连接的消费者和提供者仍可以正常通信，因为 Dubbo 会缓存注册中心的服务列表。如果此时有新的消费者需要订阅某个服务，就会失败。如果有新的提供者需要向注册中心注册服务，也会失败。当 ZooKeeper 重新上线时，Dubbo 的注册中心会重新获取服务列表并更新，此时新的消费者和提供者也可以正常操作。</p>
<p>​		如果使用直连方式，消费者不会通过注册中心来订阅和发现服务，而是直接连接到提供者的地址。这种方式下，如果提供者地址发生变化或者提供者下线，消费者将无法及时发现并重新连接到可用的提供者，容易导致调用失败。因此，建议还是使用注册中心进行服务发现和订阅。</p>
<h3 id="1011-什么是-elasticsearch为什么要用-elasticsearch">
  10.11 什么是 Elasticsearch，为什么要用 Elasticsearch
  <a href="#1011-%e4%bb%80%e4%b9%88%e6%98%af-elasticsearch%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-elasticsearch" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		Elasticsearch 是一个开源的搜索引擎，基于 Lucene 搜索引擎库构建。它提供了一个分布式的、多租户的全文搜索引擎，能够存储、搜索和分析海量数据。Elasticsearch 具有高效的全文搜索、实时性好、支持分布式、水平扩展能力强等特点，被广泛应用于日志分析、搜索引擎、商业智能等领域。</p>
<p>​		Elasticsearch 是一个基于 Lucene 的分布式搜索和分析引擎，它可以帮助开发者在大规模数据集上进行快速、准确的搜索和分析。下面是一些使用 Elasticsearch 的主要原因：</p>
<ol>
<li>高性能：Elasticsearch 的核心是基于 Lucene 的搜索引擎，可以实现快速、准确的全文搜索。它还提供了高效的数据存储和检索机制，可以处理大规模的数据集。</li>
<li>可扩展性：Elasticsearch 是一个分布式系统，可以轻松地扩展到多个节点上进行水平扩展。它使用分片和副本机制来提高系统的可用性和容错能力。</li>
<li>强大的查询功能：Elasticsearch 提供了灵活和强大的查询功能，支持全文搜索、过滤、聚合、排序等操作，可以满足各种搜索和分析需求。</li>
<li>实时性：Elasticsearch 可以在数据被索引后立即查询到最新的结果，支持实时搜索和实时分析，适用于需要及时反馈和处理数据的场景。</li>
<li>易于使用：Elasticsearch 提供了丰富的文档和示例，具有易于使用的 API 和工具，可以帮助开发者快速入门和使用。</li>
<li>社区活跃：Elasticsearch 是一个开源项目，拥有一个活跃的社区，提供了大量的文档、示例和工具，可以帮助开发者更好地理解和使用 Elasticsearch。</li>
</ol>
<p>​		总之，使用 Elasticsearch 可以帮助开发者快速构建高性能、可扩展、可靠的搜索和分析引擎，并且它的使用也越来越广泛。它适用于各种场景，包括电子商务、日志分析、企业搜索、安全监控等。</p>
<h3 id="1012-elasticsearch-工作原理">
  10.12 Elasticsearch 工作原理
  <a href="#1012-elasticsearch-%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Elasticsearch 的工作原理可以简单地概括为以下几个步骤：</p>
<ol>
<li>数据存储：Elasticsearch 将数据存储在一个或多个分片（Shard）中，每个分片是一个独立的 Lucene 索引，每个分片可以在多个节点之间复制，以提高系统的可用性和容错能力。</li>
<li>索引创建：当一个文档被索引时，Elasticsearch 会对该文档进行分词（Tokenize）和建立索引（Indexing）。分词是将文本分割成单个词语的过程，索引是将每个词语与该文档的相关信息（如出现位置、频率等）建立索引。</li>
<li>查询执行：当一个查询被执行时，Elasticsearch 会将查询解析成一组查询条件，并将这些条件发送给每个相关的分片进行查询。每个分片会将查询结果返回给协调节点（Coordinator Node）。</li>
<li>结果合并：协调节点将所有分片返回的查询结果合并成一个全局的结果集，并将其返回给客户端。</li>
<li>高可用性和容错：Elasticsearch 通过分片和副本机制来提高系统的可用性和容错能力。当一个节点失败时，Elasticsearch 会将该节点上的分片自动迁移至其他节点上，以保证数据的可用性和系统的稳定性。</li>
</ol>
<p>​		总之，Elasticsearch 通过分片和副本机制、索引创建、查询执行和结果合并等技术实现了高性能、可扩展、可靠的搜索和分析引擎。它可以帮助开发者快速、方便地构建高性能、可靠、可扩展的搜索和分析系统。</p>
<h3 id="1013-介绍一下-git-流程">
  10.13 介绍一下 Git 流程
  <a href="#1013-%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-git-%e6%b5%81%e7%a8%8b" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Git流程是一种常用的协作开发方法，它基于分布式版本控制系统Git来实现团队开发。下面是Git流程的主要步骤：</p>
<ol>
<li>创建远程仓库</li>
</ol>
<p>​		首先需要在远程服务器上创建一个Git仓库，比如GitHub、GitLab或Bitbucket等平台。在平台上创建好远程仓库后，就可以将本地代码上传到远程仓库中。</p>
<ol start="2">
<li>克隆代码</li>
</ol>
<p>​		将远程仓库中的代码克隆到本地计算机，然后在本地计算机上进行开发和修改代码。使用git clone命令可以将远程仓库克隆到本地。</p>
<ol start="3">
<li>创建分支</li>
</ol>
<p>​		在本地分支上开发，避免直接修改主要分支。使用git branch命令可以创建新分支。</p>
<ol start="4">
<li>开发和提交代码</li>
</ol>
<p>​		在本地分支上进行开发和修改代码，在开发完成之后，提交代码到本地仓库中，使用git add和git commit命令可以完成代码的提交。</p>
<ol start="5">
<li>推送代码</li>
</ol>
<p>​		将本地仓库中修改的代码推送到远程仓库中，使用git push命令将本地代码推送到远程仓库中。</p>
<ol start="6">
<li>合并分支</li>
</ol>
<p>​		如果开发完成的功能需要合并到主分支或其他分支中，则需要进行分支合并操作。使用git merge或者git pull命令可以将本地分支合并到其他分支中。</p>
<ol start="7">
<li>解决冲突</li>
</ol>
<p>​		在合并分支时，如果发生冲突，则需要解决冲突。使用git diff命令可以查看代码差异，手动解决冲突，然后再次提交代码。</p>
<ol start="8">
<li>发布和部署</li>
</ol>
<p>​		在完成代码的开发、测试和审核后，可以将代码发布到生产环境中。同时，也需要自动化部署和运维来保证代码的可靠性和稳定性。</p>
<p>以上就是常用的Git流程，可以根据实际需求进行优化和改进。</p>
<h3 id="1014-git-常用命令">
  10.14 Git 常用命令
  <a href="#1014-git-%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>仓库</p>
<pre tabindex="0"><code># 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]
</code></pre><p>配置</p>
<pre tabindex="0"><code># 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name &#34;[name]&#34;
$ git config [--global] user.email &#34;[email address]&#34;
</code></pre><p>增加/删除文件</p>
<pre tabindex="0"><code># 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
</code></pre><p>代码提交</p>
<pre tabindex="0"><code># 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre><p>分支</p>
<pre tabindex="0"><code># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre><p>标签</p>
<pre tabindex="0"><code># 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
</code></pre><p>查看信息</p>
<pre tabindex="0"><code># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&#34;提交说明&#34;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &#34;@{0 day ago}&#34;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre><p>远程同步</p>
<pre tabindex="0"><code># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre><p>撤销</p>
<pre tabindex="0"><code># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
</code></pre><p>其他</p>
<pre tabindex="0"><code># 生成一个可供发布的压缩包
$ git archive
</code></pre><hr>
<p>Github API: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</p>
<p>OpenAI API keys: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</p>
<p>5319 9332 5771 5125  06 / 26  369  90001</p>
<p>GUOLIANG WANG</p>
<p>United States of America</p>
<p>895  Armory Road  LOS ANGELES  90001</p>
<p>Califorinan</p>
<p>Liang199910112023</p>
<hr>
<h1 id="第11章-十大排序算法">
  第11章 十大排序算法
  <a href="#%e7%ac%ac11%e7%ab%a0-%e5%8d%81%e5%a4%a7%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="111-快速排序-quick-sort">
  11.1 快速排序 (Quick Sort)
  <a href="#111-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f-quick-sort" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>算法步骤：快速排序使用分治法策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：</p>
<ol>
<li>从序列中将第一个元素，做为 “基准”(<code>pivot</code>)；</li>
<li>重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 用第一个元素将待排序序列划分成左右两个部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> low<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> high<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> array<span style="color:#f92672">[</span>low<span style="color:#f92672">];</span>				<span style="color:#75715e">// 第一个元素作为枢轴
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  	<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>low <span style="color:#f92672">&lt;</span> high<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>					<span style="color:#75715e">// 用 low 和 high 搜索枢轴的最终位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      	<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> array<span style="color:#f92672">[</span>high<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;=</span> pivot<span style="color:#f92672">)</span> <span style="color:#f92672">--</span>high<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      	array<span style="color:#f92672">[</span>low<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> array<span style="color:#f92672">[</span>high<span style="color:#f92672">];</span>	<span style="color:#75715e">// 比枢轴小的元素移动到左端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      	<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> array<span style="color:#f92672">[</span>low<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;=</span> pivot<span style="color:#f92672">)</span> <span style="color:#f92672">++</span>low<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      	array<span style="color:#f92672">[</span>high<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> array<span style="color:#f92672">[</span>low<span style="color:#f92672">];</span>	<span style="color:#75715e">// 比枢轴大的元素移动到右端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  	array<span style="color:#f92672">[</span>low<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> pivot<span style="color:#f92672">;</span>						<span style="color:#75715e">// 枢轴元素存放的最终位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  	<span style="color:#66d9ef">return</span> low<span style="color:#f92672">;</span>										<span style="color:#75715e">// 返回存放枢轴的最终位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 快速排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quickSort</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> low<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> high<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>low <span style="color:#f92672">&lt;</span> high<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>																	<span style="color:#75715e">// 递归跳出的条件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> position <span style="color:#f92672">=</span> partition<span style="color:#f92672">(</span>array<span style="color:#f92672">,</span> low<span style="color:#f92672">,</span> high<span style="color:#f92672">);</span>		<span style="color:#75715e">// 划分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        quickSort<span style="color:#f92672">(</span>array<span style="color:#f92672">,</span> low<span style="color:#f92672">,</span> position <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">);</span>					<span style="color:#75715e">// 划分左子表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        quickSort<span style="color:#f92672">(</span>array<span style="color:#f92672">,</span> position <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">,</span> high<span style="color:#f92672">);</span>					<span style="color:#75715e">// 划分右子表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性 ：不稳定</li>
<li>时间复杂度 ：最佳：O(nlogn)， 最差：O(nlogn)，平均：O(nlogn)</li>
<li>空间复杂度 ：O(nlogn)</li>
</ul>
<h3 id="112-冒泡排序-bubble-sort">
  11.2 冒泡排序 (Bubble Sort)
  <a href="#112-%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f-bubble-sort" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>算法步骤：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤 1~3，直到排序完成。</li>
</ol>
<p><img src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/bubble_sort.gif" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 冒泡排序函数，接受一个整数类型的数组作为参数，返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">bubbleSort</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历数组，每次比较相邻的两个元素，将较大的元素往后移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 用来记录一轮比较中是否有元素交换位置，如果没有则说明数组已经有序，可以提前退出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">boolean</span> flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> arr<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">])</span> <span style="color:#f92672">{</span>	<span style="color:#75715e">// 如果前面的元素比后面的元素大，则交换它们的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>                arr<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>                arr<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> tmp<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span> 						<span style="color:#75715e">// 标记有元素交换位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>flag <span style="color:#f92672">==</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>						<span style="color:#75715e">// 如果一轮比较后没有元素交换位置，则说明数组已经有序，可以提前退出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性：稳定</li>
<li>时间复杂度 ：最佳：O(n) ，最差：O(n²)， 平均：O(n²)</li>
<li>空间复杂度 ：O(1)</li>
<li>排序方式 ：In-place</li>
</ul>
<h3 id="113-选择排序-selection-sort">
  11.3 选择排序 (Selection Sort)
  <a href="#113-%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f-selection-sort" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>算法步骤：</p>
<ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第 2 步，直到所有元素均排序完毕。</li>
</ol>
<p><img src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/selection_sort.gif" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 选择排序函数，接受一个整数类型的数组作为参数，返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">selectionSort</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历数组，每次找到未排序部分的最小值，并将其放到已排序部分的末尾
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> minIndex <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历未排序部分，找到最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">[</span>minIndex<span style="color:#f92672">])</span> minIndex <span style="color:#f92672">=</span> j<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果最小值不是未排序部分的第一个元素，则交换它们的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minIndex <span style="color:#f92672">!=</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>minIndex<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            arr<span style="color:#f92672">[</span>minIndex<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> tmp<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性：不稳定</li>
<li>时间复杂度 ：最佳：O(n²) ，最差：O(n²)， 平均：O(n²)</li>
<li>空间复杂度 ：O(1)</li>
<li>排序方式 ：In-place</li>
</ul>
<h3 id="114-插入排序-insertion-sort">
  11.4 插入排序 (Insertion Sort)
  <a href="#114-%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f-insertion-sort" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>算法步骤：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤 2~5。</li>
</ol>
<p><img src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/insertion_sort.gif" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 插入排序函数，接受一个整数类型的数组作为参数，返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">insertionSort</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历数组，从第二个元素开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 记录当前元素的前一个元素下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> preIndex <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 记录当前元素的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> current <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将当前元素插入到已排序的数组中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>preIndex <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> current <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">[</span>preIndex<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 将元素后移一位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            arr<span style="color:#f92672">[</span>preIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>preIndex<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 更新前一个元素下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            preIndex <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将当前元素插入到正确的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        arr<span style="color:#f92672">[</span>preIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> current<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性：稳定</li>
<li>时间复杂度 ：最佳：O(n) ，最差：O(n²)， 平均：O(n²)</li>
<li>空间复杂度 ：O(1)</li>
<li>排序方式 ：In-place</li>
</ul>
<h3 id="115-希尔排序-shell-sort">
  11.5 希尔排序 (Shell Sort)
  <a href="#115-%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f-shell-sort" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>算法步骤：</p>
<p>​		我们来看下希尔排序的基本步骤，在此我们选择增量 <code>gap=length/2</code>，缩小增量继续以 <code>gap = gap/2</code> 的方式，这种增量选择我们可以用一个序列来表示，<code>{n/2, (n/2)/2, ..., 1}</code>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列 <code>{t1, t2, …, tk}</code>，其中 <code>(ti&gt;tj, i&lt;j, tk=1)</code>；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 <code>t</code>，将待排序列分割成若干长度为 <code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<p><img src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/shell_sort.png" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 希尔排序函数，接受一个整数类型的数组作为参数，返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">shellSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> gap <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span>		<span style="color:#75715e">// 初始化间隔为数组长度的一半
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 不断缩小间隔，直到间隔为1结束循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>gap <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 对每个间隔进行插入排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> gap<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> current <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>		<span style="color:#75715e">// 记录当前子数组的坐标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> preIndex <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> gap<span style="color:#f92672">;</span>	<span style="color:#75715e">// 减去增量的值就是对应的子数坐标前一位的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 对每个子序列进行插入排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>preIndex <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> arr<span style="color:#f92672">[</span>preIndex<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> current<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 将元素后移 gap 位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                arr<span style="color:#f92672">[</span>preIndex <span style="color:#f92672">+</span> gap<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>preIndex<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 更新 gap 位下表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                preIndex <span style="color:#f92672">-=</span> gap<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        		<span style="color:#75715e">// 将当前元素插入到正确的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            arr<span style="color:#f92672">[</span>preIndex <span style="color:#f92672">+</span> gap<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> current<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 缩小增量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        gap <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性：稳定</li>
<li>时间复杂度 ：最佳：O(nlogn)， 最差：O(n²) 平均：O(nlogn)</li>
<li>空间复杂度 ：O(1)</li>
</ul>
<h3 id="116-归并排序-merge-sort">
  11.6 归并排序 (Merge Sort)
  <a href="#116-%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f-merge-sort" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>算法步骤：</p>
<p>归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下：</p>
<ol>
<li>如果输入内只有一个元素，则直接返回，否则将长度为 <code>n</code> 的输入序列分成两个长度为 <code>n/2</code> 的子序列；</li>
<li>分别对这两个子序列进行归并排序，使子序列变为有序状态；</li>
<li>设定两个指针，分别指向两个已经排序子序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；</li>
<li>重复步骤 3 ~4 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<p><img src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/merge_sort.gif" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 归并排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 要排序的整数数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return arr 排序后的整数数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">mergeSort</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 将数组分为两半
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> middle <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 将一个原始的数组 arr 从下标 0 开始复制，复制到上标 middle 生成一个新的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr_1 <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">copyOfRange</span><span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> middle<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 将一个原始的数组 arr 从下标 middle 开始复制，复制到上标 arr.length 生成一个新的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr_2 <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">copyOfRange</span><span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> middle<span style="color:#f92672">,</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 返回已排序的新数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> merge<span style="color:#f92672">(</span>mergeSort<span style="color:#f92672">(</span>arr_1<span style="color:#f92672">),</span> mergeSort<span style="color:#f92672">(</span>arr_2<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* 合并两个已排序的数组arr_1和arr_2，并返回一个新的已排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* @param arr_1 第一个已排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* @param arr_2 第二个已排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* @return 合并后的已排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">merge</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr_1<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr_2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 创建一个新数组，大小为两个输入数组大小之和，用于存储合并后的已排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> sorted_arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>arr_1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">+</span> arr_2<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 初始化三个指针，用于遍历输入数组和新数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> idx_1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> idx_2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 通过比较 arr_1 和 arr_2 中的元素，将两个数组中较小的元素逐个放入新数组中，直到有一个数组的所有元素都被放入新数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>idx_1 <span style="color:#f92672">&lt;</span> arr_1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&amp;&amp;</span> idx_2 <span style="color:#f92672">&lt;</span> arr_2<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      	<span style="color:#75715e">// 如果 arr_1 的元素小于 arr_2 的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr_1<span style="color:#f92672">[</span>idx_1<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> arr_2<span style="color:#f92672">[</span>idx_2<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          	<span style="color:#75715e">// 将 arr_1 的元素放到新建的数组中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            sorted_arr<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr_1<span style="color:#f92672">[</span>idx_1<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>          	<span style="color:#75715e">// arr_1 数组的指针指向下一位元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            idx_1 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            sorted_arr<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr_2<span style="color:#f92672">[</span>idx_2<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            idx_2 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      	<span style="color:#75715e">// 元素插入后，更新新建数组的指针指向下一位元素中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        idx <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 将剩下的未放入新数组的元素放入新数组中，其中一个 while 循环会被执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>idx_1 <span style="color:#f92672">&lt;</span> arr_1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>idx_1 <span style="color:#f92672">&lt;</span> arr_1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            sorted_arr<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr_1<span style="color:#f92672">[</span>idx_1<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            idx_1 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            idx <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>idx_2 <span style="color:#f92672">&lt;</span> arr_2<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            sorted_arr<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr_2<span style="color:#f92672">[</span>idx_2<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            idx_2 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            idx <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 返回已排序的新数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> sorted_arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性：稳定</li>
<li>时间复杂度 ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li>
<li>空间复杂度 ：O(n)</li>
</ul>
<h3 id="117-堆排序-heap-sort">
  11.7 堆排序 (Heap Sort)
  <a href="#117-%e5%a0%86%e6%8e%92%e5%ba%8f-heap-sort" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>算法步骤：</p>
<ol>
<li>将初始待排序列 <code>(R1, R2, ……, Rn)</code> 构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素 <code>R[1]</code> 与最后一个元素 <code>R[n]</code> 交换，此时得到新的无序区 <code>(R1, R2, ……, Rn-1)</code> 和新的有序区 (Rn), 且满足 <code>R[1, 2, ……, n-1]&lt;=R[n]</code>；</li>
<li>由于交换后新的堆顶 <code>R[1]</code> 可能违反堆的性质，因此需要对当前无序区 <code>(R1, R2, ……, Rn-1)</code> 调整为新堆，然后再次将 R [1] 与无序区最后一个元素交换，得到新的无序区 <code>(R1, R2, ……, Rn-2)</code> 和新的有序区 <code>(Rn-1, Rn)</code>。不断重复此过程直到有序区的元素个数为 <code>n-1</code>，则整个排序过程完成。</li>
</ol>
<p><img src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/heap_sort.gif" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 全局变量，记录一个数组长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> heapLen<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 交换一个数组中的两个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param j
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>    arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>    arr<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> tmp<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 构建大根堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buildMaxHeap</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 从倒数第二层开始，逐层向上构建大根堆。因为倒数第一层都是叶子节点，不需要调整，所以从倒数第二层开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        heapify<span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> i<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 堆调整函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 待调整的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param i   待调整的节点下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">heapify</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> largest <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>              <span style="color:#75715e">// 暂定 i 为最大节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>        			<span style="color:#75715e">// 左子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span>        <span style="color:#75715e">// 右子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果左子节点存在且大于当前最大节点，则更新最大节点为左子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">&lt;</span> heapLen <span style="color:#f92672">&amp;&amp;</span> arr<span style="color:#f92672">[</span>left<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> arr<span style="color:#f92672">[</span>largest<span style="color:#f92672">])</span> largest <span style="color:#f92672">=</span> left<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果右子节点存在且大于当前最大节点，则更新最大节点为右子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>right <span style="color:#f92672">&lt;</span> heapLen <span style="color:#f92672">&amp;&amp;</span> arr<span style="color:#f92672">[</span>right<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> arr<span style="color:#f92672">[</span>largest<span style="color:#f92672">])</span> largest <span style="color:#f92672">=</span> right<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果最大节点不是当前节点，则交换最大节点和当前节点，继续向下调整
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>largest <span style="color:#f92672">!=</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        swap<span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> largest<span style="color:#f92672">,</span> i<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        heapify<span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> largest<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 堆排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 要排序的整数数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return 排序后的整数数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">heapSort</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    heapLen <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>		<span style="color:#75715e">// 将堆的长度设置为数组的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buildMaxHeap<span style="color:#f92672">(</span>arr<span style="color:#f92672">);</span>			<span style="color:#75715e">// 建立大根堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>	<span style="color:#75715e">// 对堆进行排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        swap<span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> i<span style="color:#f92672">);</span>		<span style="color:#75715e">// 将堆顶元素与最后一个元素交换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        heapLen <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>				<span style="color:#75715e">// 堆的长度减 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        heapify<span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">);</span>		<span style="color:#75715e">// 对交换后的堆进行调整，使其重新成为最大堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>							<span style="color:#75715e">// 返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性 ：不稳定</li>
<li>时间复杂度 ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li>
<li>空间复杂度 ：O(1)</li>
</ul>
<h3 id="118-计数排序-counting-sort">
  11.8 计数排序 (Counting Sort)
  <a href="#118-%e8%ae%a1%e6%95%b0%e6%8e%92%e5%ba%8f-counting-sort" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>算法步骤：</p>
<ol>
<li>找出数组中的最大值 <code>max</code>、最小值 <code>min</code>；</li>
<li>创建一个新数组 <code>C</code>，其长度是 <code>max-min+1</code>，其元素默认值都为 0；</li>
<li>遍历原数组 <code>A</code> 中的元素 <code>A[i]</code>，以 <code>A[i]-min</code> 作为 <code>C</code> 数组的索引，以 <code>A[i]</code> 的值在 <code>A</code> 中元素出现次数作为 <code>C[A[i]-min]</code> 的值；</li>
<li>对 <code>C</code> 数组变形，<strong>新元素的值是该元素与前一个元素值的和</strong>，即当 <code>i&gt;1</code> 时 <code>C[i] = C[i] + C[i-1]</code>；</li>
<li>创建结果数组 <code>R</code>，长度和原始数组一样。</li>
<li><strong>从后向前</strong>遍历原始数组 <code>A</code> 中的元素 <code>A[i]</code>，使用 <code>A[i]</code> 减去最小值 <code>min</code> 作为索引，在计数数组 <code>C</code> 中找到对应的值 <code>C[A[i]-min]</code>，<code>C[A[i]-min]-1</code> 就是 <code>A[i]</code> 在结果数组 <code>R</code> 中的位置，做完上述这些操作，将 <code>count[A[i]-min]</code> 减小 1。</li>
</ol>
<p><img src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/counting_sort.gif" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取数组中的最大值和最小值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 待查找的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return 包含最大值和最小值的数组，第一个元素为最小值，第二个元素为最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">getMinAndMax</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">];</span>    <span style="color:#75715e">// 定义变量 maxValue，并将其赋值为数组的第一个元素，用于记录最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> minValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">];</span>    <span style="color:#75715e">// 定义变量 minValue，并将其赋值为数组的第一个元素，用于记录最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>    <span style="color:#75715e">// 遍历整个数组，寻找最大值和最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> maxValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>    					<span style="color:#75715e">// 如果当前元素大于 maxValue，将 maxValue 更新为当前元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            maxValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> minValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>    		<span style="color:#75715e">// 如果当前元素小于 minValue，将 minValue 更新为当前元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            minValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#f92672">{</span> minValue<span style="color:#f92672">,</span> maxValue <span style="color:#f92672">};</span>    <span style="color:#75715e">// 将最小值和最大值封装成数组并返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 计数排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 待排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return 返回排序结果数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">countingSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>											<span style="color:#75715e">// 如果待排序数组长度小于 2，直接返回数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> extremum <span style="color:#f92672">=</span> getMinAndMax<span style="color:#f92672">(</span>arr<span style="color:#f92672">);</span>	<span style="color:#75715e">// 获取待排序数组中的最小值和最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> minValue <span style="color:#f92672">=</span> extremum<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">];</span>					<span style="color:#75715e">// 最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> maxValue <span style="color:#f92672">=</span> extremum<span style="color:#f92672">[</span><span style="color:#ae81ff">1</span><span style="color:#f92672">];</span> 				<span style="color:#75715e">// 最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> countArr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>maxValue <span style="color:#f92672">-</span> minValue <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">];</span> <span style="color:#75715e">// 存储计数信息的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span> <span style="color:#75715e">// 存储排序结果的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 统计每个数字出现的次数，存储在 countArr 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        countArr<span style="color:#f92672">[</span>arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> minValue<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> <span style="color:#75715e">// 将 arr[i] 出现的次数加 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算 countArr 中每个元素在排序结果中所处的下标位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> countArr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        countArr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> countArr<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">];</span> 	<span style="color:#75715e">// 将 countArr[i] 增加 countArr[i-1]，即表示小于等于 i 的元素个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从后往前遍历待排序数组，依次将每个元素放入结果数组中的正确位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> countArr<span style="color:#f92672">[</span>arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> minValue<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>	<span style="color:#75715e">// 获取元素 arr[i] 在结果数组中的下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        result<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span> 											<span style="color:#75715e">// 将 arr[i] 放入结果数组中的对应位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        countArr<span style="color:#f92672">[</span>arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> minValue<span style="color:#f92672">]</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>						<span style="color:#75715e">// 将 countArr 中对应元素的值减 1，以保证相同元素的下标递减
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span> <span style="color:#75715e">// 返回排序结果数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<p>​		当输入的元素是 <code>n</code> 个 <code>0</code> 到 <code>k</code> 之间的整数时，它的运行时间是 <code>O(n+k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 <code>C</code> 的长度取决于待排序数组中数据的范围（等于待排序数组的<strong>最大值与最小值的差加上 1</strong>），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。</p>
<ul>
<li>稳定性 ：稳定</li>
<li>时间复杂度 ：最佳：<code>O(n+k)</code> 最差：<code>O(n+k)</code> 平均：<code>O(n+k)</code></li>
<li>空间复杂度 ：<code>O(k)</code></li>
</ul>
<h3 id="119-桶排序-bucket-sort">
  11.9 桶排序 (Bucket Sort)
  <a href="#119-%e6%a1%b6%e6%8e%92%e5%ba%8f-bucket-sort" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>算法步骤：</p>
<ol>
<li>设置一个 BucketSize，作为每个桶所能放置多少个不同数值；</li>
<li>遍历输入数据，并且把数据依次映射到对应的桶里去；</li>
<li>对每个非空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>
<li>从非空桶里把排好序的数据拼接起来。</li>
</ol>
<p><img src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/bucket_sort.gif" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取列表中的最大值和最小值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 待查找的列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return 包含最大值和最小值的列表，第一个元素为最小值，第二个元素为最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">getMinAndMax</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#ae81ff">0</span><span style="color:#f92672">);</span>		 <span style="color:#75715e">// 初始化最大值为列表的第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> minValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#ae81ff">0</span><span style="color:#f92672">);</span>		 <span style="color:#75715e">// 初始化最小值为列表的第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">:</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>					   <span style="color:#75715e">// 遍历整个列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;</span> maxValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>			   <span style="color:#75715e">// 如果当前元素大于最大值，则更新最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            maxValue <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;</span> minValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 如果当前元素小于最小值，则更新最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            minValue <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#f92672">{</span> minValue<span style="color:#f92672">,</span> maxValue <span style="color:#f92672">};</span>	<span style="color:#75715e">// 返回最小值和最大值的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 桶排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 待排序列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param bucket_size 桶的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return 返回排序结果列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">bucketSort</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> arr<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> bucket_size<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 如果数组长度小于等于2，或者桶的大小为0，直接返回原数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">||</span> bucket_size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> extremum <span style="color:#f92672">=</span> getMinAndMax<span style="color:#f92672">(</span>arr<span style="color:#f92672">);</span>		<span style="color:#75715e">// 获取数组中的最小值和最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> minValue <span style="color:#f92672">=</span> extremum<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxValue <span style="color:#f92672">=</span> extremum<span style="color:#f92672">[</span><span style="color:#ae81ff">1</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> bucket_cnt <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>maxValue <span style="color:#f92672">-</span> minValue<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> bucket_size <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>		<span style="color:#75715e">// 计算桶的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    List<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;&gt;</span> buckets <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>						<span style="color:#75715e">// 创建桶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> bucket_cnt<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> element <span style="color:#f92672">:</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>												<span style="color:#75715e">// 将数组中的元素放入对应的桶中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>element <span style="color:#f92672">-</span> minValue<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> bucket_size<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>idx<span style="color:#f92672">).</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>element<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>			<span style="color:#75715e">// 对桶中的元素进行排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">).</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> sort<span style="color:#f92672">(</span>buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">),</span> bucket_size <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>	<span style="color:#75715e">// 将排序后的元素按顺序放入结果数组中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> bucket <span style="color:#f92672">:</span> buckets<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> element <span style="color:#f92672">:</span> bucket<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            result<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>element<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>		<span style="color:#75715e">// 返回排序后的结果数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性 ：稳定</li>
<li>时间复杂度 ：最佳：<code>O(n+k)</code> 最差：<code>O(n²)</code> 平均：<code>O(n+k)</code></li>
<li>空间复杂度 ：<code>O(k)</code></li>
</ul>
<h3 id="1110-基数排序-radix-sort">
  11.10 基数排序 (Radix Sort)
  <a href="#1110-%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f-radix-sort" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>算法步骤：</p>
<ol>
<li>取得数组中的最大数，并取得位数，即为迭代次数 <code>N</code>（例如：数组中最大数值为 1000，则 <code>N=4</code>）；</li>
<li><code>A</code> 为原始数组，从最低位开始取每个位组成 <code>radix</code> 数组；</li>
<li>对 <code>radix</code> 进行计数排序（利用计数排序适用于小范围数的特点）；</li>
<li>将 <code>radix</code> 依次赋值给原数组；</li>
<li>重复 2~4 步骤 <code>N</code> 次</li>
</ol>
<p><img src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/radix_sort.gif" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 基数排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 待排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return 返回排序结果数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">radixSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>		<span style="color:#75715e">// 如果数组长度小于2，直接返回原数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>  						<span style="color:#75715e">// 用于记录数值位数的变量，初始化为1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> maxValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">];</span>  <span style="color:#75715e">// 用于记录最大值的变量，初始化为数组第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 循环找到数组中的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> element <span style="color:#f92672">:</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>element <span style="color:#f92672">&gt;</span> maxValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            maxValue <span style="color:#f92672">=</span> element<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算最大值的位数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>maxValue <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        maxValue <span style="color:#f92672">=</span> maxValue <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        N <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 进行 N 次循环，每次循环将数组按照一位进行排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建一个 List 数组来保存当前位数下每个数字出现的所有元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        List<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;&gt;</span> radix <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> k <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">;</span> k<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            radix<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;());</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将数组中的元素按照当前位数分配到对应的桶里
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> element <span style="color:#f92672">:</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          	<span style="color:#75715e">// pow() 方法用于返回第一个参数的第二个参数次方，计算当前元素在当前位数上的数字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>element <span style="color:#f92672">/</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">pow</span><span style="color:#f92672">(</span><span style="color:#ae81ff">10</span><span style="color:#f92672">,</span> i<span style="color:#f92672">))</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            radix<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>idx<span style="color:#f92672">).</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>element<span style="color:#f92672">);</span>  <span style="color:#75715e">// 将当前元素放入对应的桶里
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将桶里的元素依次放回原数组，完成一次排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> l <span style="color:#f92672">:</span> radix<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">:</span> l<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                arr<span style="color:#f92672">[</span>idx<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>  <span style="color:#75715e">// 返回排好序的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性 ：稳定</li>
<li>时间复杂度 ：最佳：<code>O(n×k)</code> 最差：<code>O(n×k)</code> 平均：<code>O(n×k)</code></li>
<li>空间复杂度 ：<code>O(n+k)</code></li>
</ul>
<p>基数排序 vs 计数排序 vs 桶排序：</p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>
<h1 id="第12章-计算机网络">
  第12章 计算机网络
  <a href="#%e7%ac%ac12%e7%ab%a0-%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="在使用-tcp-协议中如何解决黏包的问题">
  在使用 TCP 协议中，如何解决黏包的问题
  <a href="#%e5%9c%a8%e4%bd%bf%e7%94%a8-tcp-%e5%8d%8f%e8%ae%ae%e4%b8%ad%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e9%bb%8f%e5%8c%85%e7%9a%84%e9%97%ae%e9%a2%98" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>​		TCP是一个可靠的传输协议，它会自动进行数据分段(segmentation)和接收端数据组合(reassembling)。然而，在快速发送数据或者发送大数据包时，可能会出现多个数据包被一次性接收而导致黏包的现象。</p>
<p>下面是一些解决TCP黏包的方法：</p>
<ol>
<li>
<p>使用消息边界，例如在每个消息末尾添加特定的分隔符，如\r\n，这样接收方就可以根据特定的分隔符来区分多个数据包。</p>
</li>
<li>
<p>在消息头中添加长度信息，例如在每个消息头部添加固定长度的数据，表示该数据包的长度，在接收方接收到数据时，先读取长度信息，然后再按照该长度来读取数据。这种方法需要应用程序自己进行长度的编解码，并且要注意协议中长度信息编码的一致性和正确性。</p>
</li>
<li>
<p>使用固定长度的数据包。例如每个数据包都使用固定的长度，这样可以避免多个数据包被一次性接收。但是应该注意数据包长度对网络带宽和延迟的影响。</p>
</li>
<li>
<p>使用应用层协议来避免黏包，例如HTTP协议中的Content-Length头字段和Transfer-Encoding字段，可以告诉接收方消息的长度或者分块编码等信息。</p>
</li>
</ol>
<p>​		以上几种方法都有其利弊之处，具体使用哪种方法，需要根据应用场景和需要进行选择。</p>
<h1 id="第13章-linux">
  第13章 Linux
  <a href="#%e7%ac%ac13%e7%ab%a0-linux" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="131-简单介绍一下-linux-文件系统">
  13.1 简单介绍一下 Linux 文件系统？
  <a href="#131-%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-linux-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>Linux 文件系统是一种层次化的目录结构，其根目录为 /，包含了所有其他文件和目录。Linux 文件系统的基本组成如下：</p>
<ol>
<li>根目录 / ：所有目录、文件的根目录。</li>
<li>/bin：包含了可执行命令，是系统启动时必须的命令。</li>
<li>/boot：包含了 Linux 内核和系统启动引导程序。</li>
<li>/dev：包含了设备文件，Linux 中所有硬件设备都被视为文件。</li>
<li>/etc：包含了系统配置文件。</li>
<li>/home：包含了系统用户的主目录。</li>
<li>/lib：包含了系统启动时必要的共享库。</li>
<li>/mnt：用于挂载临时文件系统。</li>
<li>/opt：用于安装额外的软件。</li>
<li>/proc：虚拟文件系统，包含了运行中的系统信息。</li>
<li>/root：超级用户的主目录。</li>
<li>/sbin：包含了系统管理员使用的管理命令。</li>
<li>/tmp：用于存放临时文件。</li>
<li>/usr：包含了用户自己安装的应用程序。</li>
<li>/var：用于存放系统日志等变化较频繁的文件。</li>
</ol>
<p>​		这些目录和文件在 Linux 中都有各自的权限和属性，用户可以通过命令行或者 GUI 工具对其进行管理和操作。Linux 文件系统是 Linux 操作系统的重要组成部分，提供了一种有效的组织和管理系统文件的方式。</p>
<h3 id="132-一些常见的-linux-命令了解吗">
  13.2 一些常见的 Linux 命令了解吗？
  <a href="#132-%e4%b8%80%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84-linux-%e5%91%bd%e4%bb%a4%e4%ba%86%e8%a7%a3%e5%90%97" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>一些常见的 Linux 命令，如下所示：</p>
<ol>
<li>ls：列出目录下的文件和子目录。</li>
<li>cd：切换工作目录。</li>
<li>pwd：显示当前工作目录的完整路径。</li>
<li>mkdir：创建目录。</li>
<li>touch：创建空文件或更改文件的时间戳。</li>
<li>rm：删除文件或目录。</li>
<li>cp：复制文件或目录。</li>
<li>mv：移动文件或目录。</li>
<li>cat：将文件内容输出到终端。</li>
<li>grep：在文件中查找指定的字符串。</li>
<li>tar：打包文件或目录。</li>
<li>unzip：解压缩文件。</li>
<li>chmod：更改文件或目录的权限。</li>
<li>chown：更改文件或目录的所有者。</li>
<li>ps：列出系统中运行的进程。</li>
<li>top：实时查看系统资源使用情况和进程信息。</li>
<li>kill：终止进程。</li>
<li>ifconfig：查看和配置网络接口。</li>
<li>ping：测试网络连接。</li>
<li>ssh：使用 SSH 连接远程服务器。</li>
</ol>
<p>这些命令是 Linux 系统中常用的基本命令，掌握它们可以帮助我们更好地管理 Linux 系统。</p>
<h1 id="其他">
  其他
  <a href="#%e5%85%b6%e4%bb%96" class="h-anchor" aria-hidden="true">#</a>
</h1>
<h3 id="自我介绍">
  自我介绍
  <a href="#%e8%87%aa%e6%88%91%e4%bb%8b%e7%bb%8d" class="h-anchor" aria-hidden="true">#</a>
</h3>
<p>请做一下自我介绍：</p>
<p>​</p>
<p>请介绍下项目以及项目的细节？</p>
<h3 id="简历内容">
  简历内容
  <a href="#%e7%ae%80%e5%8e%86%e5%86%85%e5%ae%b9" class="h-anchor" aria-hidden="true">#</a>
</h3>
<hr>
<p><strong>工作经历：</strong></p>
<ol>
<li>
<p>公司名称：XXX</p>
<p>职位：Java开发工程师</p>
<p>工作时间：</p>
<p>工作描述：</p>
</li>
</ol>
<p>​		向开发组长汇报。所做的项目是内部 ERP，业务管理后台，官网，基础商城，手机内嵌商城展示页面，选课系统等。完成了由没有经验的毕业生向 Java 开发人员的转变，主要负责 Java 项目编写，js 编写等。初期为单一的 Java Web 项目，后期拆分抽离为使用 dubbo 作为 rpc 中间件的极其基础的分布式架构。主要技术栈为 Spring，Spring MVC，MyBatis，js。接触过 nodejs。在 APP 内嵌 html 商城展示页面项目中建立了一套依靠 localstorage，md5 等对模板进行加载，检验，缓存，渲染的流程。用以加快客户端访速度。</p>
<p><strong>项目一：校脸数据平台</strong></p>
<ul>
<li>项目描述：由于线上存在多套系统，部分业务数据需要使用公共业务数据。所以将公共数据系统抽离，且改为分布式服务。</li>
<li>技术栈：Spring、Spring MVC、Mybatis、dubbo</li>
<li>责任描述：</li>
</ul>
<p>​     1. 初期，该项目为了实现将多个常用数据查询与请求接口集中至一个项目中，实现基础数据中心的功能。</p>
<p>​     2. 后期，将该项目架构更改，使用 dubbo 实现分布式，提供基础数据支持。</p>
<p><strong>项目二：SaaS在线数据幼儿园管理平台</strong></p>
<ul>
<li>项目描述：该项目是校脸对外产品。该项目为多种用户身份提供在线服务，重写了原有 Python 平台。</li>
<li>技术栈：Spring、Spring MVC、Mybatis、MySQL、jQuery、TFS</li>
<li>责任描述：</li>
</ul>
<p>​     1. 实现了完整的角色控制，用户管理，班级圈管理，批量导入/导出等模块，完全替代原有项目，并在原有基础上增加了新的功能。</p>
<p><strong>专业技能</strong></p>
<ul>
<li>
<p>熟练掌握 Eclipse，IDEA，Maven，SVN，Git 等开发及版本控制工具；</p>
</li>
<li>
<p>熟练掌握 JavaSE 基础知识，拥有面向对象分析能力和设计能力，有严谨的编程规范；</p>
</li>
<li>
<p>熟悉 Java IO、集合、JVM 和多线程等基础知识；</p>
</li>
<li>
<p>熟悉 Spring、SpringMVC、Spring Boot、Spring Cloud、Mybatis 等开源框架技术；</p>
</li>
<li>
<p>熟悉 MySQL 的增删改查操作以及 JDBC 数据库连接池的使用；</p>
</li>
<li>
<p>熟悉 Redis、MongoDB、MQ(Kafka、RabbitMQ) 等技术的使用；</p>
</li>
<li>
<p>熟悉 Tomcat、Nginx 等 Web 服务器和应用服务器的使用和配置；</p>
</li>
<li>
<p>熟悉 React、Bootstrap、Vue、jQuery 等前端开发技术。</p>
</li>
</ul>
<hr>
<p><strong>工作经历：</strong></p>
<ol>
<li>
<p>公司名称：  XXX</p>
<p>职位：前端工程师
工作时间：</p>
<p>工作描述：</p>
</li>
</ol>
<ol>
<li>负责公司网站前端页面开发和维护，使用了 HTML5、CSS、JavaScript等技术；</li>
<li>参与了公司后台管理系统的开发，使用了 React、Antd、Redux等技术；</li>
<li>负责与后端工程师进行接口对接、bug修复等工作；</li>
<li>参与了项目开发流程中的需求讨论、需求评审等工作。</li>
</ol>
<p><strong>项目名称：学乐途在线教育平台</strong></p>
<ul>
<li>Situation：该项目是一款在线教学平台，我作为前端工程师，负责前端页面的开发和维护。</li>
<li>Task：我使用React等技术栈进行开发，并使用了Antd进行页面样式的开发。同时，我负责与后端工程师进行接口对接和调试，保证前后端数据的顺畅传输。我负责版本控制和代码管理工作，保证项目代码的质量和稳定性。</li>
<li>Action：在项目中，我与团队合作，积极参与需求分析和评审。通过使用React和Antd等技术栈，我精准高效地完成了前端页面开发和设计，并与后端工程师进行紧密的互动沟通，保证前后端数据交互的成功实现。在代码管理方面，我使用Git版本控制工具，记录和跟踪了代码开发的整个过程。</li>
<li>Result：在项目中，我的工作获得了团队成员的高度评价中。最终我们顺利完成了项目开发，呈现出了良好的用户体验和稳定的运行性能。</li>
</ul>
<p><strong>项目名称：Bee微信小程序</strong></p>
<ul>
<li>Situation：该项目是一款基于微信小程序开发的电商平台。我在其中作为前端工程师，负责小程序页面的开发和维护。</li>
<li>Task：我使用微信小程序开发框架进行开发，负责小程序页面设计和对接后端接口调试。我负责版本控制和代码管理工作，保证代码质量和开发进度。</li>
<li>Action：在项目中，我使用了微信小程序开发框架，利用Axios等工具进行后端接口的对接。我使用Chrome DevTools进行快速调试，识别并解决了多个微信小程序开发中出现的问题。在代码管理方面，我使用了Git进行版本管理工作，并跟踪了整个开发过程。</li>
<li>Result：该小程序在短时间内取得了客户的认可，呈现出了稳定且高质量的表现。我的工作获得了团队成员的认可和好评，我们成功地完成了项目目标。</li>
</ul>
<p><strong>专业技能</strong></p>
<ul>
<li>
<p>熟练掌握HTML、CSS、JavaScript等前端技术；</p>
</li>
<li>
<p>熟练掌握Vue、React等主流前端框架；</p>
</li>
<li>
<p>熟练掌握Angular、Bootstrap等前端框架和库；</p>
</li>
<li>
<p>熟悉Webpack、Babel等前端工程化技术；</p>
</li>
<li>
<p>熟悉Node.js，并熟练掌握Express.js、Koa等后端框架；</p>
</li>
<li>
<p>熟悉MySQL、MongoDB等数据库，具备数据库应用开发经验；</p>
</li>
<li>
<p>熟练使用Git进行版本管理；</p>
</li>
<li>
<p>具备良好的代码风格和编程习惯。</p>
</li>
</ul>
<hr>
<p><strong>工作经历：</strong></p>
<ol>
<li>
<p>公司名称：XXX</p>
<p>职位：Java开发工程师</p>
<p>工作时间：</p>
<p>工作描述：</p>
</li>
<li>
<p>负责公司项目后端开发及维护，使用了Java等技术；</p>
</li>
<li>
<p>参与了公司后台管理系统的开发，使用了Spring Boot、MyBatis、Redis、MySQL等框架技术；</p>
</li>
<li>
<p>根据业务需求设计并实现后端接口，并与前端工程师进行交互以完成前后端数据相互调用；</p>
</li>
<li>
<p>负责对接并调试第三方接口，保证项目整体的正常运行；</p>
</li>
<li>
<p>参与了项目需求分析、架构设计、数据库设计等流程，优化了后台接口的性能，并提高了系统的可用性和稳定性；</p>
</li>
<li>
<p>负责排查并修正项目中出现的bug，使用Eclipse、STS等开发工具定位、解决问题；</p>
</li>
<li>
<p>在开发过程中，注重代码规范性，多次使用SonarQube等工具进行代码质量检测，提高了代码质量和可维护性。</p>
</li>
</ol>
<p><strong>项目一：智能家居系统</strong></p>
<ul>
<li>
<p>Situation：公司正在开发一款智能家居系统，需要一套后台管理系统来维护、管理各个智能模块。</p>
</li>
<li>
<p>Task：负责后台管理系统的开发工作，主要是开发一些关键数据同步、数据分析等后端业务，并做出整个项目的整体性优化。</p>
</li>
<li>
<p>Action：在设计阶段，与产品经理、数据库管理员等进行需求分析及设计，并利用Spring Boot、Spring Security、MyBatis等技术栈进行后台管理系统的快速开发。使用Git进行代码管理，并参与代码评审。采用了前后端分离的架构，前端使用了AngularJS、Bootstrap等框架，后端使用了Java编程语言，并采用MySQL数据库存储数据。运用Maven进行项目管理及依赖库管理。在整个项目开发和测试的过程中，积极参与代码调优、系统性能优化等后端方面的工作。</p>
</li>
<li>
<p>Result：后台管理系统上线后，用户管理、权限管理、设备管理等功能实现得更加完善，经过后期的性能调优等工作，系统的稳定性、高并发能力得到了大幅提升。整个项目的优化工作对于后期的维护和升级工作产生了显著的影响。在项目中，我的工作得到了其他同事的认可和表彰，同时我也在项目中得到了提升。</p>
</li>
</ul>
<p><strong>项目二：学乐途在线教育平台</strong></p>
<ul>
<li>
<p>Situation：公司在开发一款在线教育平台，需要一套管理端来维护、管理各个课程、订单等信息。</p>
</li>
<li>
<p>Task：在学乐途在线教育平台项目中，负责后端开发中的课程管理、订单管理等小部分业务。此外，负责对整个项目进行整体优化。</p>
</li>
<li>
<p>Action：在后端开发方面，使用Spring Boot、MyBatis等技术进行快速开发，并使用MySQL数据库进行数据存储。在整体优化方面，针对项目中出现的性能瓶颈及代码问题进行优化，采用Redis、Nginx等技术进行系统优化，使用Git进行代码管理，使用Maven进行项目管理，并编写集成测试和单元测试代码，保证了代码质量和项目进度。同时，和前端开发人员进行沟通，保证整个项目的协调性和稳定性。</p>
</li>
<li>
<p>Result：管理端上线后，课程管理、订单管理等功能实现得较为完善，得到了客户和同事的高度认可。管理端的开发工作进度顺利，并在展示及交付环节提供了高质量的技术支持及解决方案。整个项目优化后，性能得到了明显提升，在满足客户需求的同时，也降低了后续的维护成本，同时也减轻了其他团队成员的工作负担。</p>
</li>
</ul>
<p><strong>专业技能</strong></p>
<ul>
<li>
<p>熟练掌握 Eclipse，IDEA，Maven，Git 等开发及版本控制工具；</p>
</li>
<li>
<p>熟悉 Java IO、集合、JVM 和多线程等基础知识；</p>
</li>
<li>
<p>熟悉 Spring、SpringMVC、Spring Boot、Spring Cloud、Mybatis 等开源框架技术；</p>
</li>
<li>
<p>熟悉 MySQL 的增删改查操作以及 JDBC 数据库连接池的使用；</p>
</li>
<li>
<p>熟悉 Redis、MongoDB、MQ(Kafka、RabbitMQ) 等技术的使用；</p>
</li>
<li>
<p>熟悉 React、Bootstrap、Vue、jQuery 等前端开发技术。</p>
</li>
</ul>
<hr>

    </div>
    
      
    

    
      
        

      
    
  </article>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >hello friend</span
    >
    <span class="logo__cursor"></span>
  
</a>

      <div class="copyright">
        <span>© 2023 Powered by <a href="https://gohugo.io" target="_blank" rel="noopener">WGL</a></span>
        <!--
        <span><a href="https://github.com/panr/hugo-theme-hello-friend" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
        -->
      </div>
    
  </div>
</footer>





<script type="text/javascript" src="/bundle.min.js"></script>


      
    </div>

    
  </body>
</html>
