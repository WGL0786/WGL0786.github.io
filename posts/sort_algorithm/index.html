<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>十大排序算法 | WGL</title>
<meta name="keywords" content="">
<meta name="description" content="十大排序算法是常见的排序算法集合，它们包括冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序和基数排序，每种算法都有不同的优劣和适用场景。">
<meta name="author" content="">
<link rel="canonical" href="http://WGL0786.github.io/posts/sort_algorithm/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fc7881efabd098e81cbc03777fa91f7b529548ec91f0cfe452b42d16b9e2729c.css" integrity="sha256-/HiB76vQmOgcvAN3f6kfe1KVSOyR8M/kUrQtFrnicpw=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://WGL0786.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://WGL0786.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://WGL0786.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://WGL0786.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://WGL0786.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="十大排序算法" />
<meta property="og:description" content="十大排序算法是常见的排序算法集合，它们包括冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序和基数排序，每种算法都有不同的优劣和适用场景。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://WGL0786.github.io/posts/sort_algorithm/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-04T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-07-04T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="十大排序算法"/>
<meta name="twitter:description" content="十大排序算法是常见的排序算法集合，它们包括冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序和基数排序，每种算法都有不同的优劣和适用场景。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://WGL0786.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "十大排序算法",
      "item": "http://WGL0786.github.io/posts/sort_algorithm/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "十大排序算法",
  "name": "十大排序算法",
  "description": "十大排序算法是常见的排序算法集合，它们包括冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序和基数排序，每种算法都有不同的优劣和适用场景。",
  "keywords": [
    
  ],
  "articleBody": "1 快速排序 (Quick Sort) 算法步骤：快速排序使用分治法策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：\n从序列中将第一个元素，做为 “基准”(pivot)； 重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。 // 用第一个元素将待排序序列划分成左右两个部分 public static int partition (int[] array, int low, int high) { int pivot = array[low];\t// 第一个元素作为枢轴 while (low \u003c high) {\t// 用 low 和 high 搜索枢轴的最终位置 while (low \u003c high \u0026\u0026 array[high] \u003e= pivot) --high; array[low] = array[high];\t// 比枢轴小的元素移动到左端 while (low \u003c high \u0026\u0026 array[low] \u003c= pivot) ++low; array[high] = array[low];\t// 比枢轴大的元素移动到右端 } array[low] = pivot;\t// 枢轴元素存放的最终位置 return low;\t// 返回存放枢轴的最终位置 } // 快速排序 public static void quickSort (int[] array, int low, int high) { if (low \u003c high) {\t// 递归跳出的条件 int position = partition(array, low, high);\t// 划分 quickSort(array, low, position - 1);\t// 划分左子表 quickSort(array, position + 1, high);\t// 划分右子表 } } 算法分析：\n稳定性 ：不稳定 时间复杂度 ：最佳：O(nlogn)， 最差：O(nlogn)，平均：O(nlogn) 空间复杂度 ：O(nlogn) 2 冒泡排序 (Bubble Sort) 算法步骤：\n比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤 1~3，直到排序完成。 // 冒泡排序函数，接受一个整数类型的数组作为参数，返回排序后的数组 public static int[] bubbleSort (int[] arr) { // 遍历数组，每次比较相邻的两个元素，将较大的元素往后移 for (int i = 0; i \u003c arr.length - 1; i++) { // 用来记录一轮比较中是否有元素交换位置，如果没有则说明数组已经有序，可以提前退出循环 boolean flag = false; for (int j = 0; j \u003c arr.length - i - 1; j++) { if (arr[j] \u003e arr[j + 1]) {\t// 如果前面的元素比后面的元素大，则交换它们的位置 int tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; flag = true; // 标记有元素交换位置 } } if (flag == false) {\t// 如果一轮比较后没有元素交换位置，则说明数组已经有序，可以提前退出循环 break; } } // 返回排序后的数组 return arr; } 算法分析：\n稳定性：稳定 时间复杂度 ：最佳：O(n) ，最差：O(n²)， 平均：O(n²) 空间复杂度 ：O(1) 排序方式 ：In-place 3 选择排序 (Selection Sort) 算法步骤：\n首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第 2 步，直到所有元素均排序完毕。 // 选择排序函数，接受一个整数类型的数组作为参数，返回排序后的数组 public static int[] selectionSort (int[] arr) { // 遍历数组，每次找到未排序部分的最小值，并将其放到已排序部分的末尾 for (int i = 0; i \u003c arr.length - 1; i++) { int minIndex = i; // 遍历未排序部分，找到最小值 for (int j = i + 1; j \u003c arr.length; j++) { if (arr[j] \u003c arr[minIndex]) minIndex = j; } // 如果最小值不是未排序部分的第一个元素，则交换它们的位置 if (minIndex != i) { int tmp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = tmp; } } // 返回排序后的数组 return arr; } 算法分析：\n稳定性：不稳定 时间复杂度 ：最佳：O(n²) ，最差：O(n²)， 平均：O(n²) 空间复杂度 ：O(1) 排序方式 ：In-place 4 插入排序 (Insertion Sort) 算法步骤：\n从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤 2~5。 // 插入排序函数，接受一个整数类型的数组作为参数，返回排序后的数组 public static int[] insertionSort (int[] arr) { // 遍历数组，从第二个元素开始 for (int i = 1; i \u003c arr.length; i++) { // 记录当前元素的前一个元素下标 int preIndex = i - 1; // 记录当前元素的值 int current = arr[i]; // 将当前元素插入到已排序的数组中 while (preIndex \u003e= 0 \u0026\u0026 current \u003c arr[preIndex]) { // 将元素后移一位 arr[preIndex + 1] = arr[preIndex]; // 更新前一个元素下标 preIndex -= 1; } // 将当前元素插入到正确的位置 arr[preIndex + 1] = current; } // 返回排序后的数组 return arr; } 算法分析：\n稳定性：稳定 时间复杂度 ：最佳：O(n) ，最差：O(n²)， 平均：O(n²) 空间复杂度 ：O(1) 排序方式 ：In-place 5 希尔排序 (Shell Sort) 算法步骤：\n​\t我们来看下希尔排序的基本步骤，在此我们选择增量 gap=length/2，缩小增量继续以 gap = gap/2 的方式，这种增量选择我们可以用一个序列来表示，{n/2, (n/2)/2, ..., 1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。\n先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\n选择一个增量序列 {t1, t2, …, tk}，其中 (ti\u003etj, i； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 t，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 // 希尔排序函数，接受一个整数类型的数组作为参数，返回排序后的数组 public static int[] shellSort(int[] arr) { int gap = arr.length / 2;\t// 初始化间隔为数组长度的一半 // 不断缩小间隔，直到间隔为1结束循环 while (gap \u003e 0) { // 对每个间隔进行插入排序 for (int i = gap; i \u003c n; i++) { int current = arr[i];\t// 记录当前子数组的坐标 int preIndex = i - gap;\t// 减去增量的值就是对应的子数坐标前一位的值 // 对每个子序列进行插入排序 while (preIndex \u003e= 0 \u0026\u0026 arr[preIndex] \u003e current) { // 将元素后移 gap 位 arr[preIndex + gap] = arr[preIndex]; // 更新 gap 位下表 preIndex -= gap; } // 将当前元素插入到正确的位置 arr[preIndex + gap] = current; } // 缩小增量 gap /= 2; } // 返回排序后的数组 return arr; } 算法分析：\n稳定性：稳定 时间复杂度 ：最佳：O(nlogn)， 最差：O(n²) 平均：O(nlogn) 空间复杂度 ：O(1) 6 归并排序 (Merge Sort) 算法步骤：\n归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下：\n如果输入内只有一个元素，则直接返回，否则将长度为 n 的输入序列分成两个长度为 n/2 的子序列； 分别对这两个子序列进行归并排序，使子序列变为有序状态； 设定两个指针，分别指向两个已经排序子序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置； 重复步骤 3 ~4 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 /** * 归并排序 * @param arr 要排序的整数数组 * @return arr 排序后的整数数组 */ public static int[] mergeSort (int[] arr) { if (arr.length \u003c= 1) { return arr; } // 将数组分为两半 int middle = arr.length / 2; // 将一个原始的数组 arr 从下标 0 开始复制，复制到上标 middle 生成一个新的数组 int[] arr_1 = Arrays.copyOfRange(arr, 0, middle); // 将一个原始的数组 arr 从下标 middle 开始复制，复制到上标 arr.length 生成一个新的数组 int[] arr_2 = Arrays.copyOfRange(arr, middle, arr.length); // 返回已排序的新数组 return merge(mergeSort(arr_1), mergeSort(arr_2)); } /** * 合并两个已排序的数组arr_1和arr_2，并返回一个新的已排序数组 * @param arr_1 第一个已排序数组 * @param arr_2 第二个已排序数组 * @return 合并后的已排序数组 */ public static int[] merge (int[] arr_1, int[] arr_2) { // 创建一个新数组，大小为两个输入数组大小之和，用于存储合并后的已排序数组 int[] sorted_arr = new int[arr_1.length + arr_2.length]; // 初始化三个指针，用于遍历输入数组和新数组 int idx = 0, idx_1 = 0, idx_2 = 0; // 通过比较 arr_1 和 arr_2 中的元素，将两个数组中较小的元素逐个放入新数组中，直到有一个数组的所有元素都被放入新数组 while (idx_1 \u003c arr_1.length \u0026\u0026 idx_2 \u003c arr_2.length) { // 如果 arr_1 的元素小于 arr_2 的元素 if (arr_1[idx_1] \u003c arr_2[idx_2]) { // 将 arr_1 的元素放到新建的数组中 sorted_arr[idx] = arr_1[idx_1]; // arr_1 数组的指针指向下一位元素 idx_1 += 1; } else { sorted_arr[idx] = arr_2[idx_2]; idx_2 += 1; } // 元素插入后，更新新建数组的指针指向下一位元素中 idx += 1; } // 将剩下的未放入新数组的元素放入新数组中，其中一个 while 循环会被执行 if (idx_1 \u003c arr_1.length) { while (idx_1 \u003c arr_1.length) { sorted_arr[idx] = arr_1[idx_1]; idx_1 += 1; idx += 1; } } else { while (idx_2 \u003c arr_2.length) { sorted_arr[idx] = arr_2[idx_2]; idx_2 += 1; idx += 1; } } // 返回已排序的新数组 return sorted_arr; } 算法分析：\n稳定性：稳定 时间复杂度 ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn) 空间复杂度 ：O(n) 7 堆排序 (Heap Sort) 算法步骤：\n将初始待排序列 (R1, R2, ……, Rn) 构建成大顶堆，此堆为初始的无序区； 将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1, R2, ……, Rn-1) 和新的有序区 (Rn), 且满足 R[1, 2, ……, n-1]\u003c=R[n]； 由于交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1, R2, ……, Rn-1) 调整为新堆，然后再次将 R [1] 与无序区最后一个元素交换，得到新的无序区 (R1, R2, ……, Rn-2) 和新的有序区 (Rn-1, Rn)。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。 // 全局变量，记录一个数组长度 static int heapLen; /** * 交换一个数组中的两个元素 * @param arr * @param i * @param j */ private static void swap (int[] arr, int i, int j) { int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } /** * 构建大根堆 * @param arr */ private static void buildMaxHeap (int[] arr) { // 从倒数第二层开始，逐层向上构建大根堆。因为倒数第一层都是叶子节点，不需要调整，所以从倒数第二层开始 for (int i = arr.length / 2; i \u003e 0; i--) { heapify(arr, i); } } /** * 堆调整函数 * @param arr 待调整的数组 * @param i 待调整的节点下标 */ private static void heapify (int[] arr, int i) { int largest = i; // 暂定 i 为最大节点 int left = 2 * i + 1; // 左子树 int right = 2 * i + 2; // 右子树 // 如果左子节点存在且大于当前最大节点，则更新最大节点为左子节点 if (left \u003c heapLen \u0026\u0026 arr[left] \u003e arr[largest]) largest = left; // 如果右子节点存在且大于当前最大节点，则更新最大节点为右子节点 if (right \u003c heapLen \u0026\u0026 arr[right] \u003e arr[largest]) largest = right; // 如果最大节点不是当前节点，则交换最大节点和当前节点，继续向下调整 if (largest != i) { swap(arr, largest, i); heapify(arr, largest); } } /** * 堆排序 * @param arr 要排序的整数数组 * @return 排序后的整数数组 */ public static int[] heapSort (int[] arr) { heapLen = arr.length;\t// 将堆的长度设置为数组的长度 buildMaxHeap(arr);\t// 建立大根堆 for (int i = arr.length - 1; i \u003e 0; i--) {\t// 对堆进行排序 swap(arr, 0, i);\t// 将堆顶元素与最后一个元素交换 heapLen -= 1;\t// 堆的长度减 1 heapify(arr, 0);\t// 对交换后的堆进行调整，使其重新成为最大堆 } return arr;\t// 返回排序后的数组 } 算法分析：\n稳定性 ：不稳定 时间复杂度 ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn) 空间复杂度 ：O(1) 8 计数排序 (Counting Sort) 算法步骤：\n找出数组中的最大值 max、最小值 min； 创建一个新数组 C，其长度是 max-min+1，其元素默认值都为 0； 遍历原数组 A 中的元素 A[i]，以 A[i]-min 作为 C 数组的索引，以 A[i] 的值在 A 中元素出现次数作为 C[A[i]-min] 的值； 对 C 数组变形，新元素的值是该元素与前一个元素值的和，即当 i\u003e1 时 C[i] = C[i] + C[i-1]； 创建结果数组 R，长度和原始数组一样。 从后向前遍历原始数组 A 中的元素 A[i]，使用 A[i] 减去最小值 min 作为索引，在计数数组 C 中找到对应的值 C[A[i]-min]，C[A[i]-min]-1 就是 A[i] 在结果数组 R 中的位置，做完上述这些操作，将 count[A[i]-min] 减小 1。 /** * 获取数组中的最大值和最小值。 * @param arr 待查找的数组 * @return 包含最大值和最小值的数组，第一个元素为最小值，第二个元素为最大值 */ private static int[] getMinAndMax(int[] arr) { int maxValue = arr[0]; // 定义变量 maxValue，并将其赋值为数组的第一个元素，用于记录最大值 int minValue = arr[0]; // 定义变量 minValue，并将其赋值为数组的第一个元素，用于记录最小值 for (int i = 0; i \u003c arr.length; i++) { // 遍历整个数组，寻找最大值和最小值 if (arr[i] \u003e maxValue) { // 如果当前元素大于 maxValue，将 maxValue 更新为当前元素 maxValue = arr[i]; } else if (arr[i] \u003c minValue) { // 如果当前元素小于 minValue，将 minValue 更新为当前元素 minValue = arr[i]; } } return new int[] { minValue, maxValue }; // 将最小值和最大值封装成数组并返回 } /** * 计数排序 * @param arr 待排序数组 * @return 返回排序结果数组 */ public static int[] countingSort(int[] arr) { if (arr.length \u003c 2) { return arr;\t// 如果待排序数组长度小于 2，直接返回数组 } int[] extremum = getMinAndMax(arr);\t// 获取待排序数组中的最小值和最大值 int minValue = extremum[0];\t// 最小值 int maxValue = extremum[1]; // 最大值 int[] countArr = new int[maxValue - minValue + 1]; // 存储计数信息的数组 int[] result = new int[arr.length]; // 存储排序结果的数组 // 统计每个数字出现的次数，存储在 countArr 中 for (int i = 0; i \u003c arr.length; i++) { countArr[arr[i] - minValue] += 1; // 将 arr[i] 出现的次数加 1 } // 计算 countArr 中每个元素在排序结果中所处的下标位置 for (int i = 1; i \u003c countArr.length; i++) { countArr[i] += countArr[i - 1]; // 将 countArr[i] 增加 countArr[i-1]，即表示小于等于 i 的元素个数 } // 从后往前遍历待排序数组，依次将每个元素放入结果数组中的正确位置 for (int i = arr.length - 1; i \u003e= 0; i--) { int idx = countArr[arr[i] - minValue] - 1;\t// 获取元素 arr[i] 在结果数组中的下标 result[idx] = arr[i]; // 将 arr[i] 放入结果数组中的对应位置 countArr[arr[i] - minValue] -= 1;\t// 将 countArr 中对应元素的值减 1，以保证相同元素的下标递减 } return result; // 返回排序结果数组 } 算法分析：\n​\t当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n+k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。\n稳定性 ：稳定 时间复杂度 ：最佳：O(n+k) 最差：O(n+k) 平均：O(n+k) 空间复杂度 ：O(k) 9 桶排序 (Bucket Sort) 算法步骤：\n设置一个 BucketSize，作为每个桶所能放置多少个不同数值； 遍历输入数据，并且把数据依次映射到对应的桶里去； 对每个非空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序； 从非空桶里把排好序的数据拼接起来。 /** * 获取列表中的最大值和最小值。 * @param arr 待查找的列表 * @return 包含最大值和最小值的列表，第一个元素为最小值，第二个元素为最大值 */ private static int[] getMinAndMax(List\u003cInteger\u003e arr) { int maxValue = arr.get(0);\t// 初始化最大值为列表的第一个元素 int minValue = arr.get(0);\t// 初始化最小值为列表的第一个元素 for (int i : arr) {\t// 遍历整个列表 if (i \u003e maxValue) {\t// 如果当前元素大于最大值，则更新最大值 maxValue = i; } else if (i \u003c minValue) { // 如果当前元素小于最小值，则更新最小值 minValue = i; } } return new int[] { minValue, maxValue };\t// 返回最小值和最大值的数组 } /** * 桶排序 * @param arr 待排序列表 * @param bucket_size 桶的大小 * @return 返回排序结果列表 */ public static List\u003cInteger\u003e bucketSort(List\u003cInteger\u003e arr, int bucket_size) { // 如果数组长度小于等于2，或者桶的大小为0，直接返回原数组 if (arr.size() \u003c 2 || bucket_size == 0) { return arr; } int[] extremum = getMinAndMax(arr);\t// 获取数组中的最小值和最大值 int minValue = extremum[0]; int maxValue = extremum[1]; int bucket_cnt = (maxValue - minValue) / bucket_size + 1;\t// 计算桶的数量 List\u003cList\u003cInteger\u003e\u003e buckets = new ArrayList\u003c\u003e();\t// 创建桶 for (int i = 0; i \u003c bucket_cnt; i++) { buckets.add(new ArrayList\u003cInteger\u003e()); } for (int element : arr) {\t// 将数组中的元素放入对应的桶中 int idx = (element - minValue) / bucket_size; buckets.get(idx).add(element); } for (int i = 0; i \u003c buckets.size(); i++) {\t// 对桶中的元素进行排序 if (buckets.get(i).size() \u003e 1) { buckets.set(i, sort(buckets.get(i), bucket_size / 2)); } } ArrayList\u003cInteger\u003e result = new ArrayList\u003c\u003e();\t// 将排序后的元素按顺序放入结果数组中 for (List\u003cInteger\u003e bucket : buckets) { for (int element : bucket) { result.add(element); } } return result;\t// 返回排序后的结果数组 } 算法分析：\n稳定性 ：稳定 时间复杂度 ：最佳：O(n+k) 最差：O(n²) 平均：O(n+k) 空间复杂度 ：O(k) 10 基数排序 (Radix Sort) 算法步骤：\n取得数组中的最大数，并取得位数，即为迭代次数 N（例如：数组中最大数值为 1000，则 N=4）； A 为原始数组，从最低位开始取每个位组成 radix 数组； 对 radix 进行计数排序（利用计数排序适用于小范围数的特点）； 将 radix 依次赋值给原数组； 重复 2~4 步骤 N 次 /** * 基数排序 * @param arr 待排序数组 * @return 返回排序结果数组 */ public static int[] radixSort(int[] arr) { if (arr.length \u003c 2) {\t// 如果数组长度小于2，直接返回原数组 return arr; } int N = 1; // 用于记录数值位数的变量，初始化为1 int maxValue = arr[0]; // 用于记录最大值的变量，初始化为数组第一个元素 // 循环找到数组中的最大值 for (int element : arr) { if (element \u003e maxValue) { maxValue = element; } } // 计算最大值的位数 while (maxValue / 10 != 0) { maxValue = maxValue / 10; N += 1; } // 进行 N 次循环，每次循环将数组按照一位进行排序 for (int i = 0; i \u003c N; i++) { // 创建一个 List 数组来保存当前位数下每个数字出现的所有元素 List\u003cList\u003cInteger\u003e\u003e radix = new ArrayList\u003c\u003e(); for (int k = 0; k \u003c 10; k++) { radix.add(new ArrayList\u003cInteger\u003e()); } // 将数组中的元素按照当前位数分配到对应的桶里 for (int element : arr) { // pow() 方法用于返回第一个参数的第二个参数次方，计算当前元素在当前位数上的数字 int idx = (element / (int) Math.pow(10, i)) % 10; radix.get(idx).add(element); // 将当前元素放入对应的桶里 } // 将桶里的元素依次放回原数组，完成一次排序 int idx = 0; for (List\u003cInteger\u003e l : radix) { for (int n : l) { arr[idx++] = n; } } } return arr; // 返回排好序的数组 } 算法分析：\n稳定性 ：稳定 时间复杂度 ：最佳：O(n×k) 最差：O(n×k) 平均：O(n×k) 空间复杂度 ：O(n+k) 基数排序 vs 计数排序 vs 桶排序：\n这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\n基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 ",
  "wordCount" : "1862",
  "inLanguage": "en",
  "datePublished": "2023-07-04T00:00:00Z",
  "dateModified": "2023-07-04T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://WGL0786.github.io/posts/sort_algorithm/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "WGL",
    "logo": {
      "@type": "ImageObject",
      "url": "http://WGL0786.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://WGL0786.github.io/" accesskey="h" title="WGL (Alt + H)">WGL</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://WGL0786.github.io/archives/" title="档案">
                    <span>档案</span>
                </a>
            </li>
            <li>
                <a href="http://WGL0786.github.io/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://WGL0786.github.io/">Home</a>&nbsp;»&nbsp;<a href="http://WGL0786.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      十大排序算法
    </h1>
    <div class="post-meta"><span title='2023-07-04 00:00:00 +0000 UTC'>July 4, 2023</span>&nbsp;·&nbsp;9 min

</div>
  </header> 
  <div class="post-content"><h3 id="1-快速排序-quick-sort">1 快速排序 (Quick Sort)<a hidden class="anchor" aria-hidden="true" href="#1-快速排序-quick-sort">#</a></h3>
<p>算法步骤：快速排序使用分治法策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：</p>
<ol>
<li>从序列中将第一个元素，做为 “基准”(<code>pivot</code>)；</li>
<li>重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</li>
</ol>
<p><img loading="lazy" src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/random_quick_sort.gif" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 用第一个元素将待排序序列划分成左右两个部分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> low<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> high<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> array<span style="color:#f92672">[</span>low<span style="color:#f92672">];</span>				<span style="color:#75715e">// 第一个元素作为枢轴
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  	<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>low <span style="color:#f92672">&lt;</span> high<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>					<span style="color:#75715e">// 用 low 和 high 搜索枢轴的最终位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      	<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> array<span style="color:#f92672">[</span>high<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;=</span> pivot<span style="color:#f92672">)</span> <span style="color:#f92672">--</span>high<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      	array<span style="color:#f92672">[</span>low<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> array<span style="color:#f92672">[</span>high<span style="color:#f92672">];</span>	<span style="color:#75715e">// 比枢轴小的元素移动到左端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      	<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> array<span style="color:#f92672">[</span>low<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;=</span> pivot<span style="color:#f92672">)</span> <span style="color:#f92672">++</span>low<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>      	array<span style="color:#f92672">[</span>high<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> array<span style="color:#f92672">[</span>low<span style="color:#f92672">];</span>	<span style="color:#75715e">// 比枢轴大的元素移动到右端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  	array<span style="color:#f92672">[</span>low<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> pivot<span style="color:#f92672">;</span>						<span style="color:#75715e">// 枢轴元素存放的最终位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  	<span style="color:#66d9ef">return</span> low<span style="color:#f92672">;</span>										<span style="color:#75715e">// 返回存放枢轴的最终位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 快速排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quickSort</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> array<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> low<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> high<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>low <span style="color:#f92672">&lt;</span> high<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>																	<span style="color:#75715e">// 递归跳出的条件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> position <span style="color:#f92672">=</span> partition<span style="color:#f92672">(</span>array<span style="color:#f92672">,</span> low<span style="color:#f92672">,</span> high<span style="color:#f92672">);</span>		<span style="color:#75715e">// 划分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        quickSort<span style="color:#f92672">(</span>array<span style="color:#f92672">,</span> low<span style="color:#f92672">,</span> position <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">);</span>					<span style="color:#75715e">// 划分左子表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        quickSort<span style="color:#f92672">(</span>array<span style="color:#f92672">,</span> position <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">,</span> high<span style="color:#f92672">);</span>					<span style="color:#75715e">// 划分右子表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性 ：不稳定</li>
<li>时间复杂度 ：最佳：O(nlogn)， 最差：O(nlogn)，平均：O(nlogn)</li>
<li>空间复杂度 ：O(nlogn)</li>
</ul>
<h3 id="2-冒泡排序-bubble-sort">2 冒泡排序 (Bubble Sort)<a hidden class="anchor" aria-hidden="true" href="#2-冒泡排序-bubble-sort">#</a></h3>
<p>算法步骤：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤 1~3，直到排序完成。</li>
</ol>
<p><img loading="lazy" src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/bubble_sort.gif" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 冒泡排序函数，接受一个整数类型的数组作为参数，返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">bubbleSort</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历数组，每次比较相邻的两个元素，将较大的元素往后移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 用来记录一轮比较中是否有元素交换位置，如果没有则说明数组已经有序，可以提前退出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">boolean</span> flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> arr<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">])</span> <span style="color:#f92672">{</span>	<span style="color:#75715e">// 如果前面的元素比后面的元素大，则交换它们的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>                arr<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>                arr<span style="color:#f92672">[</span>j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> tmp<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>                flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span> 						<span style="color:#75715e">// 标记有元素交换位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>flag <span style="color:#f92672">==</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>						<span style="color:#75715e">// 如果一轮比较后没有元素交换位置，则说明数组已经有序，可以提前退出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性：稳定</li>
<li>时间复杂度 ：最佳：O(n) ，最差：O(n²)， 平均：O(n²)</li>
<li>空间复杂度 ：O(1)</li>
<li>排序方式 ：In-place</li>
</ul>
<h3 id="3-选择排序-selection-sort">3 选择排序 (Selection Sort)<a hidden class="anchor" aria-hidden="true" href="#3-选择排序-selection-sort">#</a></h3>
<p>算法步骤：</p>
<ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第 2 步，直到所有元素均排序完毕。</li>
</ol>
<p><img loading="lazy" src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/selection_sort.gif" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 选择排序函数，接受一个整数类型的数组作为参数，返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">selectionSort</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历数组，每次找到未排序部分的最小值，并将其放到已排序部分的末尾
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> minIndex <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历未排序部分，找到最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">[</span>minIndex<span style="color:#f92672">])</span> minIndex <span style="color:#f92672">=</span> j<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果最小值不是未排序部分的第一个元素，则交换它们的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minIndex <span style="color:#f92672">!=</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>minIndex<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            arr<span style="color:#f92672">[</span>minIndex<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> tmp<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性：不稳定</li>
<li>时间复杂度 ：最佳：O(n²) ，最差：O(n²)， 平均：O(n²)</li>
<li>空间复杂度 ：O(1)</li>
<li>排序方式 ：In-place</li>
</ul>
<h3 id="4-插入排序-insertion-sort">4 插入排序 (Insertion Sort)<a hidden class="anchor" aria-hidden="true" href="#4-插入排序-insertion-sort">#</a></h3>
<p>算法步骤：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤 2~5。</li>
</ol>
<p><img loading="lazy" src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/insertion_sort.gif" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 插入排序函数，接受一个整数类型的数组作为参数，返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">insertionSort</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历数组，从第二个元素开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 记录当前元素的前一个元素下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> preIndex <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 记录当前元素的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> current <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将当前元素插入到已排序的数组中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>preIndex <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> current <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">[</span>preIndex<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 将元素后移一位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            arr<span style="color:#f92672">[</span>preIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>preIndex<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 更新前一个元素下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            preIndex <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将当前元素插入到正确的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        arr<span style="color:#f92672">[</span>preIndex <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">]</span> <span style="color:#f92672">=</span> current<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性：稳定</li>
<li>时间复杂度 ：最佳：O(n) ，最差：O(n²)， 平均：O(n²)</li>
<li>空间复杂度 ：O(1)</li>
<li>排序方式 ：In-place</li>
</ul>
<h3 id="5-希尔排序-shell-sort">5 希尔排序 (Shell Sort)<a hidden class="anchor" aria-hidden="true" href="#5-希尔排序-shell-sort">#</a></h3>
<p>算法步骤：</p>
<p>​		我们来看下希尔排序的基本步骤，在此我们选择增量 <code>gap=length/2</code>，缩小增量继续以 <code>gap = gap/2</code> 的方式，这种增量选择我们可以用一个序列来表示，<code>{n/2, (n/2)/2, ..., 1}</code>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列 <code>{t1, t2, …, tk}</code>，其中 <code>(ti&gt;tj, i&lt;j, tk=1)</code>；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 <code>t</code>，将待排序列分割成若干长度为 <code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<p><img loading="lazy" src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/shell_sort.png" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 希尔排序函数，接受一个整数类型的数组作为参数，返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">shellSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> gap <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span>		<span style="color:#75715e">// 初始化间隔为数组长度的一半
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 不断缩小间隔，直到间隔为1结束循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>gap <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 对每个间隔进行插入排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> gap<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> n<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> current <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>		<span style="color:#75715e">// 记录当前子数组的坐标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> preIndex <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> gap<span style="color:#f92672">;</span>	<span style="color:#75715e">// 减去增量的值就是对应的子数坐标前一位的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 对每个子序列进行插入排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>preIndex <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> arr<span style="color:#f92672">[</span>preIndex<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> current<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 将元素后移 gap 位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                arr<span style="color:#f92672">[</span>preIndex <span style="color:#f92672">+</span> gap<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>preIndex<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>              	<span style="color:#75715e">// 更新 gap 位下表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                preIndex <span style="color:#f92672">-=</span> gap<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        		<span style="color:#75715e">// 将当前元素插入到正确的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            arr<span style="color:#f92672">[</span>preIndex <span style="color:#f92672">+</span> gap<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> current<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 缩小增量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        gap <span style="color:#f92672">/=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性：稳定</li>
<li>时间复杂度 ：最佳：O(nlogn)， 最差：O(n²) 平均：O(nlogn)</li>
<li>空间复杂度 ：O(1)</li>
</ul>
<h3 id="6-归并排序-merge-sort">6 归并排序 (Merge Sort)<a hidden class="anchor" aria-hidden="true" href="#6-归并排序-merge-sort">#</a></h3>
<p>算法步骤：</p>
<p>归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下：</p>
<ol>
<li>如果输入内只有一个元素，则直接返回，否则将长度为 <code>n</code> 的输入序列分成两个长度为 <code>n/2</code> 的子序列；</li>
<li>分别对这两个子序列进行归并排序，使子序列变为有序状态；</li>
<li>设定两个指针，分别指向两个已经排序子序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；</li>
<li>重复步骤 3 ~4 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<p><img loading="lazy" src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/merge_sort.gif" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 归并排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 要排序的整数数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return arr 排序后的整数数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">mergeSort</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 将数组分为两半
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> middle <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 将一个原始的数组 arr 从下标 0 开始复制，复制到上标 middle 生成一个新的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr_1 <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">copyOfRange</span><span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> middle<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 将一个原始的数组 arr 从下标 middle 开始复制，复制到上标 arr.length 生成一个新的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr_2 <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">copyOfRange</span><span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> middle<span style="color:#f92672">,</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 返回已排序的新数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> merge<span style="color:#f92672">(</span>mergeSort<span style="color:#f92672">(</span>arr_1<span style="color:#f92672">),</span> mergeSort<span style="color:#f92672">(</span>arr_2<span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* 合并两个已排序的数组arr_1和arr_2，并返回一个新的已排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* @param arr_1 第一个已排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* @param arr_2 第二个已排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">	* @return 合并后的已排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">merge</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr_1<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr_2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 创建一个新数组，大小为两个输入数组大小之和，用于存储合并后的已排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> sorted_arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>arr_1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">+</span> arr_2<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 初始化三个指针，用于遍历输入数组和新数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> idx_1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> idx_2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 通过比较 arr_1 和 arr_2 中的元素，将两个数组中较小的元素逐个放入新数组中，直到有一个数组的所有元素都被放入新数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>idx_1 <span style="color:#f92672">&lt;</span> arr_1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&amp;&amp;</span> idx_2 <span style="color:#f92672">&lt;</span> arr_2<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      	<span style="color:#75715e">// 如果 arr_1 的元素小于 arr_2 的元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr_1<span style="color:#f92672">[</span>idx_1<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> arr_2<span style="color:#f92672">[</span>idx_2<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          	<span style="color:#75715e">// 将 arr_1 的元素放到新建的数组中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            sorted_arr<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr_1<span style="color:#f92672">[</span>idx_1<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>          	<span style="color:#75715e">// arr_1 数组的指针指向下一位元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            idx_1 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            sorted_arr<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr_2<span style="color:#f92672">[</span>idx_2<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            idx_2 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      	<span style="color:#75715e">// 元素插入后，更新新建数组的指针指向下一位元素中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        idx <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 将剩下的未放入新数组的元素放入新数组中，其中一个 while 循环会被执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>idx_1 <span style="color:#f92672">&lt;</span> arr_1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>idx_1 <span style="color:#f92672">&lt;</span> arr_1<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            sorted_arr<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr_1<span style="color:#f92672">[</span>idx_1<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            idx_1 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            idx <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>idx_2 <span style="color:#f92672">&lt;</span> arr_2<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            sorted_arr<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr_2<span style="color:#f92672">[</span>idx_2<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>            idx_2 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            idx <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 返回已排序的新数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> sorted_arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性：稳定</li>
<li>时间复杂度 ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li>
<li>空间复杂度 ：O(n)</li>
</ul>
<h3 id="7-堆排序-heap-sort">7 堆排序 (Heap Sort)<a hidden class="anchor" aria-hidden="true" href="#7-堆排序-heap-sort">#</a></h3>
<p>算法步骤：</p>
<ol>
<li>将初始待排序列 <code>(R1, R2, ……, Rn)</code> 构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素 <code>R[1]</code> 与最后一个元素 <code>R[n]</code> 交换，此时得到新的无序区 <code>(R1, R2, ……, Rn-1)</code> 和新的有序区 (Rn), 且满足 <code>R[1, 2, ……, n-1]&lt;=R[n]</code>；</li>
<li>由于交换后新的堆顶 <code>R[1]</code> 可能违反堆的性质，因此需要对当前无序区 <code>(R1, R2, ……, Rn-1)</code> 调整为新堆，然后再次将 R [1] 与无序区最后一个元素交换，得到新的无序区 <code>(R1, R2, ……, Rn-2)</code> 和新的有序区 <code>(Rn-1, Rn)</code>。不断重复此过程直到有序区的元素个数为 <code>n-1</code>，则整个排序过程完成。</li>
</ol>
<p><img loading="lazy" src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/heap_sort.gif" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 全局变量，记录一个数组长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> heapLen<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 交换一个数组中的两个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param j
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">swap</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>    arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>    arr<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> tmp<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 构建大根堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">buildMaxHeap</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 从倒数第二层开始，逐层向上构建大根堆。因为倒数第一层都是叶子节点，不需要调整，所以从倒数第二层开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        heapify<span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> i<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 堆调整函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 待调整的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param i   待调整的节点下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">heapify</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> largest <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>              <span style="color:#75715e">// 暂定 i 为最大节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>        			<span style="color:#75715e">// 左子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">;</span>        <span style="color:#75715e">// 右子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 如果左子节点存在且大于当前最大节点，则更新最大节点为左子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">&lt;</span> heapLen <span style="color:#f92672">&amp;&amp;</span> arr<span style="color:#f92672">[</span>left<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> arr<span style="color:#f92672">[</span>largest<span style="color:#f92672">])</span> largest <span style="color:#f92672">=</span> left<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果右子节点存在且大于当前最大节点，则更新最大节点为右子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>right <span style="color:#f92672">&lt;</span> heapLen <span style="color:#f92672">&amp;&amp;</span> arr<span style="color:#f92672">[</span>right<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> arr<span style="color:#f92672">[</span>largest<span style="color:#f92672">])</span> largest <span style="color:#f92672">=</span> right<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果最大节点不是当前节点，则交换最大节点和当前节点，继续向下调整
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>largest <span style="color:#f92672">!=</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        swap<span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> largest<span style="color:#f92672">,</span> i<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        heapify<span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> largest<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 堆排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 要排序的整数数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return 排序后的整数数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">heapSort</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    heapLen <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>		<span style="color:#75715e">// 将堆的长度设置为数组的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buildMaxHeap<span style="color:#f92672">(</span>arr<span style="color:#f92672">);</span>			<span style="color:#75715e">// 建立大根堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>	<span style="color:#75715e">// 对堆进行排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        swap<span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">,</span> i<span style="color:#f92672">);</span>		<span style="color:#75715e">// 将堆顶元素与最后一个元素交换
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        heapLen <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>				<span style="color:#75715e">// 堆的长度减 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        heapify<span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">);</span>		<span style="color:#75715e">// 对交换后的堆进行调整，使其重新成为最大堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>							<span style="color:#75715e">// 返回排序后的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性 ：不稳定</li>
<li>时间复杂度 ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li>
<li>空间复杂度 ：O(1)</li>
</ul>
<h3 id="8-计数排序-counting-sort">8 计数排序 (Counting Sort)<a hidden class="anchor" aria-hidden="true" href="#8-计数排序-counting-sort">#</a></h3>
<p>算法步骤：</p>
<ol>
<li>找出数组中的最大值 <code>max</code>、最小值 <code>min</code>；</li>
<li>创建一个新数组 <code>C</code>，其长度是 <code>max-min+1</code>，其元素默认值都为 0；</li>
<li>遍历原数组 <code>A</code> 中的元素 <code>A[i]</code>，以 <code>A[i]-min</code> 作为 <code>C</code> 数组的索引，以 <code>A[i]</code> 的值在 <code>A</code> 中元素出现次数作为 <code>C[A[i]-min]</code> 的值；</li>
<li>对 <code>C</code> 数组变形，<strong>新元素的值是该元素与前一个元素值的和</strong>，即当 <code>i&gt;1</code> 时 <code>C[i] = C[i] + C[i-1]</code>；</li>
<li>创建结果数组 <code>R</code>，长度和原始数组一样。</li>
<li><strong>从后向前</strong>遍历原始数组 <code>A</code> 中的元素 <code>A[i]</code>，使用 <code>A[i]</code> 减去最小值 <code>min</code> 作为索引，在计数数组 <code>C</code> 中找到对应的值 <code>C[A[i]-min]</code>，<code>C[A[i]-min]-1</code> 就是 <code>A[i]</code> 在结果数组 <code>R</code> 中的位置，做完上述这些操作，将 <code>count[A[i]-min]</code> 减小 1。</li>
</ol>
<p><img loading="lazy" src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/counting_sort.gif" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取数组中的最大值和最小值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 待查找的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return 包含最大值和最小值的数组，第一个元素为最小值，第二个元素为最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">getMinAndMax</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">];</span>    <span style="color:#75715e">// 定义变量 maxValue，并将其赋值为数组的第一个元素，用于记录最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> minValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">];</span>    <span style="color:#75715e">// 定义变量 minValue，并将其赋值为数组的第一个元素，用于记录最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>    <span style="color:#75715e">// 遍历整个数组，寻找最大值和最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&gt;</span> maxValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>    					<span style="color:#75715e">// 如果当前元素大于 maxValue，将 maxValue 更新为当前元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            maxValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> minValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>    		<span style="color:#75715e">// 如果当前元素小于 minValue，将 minValue 更新为当前元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            minValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#f92672">{</span> minValue<span style="color:#f92672">,</span> maxValue <span style="color:#f92672">};</span>    <span style="color:#75715e">// 将最小值和最大值封装成数组并返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 计数排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 待排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return 返回排序结果数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">countingSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>											<span style="color:#75715e">// 如果待排序数组长度小于 2，直接返回数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> extremum <span style="color:#f92672">=</span> getMinAndMax<span style="color:#f92672">(</span>arr<span style="color:#f92672">);</span>	<span style="color:#75715e">// 获取待排序数组中的最小值和最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> minValue <span style="color:#f92672">=</span> extremum<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">];</span>					<span style="color:#75715e">// 最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> maxValue <span style="color:#f92672">=</span> extremum<span style="color:#f92672">[</span><span style="color:#ae81ff">1</span><span style="color:#f92672">];</span> 				<span style="color:#75715e">// 最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> countArr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>maxValue <span style="color:#f92672">-</span> minValue <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">];</span> <span style="color:#75715e">// 存储计数信息的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span> <span style="color:#75715e">// 存储排序结果的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 统计每个数字出现的次数，存储在 countArr 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        countArr<span style="color:#f92672">[</span>arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> minValue<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> <span style="color:#75715e">// 将 arr[i] 出现的次数加 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算 countArr 中每个元素在排序结果中所处的下标位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> countArr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        countArr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">+=</span> countArr<span style="color:#f92672">[</span>i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">];</span> 	<span style="color:#75715e">// 将 countArr[i] 增加 countArr[i-1]，即表示小于等于 i 的元素个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从后往前遍历待排序数组，依次将每个元素放入结果数组中的正确位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i<span style="color:#f92672">--)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> countArr<span style="color:#f92672">[</span>arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> minValue<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>	<span style="color:#75715e">// 获取元素 arr[i] 在结果数组中的下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        result<span style="color:#f92672">[</span>idx<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span> 											<span style="color:#75715e">// 将 arr[i] 放入结果数组中的对应位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        countArr<span style="color:#f92672">[</span>arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> minValue<span style="color:#f92672">]</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>						<span style="color:#75715e">// 将 countArr 中对应元素的值减 1，以保证相同元素的下标递减
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span> <span style="color:#75715e">// 返回排序结果数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<p>​		当输入的元素是 <code>n</code> 个 <code>0</code> 到 <code>k</code> 之间的整数时，它的运行时间是 <code>O(n+k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 <code>C</code> 的长度取决于待排序数组中数据的范围（等于待排序数组的<strong>最大值与最小值的差加上 1</strong>），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。</p>
<ul>
<li>稳定性 ：稳定</li>
<li>时间复杂度 ：最佳：<code>O(n+k)</code> 最差：<code>O(n+k)</code> 平均：<code>O(n+k)</code></li>
<li>空间复杂度 ：<code>O(k)</code></li>
</ul>
<h3 id="9-桶排序-bucket-sort">9 桶排序 (Bucket Sort)<a hidden class="anchor" aria-hidden="true" href="#9-桶排序-bucket-sort">#</a></h3>
<p>算法步骤：</p>
<ol>
<li>设置一个 BucketSize，作为每个桶所能放置多少个不同数值；</li>
<li>遍历输入数据，并且把数据依次映射到对应的桶里去；</li>
<li>对每个非空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>
<li>从非空桶里把排好序的数据拼接起来。</li>
</ol>
<p><img loading="lazy" src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/bucket_sort.gif" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 获取列表中的最大值和最小值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 待查找的列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return 包含最大值和最小值的列表，第一个元素为最小值，第二个元素为最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">getMinAndMax</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#ae81ff">0</span><span style="color:#f92672">);</span>		 <span style="color:#75715e">// 初始化最大值为列表的第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> minValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#ae81ff">0</span><span style="color:#f92672">);</span>		 <span style="color:#75715e">// 初始化最小值为列表的第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">:</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>					   <span style="color:#75715e">// 遍历整个列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;</span> maxValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>			   <span style="color:#75715e">// 如果当前元素大于最大值，则更新最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            maxValue <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;</span> minValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// 如果当前元素小于最小值，则更新最小值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            minValue <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#f92672">{</span> minValue<span style="color:#f92672">,</span> maxValue <span style="color:#f92672">};</span>	<span style="color:#75715e">// 返回最小值和最大值的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 桶排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 待排序列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param bucket_size 桶的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return 返回排序结果列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">bucketSort</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> arr<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> bucket_size<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#75715e">// 如果数组长度小于等于2，或者桶的大小为0，直接返回原数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">||</span> bucket_size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> extremum <span style="color:#f92672">=</span> getMinAndMax<span style="color:#f92672">(</span>arr<span style="color:#f92672">);</span>		<span style="color:#75715e">// 获取数组中的最小值和最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> minValue <span style="color:#f92672">=</span> extremum<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> maxValue <span style="color:#f92672">=</span> extremum<span style="color:#f92672">[</span><span style="color:#ae81ff">1</span><span style="color:#f92672">];</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> bucket_cnt <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>maxValue <span style="color:#f92672">-</span> minValue<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> bucket_size <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>		<span style="color:#75715e">// 计算桶的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    List<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;&gt;</span> buckets <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>						<span style="color:#75715e">// 创建桶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> bucket_cnt<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;());</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> element <span style="color:#f92672">:</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>												<span style="color:#75715e">// 将数组中的元素放入对应的桶中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>element <span style="color:#f92672">-</span> minValue<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> bucket_size<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>idx<span style="color:#f92672">).</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>element<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>			<span style="color:#75715e">// 对桶中的元素进行排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">).</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> sort<span style="color:#f92672">(</span>buckets<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">),</span> bucket_size <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">));</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>	<span style="color:#75715e">// 将排序后的元素按顺序放入结果数组中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> bucket <span style="color:#f92672">:</span> buckets<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> element <span style="color:#f92672">:</span> bucket<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            result<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>element<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>		<span style="color:#75715e">// 返回排序后的结果数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性 ：稳定</li>
<li>时间复杂度 ：最佳：<code>O(n+k)</code> 最差：<code>O(n²)</code> 平均：<code>O(n+k)</code></li>
<li>空间复杂度 ：<code>O(k)</code></li>
</ul>
<h3 id="10-基数排序-radix-sort">10 基数排序 (Radix Sort)<a hidden class="anchor" aria-hidden="true" href="#10-基数排序-radix-sort">#</a></h3>
<p>算法步骤：</p>
<ol>
<li>取得数组中的最大数，并取得位数，即为迭代次数 <code>N</code>（例如：数组中最大数值为 1000，则 <code>N=4</code>）；</li>
<li><code>A</code> 为原始数组，从最低位开始取每个位组成 <code>radix</code> 数组；</li>
<li>对 <code>radix</code> 进行计数排序（利用计数排序适用于小范围数的特点）；</li>
<li>将 <code>radix</code> 依次赋值给原数组；</li>
<li>重复 2~4 步骤 <code>N</code> 次</li>
</ol>
<p><img loading="lazy" src="https://wgl-md.oss-cn-beijing.aliyuncs.com/Chapter-11/radix_sort.gif" alt=""  />
</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 基数排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param arr 待排序数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @return 返回排序结果数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> <span style="color:#a6e22e">radixSort</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>		<span style="color:#75715e">// 如果数组长度小于2，直接返回原数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>  						<span style="color:#75715e">// 用于记录数值位数的变量，初始化为1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> maxValue <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span><span style="color:#ae81ff">0</span><span style="color:#f92672">];</span>  <span style="color:#75715e">// 用于记录最大值的变量，初始化为数组第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 循环找到数组中的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> element <span style="color:#f92672">:</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>element <span style="color:#f92672">&gt;</span> maxValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            maxValue <span style="color:#f92672">=</span> element<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算最大值的位数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>maxValue <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        maxValue <span style="color:#f92672">=</span> maxValue <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        N <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 进行 N 次循环，每次循环将数组按照一位进行排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> N<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建一个 List 数组来保存当前位数下每个数字出现的所有元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        List<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;&gt;</span> radix <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span> k <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">;</span> k<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            radix<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;());</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将数组中的元素按照当前位数分配到对应的桶里
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> element <span style="color:#f92672">:</span> arr<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          	<span style="color:#75715e">// pow() 方法用于返回第一个参数的第二个参数次方，计算当前元素在当前位数上的数字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>element <span style="color:#f92672">/</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">pow</span><span style="color:#f92672">(</span><span style="color:#ae81ff">10</span><span style="color:#f92672">,</span> i<span style="color:#f92672">))</span> <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            radix<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>idx<span style="color:#f92672">).</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>element<span style="color:#f92672">);</span>  <span style="color:#75715e">// 将当前元素放入对应的桶里
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将桶里的元素依次放回原数组，完成一次排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> l <span style="color:#f92672">:</span> radix<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">:</span> l<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                arr<span style="color:#f92672">[</span>idx<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">;</span>  <span style="color:#75715e">// 返回排好序的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>算法分析：</p>
<ul>
<li>稳定性 ：稳定</li>
<li>时间复杂度 ：最佳：<code>O(n×k)</code> 最差：<code>O(n×k)</code> 平均：<code>O(n×k)</code></li>
<li>空间复杂度 ：<code>O(n+k)</code></li>
</ul>
<p>基数排序 vs 计数排序 vs 桶排序：</p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="http://WGL0786.github.io/posts/java/">
    <span class="title">« Prev</span>
    <br>
    <span>Java 面经</span>
  </a>
  <a class="next" href="http://WGL0786.github.io/posts/third/">
    <span class="title">Next »</span>
    <br>
    <span>待更新</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    Copyright 
    <span>&copy; 2023 <a href="http://WGL0786.github.io/">WGL</a></span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
